<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Emgu.CV.World</name>
    </assembly>
    <members>
        <member name="T:Emgu.Util.DisposableObject">
            <summary>
            An abstract class that wrap around a disposable object
            </summary>
        </member>
        <member name="F:Emgu.Util.DisposableObject._disposed">
            <summary> Track whether Dispose has been called. </summary>
        </member>
        <member name="M:Emgu.Util.DisposableObject.Dispose">
            <summary>
            The dispose function that implements IDisposable interface
            </summary>
        </member>
        <member name="M:Emgu.Util.DisposableObject.Dispose(System.Boolean)">
            <summary> 
             Dispose(bool disposing) executes in two distinct scenarios.
             If disposing equals true, the method has been called directly
             or indirectly by a user's code. Managed and unmanaged resources
             can be disposed.
             If disposing equals false, the method has been called by the
             runtime from inside the finalizer and you should not reference
             other objects. Only unmanaged resources can be disposed.
            </summary>
             <param name="disposing">
             If disposing equals false, the method has been called by the
             runtime from inside the finalizer and you should not reference
             other objects. Only unmanaged resources can be disposed.
             </param>
        </member>
        <member name="M:Emgu.Util.DisposableObject.ReleaseManagedResources">
            <summary>
            Release the managed resources. This function will be called during the disposal of the current object.
            override ride this function if you need to call the Dispose() function on any managed IDisposable object created by the current object
            </summary>
        </member>
        <member name="M:Emgu.Util.DisposableObject.DisposeObject">
            <summary>
            Release the unmanaged resources
            </summary>
        </member>
        <member name="M:Emgu.Util.DisposableObject.Finalize">
            <summary>
            Destructor
            </summary>
        </member>
        <member name="T:Emgu.Util.EventArgs`1">
            <summary>
            A generic EventArgs
            </summary>
            <typeparam name="T">The type of arguments</typeparam>
        </member>
        <member name="M:Emgu.Util.EventArgs`1.#ctor(`0)">
            <summary>
            Create a generic EventArgs with the specific value
            </summary>
            <param name="value">The value</param>
        </member>
        <member name="P:Emgu.Util.EventArgs`1.Value">
            <summary>
            The value of the EventArgs
            </summary>
        </member>
        <member name="T:Emgu.Util.EventArgs`2">
            <summary>
            A generic EventArgs
            </summary>
            <typeparam name="T1">The type of the first value</typeparam>
            <typeparam name="T2">The type of the second value</typeparam>
        </member>
        <member name="M:Emgu.Util.EventArgs`2.#ctor(`0,`1)">
            <summary>
            Create a generic EventArgs with two values
            </summary>
            <param name="value1">The first value</param>
            <param name="value2">The second value</param>
        </member>
        <member name="P:Emgu.Util.EventArgs`2.Value1">
            <summary>
            The first value
            </summary>
        </member>
        <member name="P:Emgu.Util.EventArgs`2.Value2">
            <summary>
            The second value
            </summary>
        </member>
        <member name="T:Emgu.Util.ICodeGenerable">
            <summary>
            Implement this interface if the object can output code to generate it self.
            </summary>
        </member>
        <member name="M:Emgu.Util.ICodeGenerable.ToCode(Emgu.Util.TypeEnum.ProgrammingLanguage)">
            <summary>
            Return the code to generate the object itself from the specific language
            </summary>
            <param name="language">The programming language to output code</param>
            <returns>The code to generate the object from the specific language</returns>
        </member>
        <member name="T:Emgu.Util.IInterpolatable`1">
            <summary>
            An object that can be interpolated
            </summary>
        </member>
        <member name="M:Emgu.Util.IInterpolatable`1.LinearInterpolate(`0,System.Double)">
            <summary>
            Interpolate base on this point and the other point with the given index
            </summary>
            <param name="other">The other point</param>
            <param name="index">The interpolation index</param>
            <returns>The interpolated point</returns>
        </member>
        <member name="P:Emgu.Util.IInterpolatable`1.InterpolationIndex">
            <summary>
            The index that will be used for interpolation
            </summary>
        </member>
        <member name="T:Emgu.Util.PinnedArray`1">
            <summary>
            A Pinnned array of the specific type
            </summary>
            <typeparam name="T">The type of the array</typeparam>
        </member>
        <member name="M:Emgu.Util.PinnedArray`1.#ctor(System.Int32)">
            <summary>
            Create a Pinnned array of the specific type
            </summary>
            <param name="size">The size of the array</param>
        </member>
        <member name="M:Emgu.Util.PinnedArray`1.AddrOfPinnedObject">
            <summary>
            Get the address of the pinned array
            </summary>
            <returns>A pointer to the address of the the pinned array</returns>
        </member>
        <member name="M:Emgu.Util.PinnedArray`1.ReleaseManagedResources">
            <summary>
            Release the GCHandle
            </summary>
        </member>
        <member name="M:Emgu.Util.PinnedArray`1.DisposeObject">
            <summary>
            Disposed the unmanaged data
            </summary>
        </member>
        <member name="P:Emgu.Util.PinnedArray`1.Array">
            <summary>
            Get the array
            </summary>
        </member>
        <member name="T:Emgu.Util.Platform">
            <summary>
            Provide information for the platform which is using. 
            </summary>
        </member>
        <member name="P:Emgu.Util.Platform.OperationSystem">
            <summary>
            Get the type of the current operating system
            </summary>
        </member>
        <member name="P:Emgu.Util.Platform.ClrType">
            <summary>
            Get the type of the current runtime environment
            </summary>
        </member>
        <member name="T:Emgu.Util.Toolbox">
            <summary>
            utilities functions for Emgu
            </summary>
        </member>
        <member name="M:Emgu.Util.Toolbox.XmlSerialize``1(``0)">
            <summary>
            Convert an object to an xml document
            </summary>
            <typeparam name="T">The type of the object to be converted</typeparam>
            <param name="sourceObject">The object to be serialized</param>
            <returns>An xml document that represents the object</returns>
        </member>
        <member name="M:Emgu.Util.Toolbox.XmlSerialize``1(``0,System.Type[])">
            <summary>
            Convert an object to an xml document
            </summary>
            <typeparam name="T">The type of the object to be converted</typeparam>
            <param name="sourceObject">The object to be serialized</param>
            <param name="knownTypes">Other types that it must known ahead to serialize the object</param>
            <returns>An xml document that represents the object</returns>
        </member>
        <member name="M:Emgu.Util.Toolbox.XmlDeserialize``1(System.Xml.Linq.XDocument)">
            <summary>
            Convert an xml document to an object
            </summary>
            <typeparam name="T">The type of the object to be converted to</typeparam>
            <param name="document">The xml document</param>
            <returns>The object representation as a result of the deserialization of the xml document</returns>
        </member>
        <member name="M:Emgu.Util.Toolbox.XmlDeserialize``1(System.Xml.Linq.XDocument,System.Type[])">
            <summary>
            Convert an xml document to an object
            </summary>
            <typeparam name="T">The type of the object to be converted to</typeparam>
            <param name="xDoc">The xml document</param>
            <param name="knownTypes">Other types that it must known ahead to deserialize the object</param>
            <returns>The object representation as a result of the deserialization of the xml document</returns>
        </member>
        <member name="M:Emgu.Util.Toolbox.XmlStringDeserialize``1(System.String)">
            <summary>
            Convert an xml string to an object
            </summary>
            <typeparam name="T">The type of the object to be converted to</typeparam>
            <param name="xmlString">The xml document as a string</param>
            <returns>The object representation as a result of the deserialization of the xml string</returns>
        </member>
        <member name="M:Emgu.Util.Toolbox.SizeOf``1">
            <summary>
            Similar to Marshal.SizeOf function
            </summary>
            <typeparam name="T">The type</typeparam>
            <returns>The size of T in bytes</returns>
        </member>
        <member name="M:Emgu.Util.Toolbox.MergeBytes(System.Byte[],System.Byte[])">
            <summary>
            Merges two byte vector into one
            </summary>
            <param name="a">the first byte vector to be merged</param>
            <param name="b">the second byte vector to be merged</param>
            <returns>The bytes that is a concatenation of a and b</returns>
        </member>
        <member name="M:Emgu.Util.Toolbox.ExecuteCmd(System.String,System.String)">
            <summary>
            Call a command from command line
            </summary>
            <param name="execFileName">The name of the executable</param>
            <param name="arguments">The arguments to the executable</param>
            <returns>The standard output</returns>
        </member>
        <member name="M:Emgu.Util.Toolbox.GetBaseType(System.Type,System.String)">
            <summary>
            Use reflection to find the base type. If such type do not exist, null is returned
            </summary>
            <param name="currentType">The type to search from</param>
            <param name="baseClassName">The name of the base class to search</param>
            <returns>The base type</returns>
        </member>
        <member name="M:Emgu.Util.Toolbox.ToBytes``1(``0[])">
            <summary>
            Convert some generic vector to vector of Bytes
            </summary>
            <typeparam name="TData">type of the input vector</typeparam>
            <param name="data">array of data</param>
            <returns>the byte vector</returns>
        </member>
        <member name="M:Emgu.Util.Toolbox.LinearInterpolate``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Perform first degree interpolation give the sorted data <paramref name="src"/> and the interpolation <paramref name="indexes"/>
            </summary>
            <param name="src">The sorted data that will be interpolated from</param>
            <param name="indexes">The indexes of the interpolate result</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.Util.Toolbox.LinearSubsample``1(System.Collections.Generic.IEnumerable{``0},System.Double)">
            <summary>
            Get subsamples with the specific rate
            </summary>
            <param name="src">The source which the subsamples will be derived from</param>
            <param name="subsampleRate">The subsample rate</param>
            <returns><paramref name="src"/> subsampled with the specific rate </returns>
        </member>
        <member name="M:Emgu.Util.Toolbox.JoinInterpolatables``1(System.Collections.Generic.IEnumerable{``0}[])">
            <summary>
            Joining multiple index ascending IInterpolatables together as a single index ascending IInterpolatable. 
            </summary>
            <typeparam name="T">The type of objects that will be joined</typeparam>
            <param name="enums">The enumerables, each should be stored in index ascending order</param>
            <returns>A single enumerable sorted in index ascending order</returns>
        </member>
        <member name="M:Emgu.Util.Toolbox.LoadLibrary(System.String)">
            <summary>
            Maps the specified executable module into the address space of the calling process.
            </summary>
            <param name="dllname">The name of the dll</param>
            <returns>The handle to the library</returns>
        </member>
        <member name="M:Emgu.Util.Toolbox.FreeLibrary(System.IntPtr)">
            <summary>
            Decrements the reference count of the loaded dynamic-link library (DLL). When the reference count reaches zero, the module is unmapped from the address space of the calling process and the handle is no longer valid
            </summary>
            <param name="handle">The handle to the library</param>
            <returns>If the function succeeds, the return value is true. If the function fails, the return value is false.</returns>
        </member>
        <member name="M:Emgu.Util.Toolbox.SetDllDirectory(System.String)">
            <summary>
            Adds a directory to the search path used to locate DLLs for the application
            </summary>
            <param name="path">The directory to be searched for DLLs</param>
            <returns>True if success</returns>
        </member>
        <member name="T:Emgu.Util.TypeEnum.OS">
            <summary>
            Type of operating system
            </summary>
        </member>
        <member name="F:Emgu.Util.TypeEnum.OS.Windows">
            <summary>
            Windows
            </summary>
        </member>
        <member name="F:Emgu.Util.TypeEnum.OS.Linux">
            <summary>
            Linux
            </summary>
        </member>
        <member name="F:Emgu.Util.TypeEnum.OS.MacOSX">
            <summary>
            Mac OSX
            </summary>
        </member>
        <member name="F:Emgu.Util.TypeEnum.OS.IOS">
            <summary>
            iOS devices. iPhone, iPad, iPod Touch
            </summary>
        </member>
        <member name="F:Emgu.Util.TypeEnum.OS.Android">
            <summary>
            Android devices
            </summary>
        </member>
        <member name="F:Emgu.Util.TypeEnum.OS.WindowsPhone">
            <summary>
            The windows phone
            </summary>
        </member>
        <member name="T:Emgu.Util.TypeEnum.ClrType">
            <summary>
            The runtime environment
            </summary>
        </member>
        <member name="F:Emgu.Util.TypeEnum.ClrType.DotNet">
            <summary>
            .Net runtime
            </summary>
        </member>
        <member name="F:Emgu.Util.TypeEnum.ClrType.NetFxCore">
            <summary>
            Windows Store app runtime
            </summary>
        </member>
        <member name="F:Emgu.Util.TypeEnum.ClrType.Mono">
            <summary>
            Mono runtime
            </summary>
        </member>
        <member name="T:Emgu.Util.TypeEnum.ProgrammingLanguage">
            <summary>
            The type of Programming languages
            </summary>
        </member>
        <member name="F:Emgu.Util.TypeEnum.ProgrammingLanguage.CSharp">
            <summary>
            C#
            </summary>
        </member>
        <member name="F:Emgu.Util.TypeEnum.ProgrammingLanguage.CPlusPlus">
            <summary>
            C++
            </summary>
        </member>
        <member name="T:Emgu.Util.UnmanagedObject">
            <summary>
            An Unmanaged Object is a disposable object with a Ptr property pointing to the unmanaged object
            </summary>
        </member>
        <member name="F:Emgu.Util.UnmanagedObject._ptr">
            <summary>
            A pointer to the unmanaged object
            </summary>
        </member>
        <member name="M:Emgu.Util.UnmanagedObject.op_Implicit(Emgu.Util.UnmanagedObject)~System.IntPtr">
            <summary>
            Implicit operator for IntPtr
            </summary>
            <param name="obj">The UnmanagedObject</param>
            <returns>The unmanaged pointer for this object</returns>
        </member>
        <member name="P:Emgu.Util.UnmanagedObject.Ptr">
            <summary>
            Pointer to the unmanaged object
            </summary>
        </member>
        <member name="T:Emgu.CV.Affine3d">
            <summary>
            The Affine3 matrix, double precision. 
            </summary>
        </member>
        <member name="M:Emgu.CV.Affine3d.#ctor">
            <summary>
            Create an empty Affine3, double precision matrix
            </summary>
        </member>
        <member name="M:Emgu.CV.Affine3d.Identity">
            <summary>
            Create a new identity matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.Affine3d.Rotate(System.Double,System.Double,System.Double)">
            <summary>
            Rotate the Affine3 matrix by a Rodrigues vector
            </summary>
            <param name="r0">Value of the Rodrigues vector</param>
            <param name="r1">Value of the Rodrigues vector</param>
            <param name="r2">Value of the Rodrigues vector</param>
            <returns>The rotated Affine3 matrix</returns>
        </member>
        <member name="M:Emgu.CV.Affine3d.Translate(System.Double,System.Double,System.Double)">
            <summary>
            Translate the Affine3 matrix by the given value
            </summary>
            <param name="t0">Value of the translation vector</param>
            <param name="t1">Value of the translation vector</param>
            <param name="t2">Value of the translation vector</param>
            <returns>The translated Affine3 matrix</returns>
        </member>
        <member name="M:Emgu.CV.Affine3d.GetValues">
            <summary>
            Get the 3x3 matrix's value as a double vector (of size 9)
            </summary>
            <returns>The 3x3 matrix's value as a double vector (of size 9)</returns>
        </member>
        <member name="M:Emgu.CV.Affine3d.DisposeObject">
            <summary>
            Release the unmanged memory associated with this Affine3 model
            </summary>
        </member>
        <member name="T:Emgu.CV.CvInvoke">
            <summary>
            Library to invoke OpenCV functions
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.StringMarshalType">
            <summary>
            string marshaling type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.BoolMarshalType">
            <summary>
            Represent a bool value in C++
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.BoolToIntMarshalType">
            <summary>
            Represent a int value in C++
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.CvCallingConvention">
            <summary>
            Opencv's calling convention
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.ExternLibrary">
            <summary>
            The file name of the cvextern library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.ExternCudaLibrary">
            <summary>
            The file name of the cvextern library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpencvFFMpegLibrary">
            <summary>
            The file name of the opencv_ffmpeg library
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveVideoCaptureCreateFromDevice(System.Int32)">
            <summary>
            Allocates and initialized the CvCapture structure for reading a video stream from the camera. Currently two camera interfaces can be used on Windows: Video for Windows (VFW) and Matrox Imaging Library (MIL); and two on Linux: V4L and FireWire (IEEE1394). 
            </summary>
            <param name="index">Index of the camera to be used. If there is only one camera or it does not matter what camera to use -1 may be passed</param>
            <returns>Pointer to the capture structure</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveVideoCaptureCreateFromFile(System.IntPtr)">
             <summary>
             Allocates and initialized the CvCapture structure for reading the video stream from the specified file. 
            After the allocated structure is not used any more it should be released by cvReleaseCapture function. 
             </summary>
             <param name="filename">Name of the video file.</param>
             <returns>Pointer to the capture structure.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveVideoCaptureRelease(System.IntPtr@)">
            <summary>
            The function cvReleaseCapture releases the CvCapture structure allocated by cvCreateFileCapture or cvCreateCameraCapture
            </summary>
            <param name="capture">pointer to video capturing structure.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveVideoCaptureRead(System.IntPtr,System.IntPtr)">
            <summary>
            Grabs a frame from camera or video file, decompresses and returns it. This function is just a combination of cvGrabFrame and cvRetrieveFrame in one call. 
            </summary>
            <param name="capture">Video capturing structure</param>
            <param name="frame">The output frame</param>
            <returns>true id a frame is read</returns>
            <remarks>The returned image should not be released or modified by user. </remarks>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveVideoCaptureGrab(System.IntPtr)">
            <summary>
            Grab a frame
            </summary>
            <param name="capture">Video capturing structure</param>
            <returns>True on success</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveVideoCaptureRetrieve(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Get the frame grabbed with cvGrabFrame(..)
            This function may apply some frame processing like frame decompression, flipping etc.
            </summary>
            <param name="capture">Video capturing structure</param>
            <param name="image">The output image</param>
            <param name="flag">The frame retrieve flag</param>
            <returns>True on success</returns>
            <remarks>The returned image should not be released or modified by user. </remarks>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveVideoCaptureGet(System.IntPtr,Emgu.CV.CvEnum.CapProp)">
            <summary>
            Retrieves the specified property of camera or video file
            </summary>
            <param name="capture">Video capturing structure</param>
            <param name="prop">Property identifier</param>
            <returns>The specified property of camera or video file</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveVideoCaptureSet(System.IntPtr,Emgu.CV.CvEnum.CapProp,System.Double)">
            <summary>
            Sets the specified property of video capturing
            </summary>
            <param name="capture">Video capturing structure</param>
            <param name="propertyId">Property identifier</param>
            <param name="value">Value of the property</param>
            <returns>True on success</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CheckLibraryLoaded">
            <summary>
            Check to make sure all the unmanaged libraries are loaded
            </summary>
            <returns>True if library loaded</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.LoadUnmanagedModules(System.String,System.String[])">
            <summary>
            Attempts to load opencv modules from the specific location
            </summary>
            <param name="loadDirectory">The directory where the unmanaged modules will be loaded. If it is null, the default location will be used.</param>
            <param name="unmanagedModules">The names of opencv modules. e.g. "opencv_cxcore.dll" on windows.</param>
            <returns>True if all the modules has been loaded successfully</returns>
            <remarks>If <paramref name="loadDirectory"/> is null, the default location on windows is the dll's path appended by either "x64" or "x86", depends on the applications current mode.</remarks>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetModuleFormatString">
            <summary>
            Get the module format string.
            </summary>
            <returns>On Windows, "{0}".dll will be returned; On Linux, "lib{0}.so" will be returned; Otherwise {0} is returned.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.DefaultLoadUnmanagedModules(System.String[])">
            <summary>
            Attempts to load opencv modules from the specific location
            </summary>
            <param name="modules">The names of opencv modules. e.g. "opencv_cxcore.dll" on windows.</param>
            <returns>True if all the modules has been loaded successfully</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.#cctor">
            <summary>
            Static Constructor to setup opencv environment
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetDepthType(Emgu.CV.CvEnum.DepthType)">
            <summary>
            Get the corresponding depth type
            </summary>
            <param name="t">The opencv depth type</param>
            <returns>The equivalent depth type</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetDepthType(System.Type)">
            <summary>
            Get the corresponding opencv depth type
            </summary>
            <param name="t">The element type</param>
            <returns>The equivalent opencv depth type</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MakeType(Emgu.CV.CvEnum.DepthType,System.Int32)">
            <summary>
            This function performs the same as MakeType macro
            </summary>
            <param name="depth">The type of depth</param>
            <param name="channels">The number of channels</param>
            <returns>An interger tha represent a mat type</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SanityCheck">
            <summary>
            Check if the size of the C structures match those of C#
            </summary>
            <returns>True if the size matches</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindHomography(System.Drawing.PointF[],System.Drawing.PointF[],Emgu.CV.CvEnum.HomographyMethod,System.Double,Emgu.CV.IOutputArray)">
            <summary>
            Finds perspective transformation H=||h_ij|| between the source and the destination planes
            </summary>
            <param name="srcPoints">Point coordinates in the original plane</param>
            <param name="dstPoints">Point coordinates in the destination plane</param>
            <param name="method">FindHomography method</param>
            <param name="ransacReprojThreshold">
            The maximum allowed reprojection error to treat a point pair as an inlier. 
            The parameter is only used in RANSAC-based homography estimation. 
            E.g. if dst_points coordinates are measured in pixels with pixel-accurate precision, it makes sense to set this parameter somewhere in the range ~1..3
            </param>
            <param name="mask">Optional output mask set by a robust method ( CV_RANSAC or CV_LMEDS ). Note that the input mask values are ignored.</param>
            <returns>The 3x3 homography matrix if found. Null if not found.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindHomography(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.HomographyMethod,System.Double,Emgu.CV.IOutputArray)">
            <summary>
            Finds perspective transformation H=||hij|| between the source and the destination planes
            </summary>
            <param name="srcPoints">Point coordinates in the original plane, 2xN, Nx2, 3xN or Nx3 array (the latter two are for representation in homogeneous coordinates), where N is the number of points. </param>
            <param name="dstPoints">Point coordinates in the destination plane, 2xN, Nx2, 3xN or Nx3 array (the latter two are for representation in homogeneous coordinates) </param>
            <param name="method">The type of the method</param>
            <param name="ransacReprojThreshold">The maximum allowed re-projection error to treat a point pair as an inlier. The parameter is only used in RANSAC-based homography estimation. E.g. if dst_points coordinates are measured in pixels with pixel-accurate precision, it makes sense to set this parameter somewhere in the range ~1..3</param>
            <param name="mask">The optional output mask set by a robust method (RANSAC or LMEDS). </param>
            <returns>Output 3x3 homography matrix. Homography matrix is determined up to a scale, thus it is normalized to make h33=1</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Rodrigues(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray)">
            <summary>
            Converts a rotation vector to rotation matrix or vice versa. Rotation vector is a compact representation of rotation matrix. Direction of the rotation vector is the rotation axis and the length of the vector is the rotation angle around the axis. 
            </summary>
            <param name="src">The input rotation vector (3x1 or 1x3) or rotation matrix (3x3). </param>
            <param name="dst">The output rotation matrix (3x3) or rotation vector (3x1 or 1x3), respectively</param>
            <param name="jacobian">Optional output Jacobian matrix, 3x9 or 9x3 - partial derivatives of the output array components w.r.t the input array components</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindEssentialMat(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.FmType,System.Double,System.Double,Emgu.CV.IOutputArray)">
            <summary>
            Calculates an essential matrix from the corresponding points in two images.
            </summary>
            <param name="points1">Array of N (N &gt;= 5) 2D points from the first image. The point coordinates should be floating-point (single or double precision).</param>
            <param name="points2">Array of the second image points of the same size and format as points1</param>
            <param name="cameraMatrix">Camera matrix K=[[fx 0 cx][0 fy cy][0 0 1]]. Note that this function assumes that points1 and points2 are feature points from cameras with the same camera matrix.</param>
            <param name="method">Method for computing a fundamental matrix. RANSAC for the RANSAC algorithm. LMEDS for the LMedS algorithm</param>
            <param name="prob">Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of confidence (probability) that the estimated matrix is correct.</param>
            <param name="threshold">Parameter used for RANSAC. It is the maximum distance from a point to an epipolar line in pixels, beyond which the point is considered an outlier and is not used for computing the final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the point localization, image resolution, and the image noise.</param>
            <param name="mask">Output array of N elements, every element of which is set to 0 for outliers and to 1 for the other points. The array is computed only in the RANSAC and LMedS methods.</param>
            <returns>The essential mat</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindFundamentalMat(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.FmType,System.Double,System.Double,Emgu.CV.IOutputArray)">
            <summary>
            Calculates fundamental matrix using one of four methods listed above and returns the number of fundamental matrices found (1 or 3) and 0, if no matrix is found. 
            </summary>
            <param name="points1">Array of N points from the first image. The point coordinates should be floating-point (single or double precision).</param>
            <param name="points2">Array of the second image points of the same size and format as points1 </param>
            <param name="method">Method for computing the fundamental matrix </param>
            <param name="param1">Parameter used for RANSAC. It is the maximum distance from a point to an epipolar line in pixels, beyond which the point is considered an outlier and is not used for computing the final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the point localization, image resolution, and the image noise.</param>
            <param name="param2">Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of confidence (probability) that the estimated matrix is correct.</param>
            <param name="mask">The optional pointer to output array of N elements, every element of which is set to 0 for outliers and to 1 for the "inliers", i.e. points that comply well with the estimated epipolar geometry. The array is computed only in RANSAC and LMedS methods. For other methods it is set to all 1.</param>
            <returns>The calculated fundamental matrix </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ComputeCorrespondEpilines(Emgu.CV.IInputArray,System.Int32,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            For every point in one of the two images of stereo-pair the function cvComputeCorrespondEpilines finds equation of a line that contains the corresponding point (i.e. projection of the same 3D point) in the other image. Each line is encoded by a vector of 3 elements l=[a,b,c]^T, so that: 
            l^T*[x, y, 1]^T=0, or
            a*x + b*y + c = 0
            From the fundamental matrix definition (see cvFindFundamentalMatrix discussion), line l2 for a point p1 in the first image (which_image=1) can be computed as: 
            l2=F*p1 and the line l1 for a point p2 in the second image (which_image=1) can be computed as: 
            l1=F^T*p2Line coefficients are defined up to a scale. They are normalized (a2+b2=1) are stored into correspondent_lines
            </summary>
            <param name="points">The input points. 2xN, Nx2, 3xN or Nx3 array (where N number of points). Multi-channel 1xN or Nx1 array is also acceptable.</param>
            <param name="whichImage">Index of the image (1 or 2) that contains the points</param>
            <param name="fundamentalMatrix">Fundamental matrix </param>
            <param name="correspondentLines">Computed epilines, 3xN or Nx3 array </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ConvertPointsToHomogeneous(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Converts points from Euclidean to homogeneous space.
            </summary>
            <param name="src">Input vector of N-dimensional points.</param>
            <param name="dst">Output vector of N+1-dimensional points.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ConvertPointsFromHomogeneous(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Converts points from homogeneous to Euclidean space.
            </summary>
            <param name="src">Input vector of N-dimensional points.</param>
            <param name="dst">Output vector of N-1-dimensional points.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ReprojectImageTo3D(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,System.Boolean,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Transforms 1-channel disparity map to 3-channel image, a 3D surface.
            </summary>
            <param name="disparity">Disparity map</param>
            <param name="image3D">3-channel, 16-bit integer or 32-bit floating-point image - the output map of 3D points</param>
            <param name="q">The reprojection 4x4 matrix, can be arbitrary, e.g. the one, computed by cvStereoRectify</param>
            <param name="handleMissingValues">Indicates, whether the function should handle missing values (i.e. points where the disparity was not computed). 
            If handleMissingValues=true, then pixels with the minimal disparity that corresponds to the outliers (see StereoMatcher::compute ) 
            are transformed to 3D points with a very large Z value (currently set to 10000).</param>
            <param name="ddepth">The optional output array depth. If it is -1, the output image will have CV_32F depth. ddepth can also be set to CV_16S, CV_32S or CV_32F.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetOptimalNewCameraMatrix(Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.Size,System.Double,System.Drawing.Size,System.Drawing.Rectangle@,System.Boolean)">
            <summary>
            Returns the new camera matrix based on the free scaling parameter.
            </summary>
            <param name="cameraMatrix">	Input camera matrix.</param>
            <param name="distCoeffs">Input vector of distortion coefficients (k1,k2,p1,p2[,k3[,k4,k5,k6[,s1,s2,s3,s4[,?x,?y]]]]) of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</param>
            <param name="imageSize">Original image size.</param>
            <param name="alpha">Free scaling parameter between 0 (when all the pixels in the undistorted image are valid) and 1 (when all the source image pixels are retained in the undistorted image).</param>
            <param name="newImgSize">Image size after rectification. By default,it is set to imageSize .</param>
            <param name="validPixROI">output rectangle that outlines all-good-pixels region in the undistorted image. </param>
            <param name="centerPrincipalPoint">indicates whether in the new camera matrix the principal point should be at the image center or not. By default, the principal point is chosen to best fit a subset of the source image (determined by alpha) to the corrected image.</param>
            <returns>The new camera matrix based on the free scaling parameter.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.InitCameraMatrix2D(Emgu.CV.IInputArrayOfArrays,Emgu.CV.IInputArrayOfArrays,System.Drawing.Size,System.Double)">
            <summary>
            Finds an initial camera matrix from 3D-2D point correspondences.
            </summary>
            <param name="objectPoints">Vector of vectors of the calibration pattern points in the calibration pattern coordinate space.</param>
            <param name="imagePoints">Vector of vectors of the projections of the calibration pattern points.</param>
            <param name="imageSize">Image size in pixels used to initialize the principal point.</param>
            <param name="aspectRatio">If it is zero or negative, both fx and fy are estimated independently. Otherwise, fx=fy*aspectRatio.</param>
            <returns>An initial camera matrix for the camera calibration process.</returns>
            <remarks>Currently, the function only supports planar calibration patterns, which are patterns where each object point has z-coordinate =0.</remarks>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ProjectPoints(Emgu.CV.Structure.MCvPoint3D32f[],Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double)">
            <summary>
            Computes projections of 3D points to the image plane given intrinsic and extrinsic camera parameters. 
            Optionally, the function computes jacobians - matrices of partial derivatives of image points as functions of all the input parameters w.r.t. the particular parameters, intrinsic and/or extrinsic. 
            The jacobians are used during the global optimization in cvCalibrateCamera2 and cvFindExtrinsicCameraParams2. 
            The function itself is also used to compute back-projection error for with current intrinsic and extrinsic parameters. 
            </summary>
            <remarks>Note, that with intrinsic and/or extrinsic parameters set to special values, the function can be used to compute just extrinsic transformation or just intrinsic transformation (i.e. distortion of a sparse set of points) </remarks>
            <param name="objectPoints">The array of object points.</param>
            <param name="rvec">The rotation vector, 1x3 or 3x1</param>
            <param name="tvec">The translation vector, 1x3 or 3x1</param>
            <param name="cameraMatrix">The camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1]. </param>
            <param name="distCoeffs">The vector of distortion coefficients, 4x1 or 1x4 [k1, k2, p1, p2]. If it is IntPtr.Zero, all distortion coefficients are considered 0's</param>
            <returns>The output array of image points, 2xN or Nx2, where N is the total number of points in the view</returns>
            <param name="aspectRatio">Aspect ratio</param>
            <param name="jacobian">Optional output 2Nx(10+&lt;numDistCoeffs&gt;) jacobian matrix of derivatives of image points with respect to components of the rotation vector, translation vector, focal lengths, coordinates of the principal point and the distortion coefficients. In the old interface different components of the jacobian are returned via different output parameters.</param>
            <returns>The array of image points which is the projection of <paramref name="objectPoints"/></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ProjectPoints(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Double)">
            <summary>
            Computes projections of 3D points to the image plane given intrinsic and extrinsic camera parameters. Optionally, the function computes jacobians - matrices of partial derivatives of image points as functions of all the input parameters w.r.t. the particular parameters, intrinsic and/or extrinsic. The jacobians are used during the global optimization in cvCalibrateCamera2 and cvFindExtrinsicCameraParams2. The function itself is also used to compute back-projection error for with current intrinsic and extrinsic parameters.
            Note, that with intrinsic and/or extrinsic parameters set to special values, the function can be used to compute just extrinsic transformation or just intrinsic transformation (i.e. distortion of a sparse set of points). 
            </summary>
            <param name="objectPoints">The array of object points, 3xN or Nx3, where N is the number of points in the view</param>
            <param name="rvec">The rotation vector, 1x3 or 3x1</param>
            <param name="tvec">The translation vector, 1x3 or 3x1</param>
            <param name="cameraMatrix">The camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1]. </param>
            <param name="distCoeffs">The vector of distortion coefficients, 4x1 or 1x4 [k1, k2, p1, p2]. If it is IntPtr.Zero, all distortion coefficients are considered 0's</param>
            <param name="imagePoints">The output array of image points, 2xN or Nx2, where N is the total number of points in the view</param>
            <param name="aspectRatio">Aspect ratio</param>
            <param name="jacobian">Optional output 2Nx(10+&lt;numDistCoeffs&gt;) jacobian matrix of derivatives of image points with respect to components of the rotation vector, translation vector, focal lengths, coordinates of the principal point and the distortion coefficients. In the old interface different components of the jacobian are returned via different output parameters.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalibrateCamera(Emgu.CV.Structure.MCvPoint3D32f[][],System.Drawing.PointF[][],System.Drawing.Size,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.CvEnum.CalibType,Emgu.CV.Structure.MCvTermCriteria,Emgu.CV.Mat[]@,Emgu.CV.Mat[]@)">
            <summary>
            Estimates intrinsic camera parameters and extrinsic parameters for each of the views
            </summary>
            <param name="objectPoints">The 3D location of the object points. The first index is the index of image, second index is the index of the point</param>
            <param name="imagePoints">The 2D image location of the points. The first index is the index of the image, second index is the index of the point</param>
            <param name="imageSize">The size of the image, used only to initialize intrinsic camera matrix</param>
            <param name="rotationVectors">The output 3xM or Mx3 array of rotation vectors (compact representation of rotation matrices, see cvRodrigues2). </param>
            <param name="translationVectors">The output 3xM or Mx3 array of translation vectors</param>/// <param name="calibrationType">cCalibration type</param>
            <param name="termCriteria">The termination criteria</param>
            <param name="cameraMatrix">The output camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1]. If CV_CALIB_USE_INTRINSIC_GUESS and/or CV_CALIB_FIX_ASPECT_RATION are specified, some or all of fx, fy, cx, cy must be initialized</param>
            <param name="distortionCoeffs">The output 4x1 or 1x4 vector of distortion coefficients [k1, k2, p1, p2]</param>
            <returns>The final reprojection error</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalibrateCamera(Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.CalibType,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Estimates intrinsic camera parameters and extrinsic parameters for each of the views
            </summary>
            <param name="objectPoints">The joint matrix of object points, 3xN or Nx3, where N is the total number of points in all views</param>
            <param name="imagePoints">The joint matrix of corresponding image points, 2xN or Nx2, where N is the total number of points in all views</param>
            <param name="imageSize">Size of the image, used only to initialize intrinsic camera matrix</param>
            <param name="cameraMatrix">The output camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1]. If CV_CALIB_USE_INTRINSIC_GUESS and/or CV_CALIB_FIX_ASPECT_RATION are specified, some or all of fx, fy, cx, cy must be initialized</param>
            <param name="distortionCoeffs">The output 4x1 or 1x4 vector of distortion coefficients [k1, k2, p1, p2]</param>
            <param name="rotationVectors">The output 3xM or Mx3 array of rotation vectors (compact representation of rotation matrices, see cvRodrigues2). </param>
            <param name="translationVectors">The output 3xM or Mx3 array of translation vectors</param>
            <param name="flags">Different flags</param>
            <param name="termCriteria">The termination criteria</param>
            <returns>The final reprojection error</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalibrationMatrixValues(Emgu.CV.IInputArray,System.Drawing.Size,System.Double,System.Double,System.Double@,System.Double@,System.Double@,Emgu.CV.Structure.MCvPoint2D64f@,System.Double@)">
            <summary>
            Computes various useful camera (sensor/lens) characteristics using the computed camera calibration matrix, image frame resolution in pixels and the physical aperture size
            </summary>
            <param name="cameraMatrix">The matrix of intrinsic parameters</param>
            <param name="imageSize">Image size in pixels</param>
            <param name="apertureWidth">Aperture width in real-world units (optional input parameter). Set it to 0 if not used</param>
            <param name="apertureHeight">Aperture width in real-world units (optional input parameter). Set it to 0 if not used</param>
            <param name="fovx">Field of view angle in x direction in degrees</param>
            <param name="fovy">Field of view angle in y direction in degrees </param>
            <param name="focalLength">Focal length in real-world units </param>
            <param name="principalPoint">The principal point in real-world units </param>
            <param name="aspectRatio">The pixel aspect ratio ~ fy/f</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SolvePnP(Emgu.CV.Structure.MCvPoint3D32f[],System.Drawing.PointF[],Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Boolean,Emgu.CV.CvEnum.SolvePnpMethod)">
            <summary>
            Estimates extrinsic camera parameters using known intrinsic parameters and extrinsic parameters for each view. The coordinates of 3D object points and their correspondent 2D projections must be specified. This function also minimizes back-projection error. 
            </summary>
            <param name="objectPoints">The array of object points</param>
            <param name="imagePoints">The array of corresponding image points</param>
            <param name="intrinsicMatrix">The camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1]. </param>
            <param name="distortionCoeffs">The vector of distortion coefficients, 4x1 or 1x4 [k1, k2, p1, p2]. If it is IntPtr.Zero, all distortion coefficients are considered 0's.</param>
            <param name="rotationVector">The output 3x1 or 1x3 rotation vector (compact representation of a rotation matrix, see cvRodrigues2). </param>
            <param name="translationVector">The output 3x1 or 1x3 translation vector</param>
            <param name="useExtrinsicGuess">Use the input rotation and translation parameters as a guess</param>
            <param name="method">Method for solving a PnP problem</param>
            <returns>The extrinsic parameters</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SolvePnP(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Boolean,Emgu.CV.CvEnum.SolvePnpMethod)">
            <summary>
            Estimates extrinsic camera parameters using known intrinsic parameters and extrinsic parameters for each view. The coordinates of 3D object points and their correspondent 2D projections must be specified. This function also minimizes back-projection error
            </summary>
            <param name="objectPoints">The array of object points, 3xN or Nx3, where N is the number of points in the view</param>
            <param name="imagePoints">The array of corresponding image points, 2xN or Nx2, where N is the number of points in the view</param>
            <param name="intrinsicMatrix">The camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1]. </param>
            <param name="distortionCoeffs">The vector of distortion coefficients, 4x1 or 1x4 [k1, k2, p1, p2]. If it is IntPtr.Zero, all distortion coefficients are considered 0's.</param>
            <param name="rotationVector">The output 3x1 or 1x3 rotation vector (compact representation of a rotation matrix, see cvRodrigues2). </param>
            <param name="translationVector">The output 3x1 or 1x3 translation vector</param>
            <param name="useExtrinsicGuess">Use the input rotation and translation parameters as a guess</param>
            <param name="flags">Method for solving a PnP problem</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SolvePnPRansac(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Boolean,System.Int32,System.Single,System.Double,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.SolvePnpMethod)">
            <summary>
            Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.
            </summary>
            <param name="objectPoints">Array of object points in the object coordinate space, 3xN/Nx3 1-channel or 1xN/Nx1 3-channel, where N is the number of points. VectorOfPoint3D32f can be also passed here.</param>
            <param name="imagePoints">Array of corresponding image points, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel, where N is the number of points. VectorOfPointF can be also passed here.</param>
            <param name="cameraMatrix">Input camera matrix</param>
            <param name="distCoeffs">Input vector of distortion coefficients of 4, 5, 8 or 12 elements. If the vector is null/empty, the zero distortion coefficients are assumed.</param>
            <param name="rvec">Output rotation vector </param>
            <param name="tvec">Output translation vector.</param>
            <param name="useExtrinsicGuess">If true, the function uses the provided rvec and tvec values as initial approximations of the rotation and translation vectors, respectively, and further optimizes them.</param>
            <param name="iterationsCount">Number of iterations.</param>
            <param name="reprojectionError">Inlier threshold value used by the RANSAC procedure. The parameter value is the maximum allowed distance between the observed and computed point projections to consider it an inlier.</param>
            <param name="confident">The probability that the algorithm produces a useful result.</param>
            <param name="inliers">Output vector that contains indices of inliers in objectPoints and imagePoints .</param>
            <param name="flags">Method for solving a PnP problem </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.StereoCalibrate(Emgu.CV.Structure.MCvPoint3D32f[][],System.Drawing.PointF[][],System.Drawing.PointF[][],Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,System.Drawing.Size,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.CalibType,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Estimates transformation between the 2 cameras making a stereo pair. If we have a stereo camera, where the relative position and orientatation of the 2 cameras is fixed, and if we computed poses of an object relative to the first camera and to the second camera, (R1, T1) and (R2, T2), respectively (that can be done with cvFindExtrinsicCameraParams2), obviously, those poses will relate to each other, i.e. given (R1, T1) it should be possible to compute (R2, T2) - we only need to know the position and orientation of the 2nd camera relative to the 1st camera. That's what the described function does. It computes (R, T) such that:
            R2=R*R1,
            T2=R*T1 + T
            </summary>
            <param name="objectPoints">The 3D location of the object points. The first index is the index of image, second index is the index of the point</param>
            <param name="imagePoints1">The 2D image location of the points for camera 1. The first index is the index of the image, second index is the index of the point</param>
            <param name="imagePoints2">The 2D image location of the points for camera 2. The first index is the index of the image, second index is the index of the point</param>
            <param name="cameraMatrix1">The input/output camera matrices [fxk 0 cxk; 0 fyk cyk; 0 0 1]. If CV_CALIB_USE_INTRINSIC_GUESS or CV_CALIB_FIX_ASPECT_RATIO are specified, some or all of the elements of the matrices must be initialized</param>
            <param name="distCoeffs1">The input/output vectors of distortion coefficients for each camera, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="cameraMatrix2">The input/output camera matrices [fxk 0 cxk; 0 fyk cyk; 0 0 1]. If CV_CALIB_USE_INTRINSIC_GUESS or CV_CALIB_FIX_ASPECT_RATIO are specified, some or all of the elements of the matrices must be initialized</param>
            <param name="distCoeffs2">The input/output vectors of distortion coefficients for each camera, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="imageSize">Size of the image, used only to initialize intrinsic camera matrix</param>
            <param name="r">The rotation matrix between the 1st and the 2nd cameras' coordinate systems </param>
            <param name="t">The translation vector between the cameras' coordinate systems</param>
            <param name="e">The optional output essential matrix</param>
            <param name="f">The optional output fundamental matrix </param>
            <param name="termCrit">Termination criteria for the iterative optimization algorithm</param>
            <param name="flags">The calibration flags</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.StereoCalibrate(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,System.Drawing.Size,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.CalibType,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Estimates transformation between the 2 cameras making a stereo pair. If we have a stereo camera, where the relative position and orientatation of the 2 cameras is fixed, and if we computed poses of an object relative to the fist camera and to the second camera, (R1, T1) and (R2, T2), respectively (that can be done with cvFindExtrinsicCameraParams2), obviously, those poses will relate to each other, i.e. given (R1, T1) it should be possible to compute (R2, T2) - we only need to know the position and orientation of the 2nd camera relative to the 1st camera. That's what the described function does. It computes (R, T) such that:
            R2=R*R1,
            T2=R*T1 + T
            </summary>
            <param name="objectPoints">The joint matrix of object points, 3xN or Nx3, where N is the total number of points in all views</param>
            <param name="imagePoints1">The joint matrix of corresponding image points in the views from the 1st camera, 2xN or Nx2, where N is the total number of points in all views</param>
            <param name="imagePoints2">The joint matrix of corresponding image points in the views from the 2nd camera, 2xN or Nx2, where N is the total number of points in all views</param>
            <param name="cameraMatrix1">The input/output camera matrices [fxk 0 cxk; 0 fyk cyk; 0 0 1]. If CV_CALIB_USE_INTRINSIC_GUESS or CV_CALIB_FIX_ASPECT_RATIO are specified, some or all of the elements of the matrices must be initialized</param>
            <param name="distCoeffs1">The input/output vectors of distortion coefficients for each camera, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="cameraMatrix2">The input/output camera matrices [fxk 0 cxk; 0 fyk cyk; 0 0 1]. If CV_CALIB_USE_INTRINSIC_GUESS or CV_CALIB_FIX_ASPECT_RATIO are specified, some or all of the elements of the matrices must be initialized</param>
            <param name="distCoeffs2">The input/output vectors of distortion coefficients for each camera, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="imageSize">Size of the image, used only to initialize intrinsic camera matrix</param>
            <param name="r">The rotation matrix between the 1st and the 2nd cameras' coordinate systems </param>
            <param name="t">The translation vector between the cameras' coordinate systems</param>
            <param name="e">The optional output essential matrix</param>
            <param name="f">The optional output fundamental matrix </param>
            <param name="termCrit">Termination criteria for the iterative optimization algorithm</param>
            <param name="flags">The calibration flags</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.StereoRectifyUncalibrated(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Double)">
            <summary>
            computes the rectification transformations without knowing intrinsic parameters of the cameras and their relative position in space, hence the suffix "Uncalibrated". Another related difference from cvStereoRectify is that the function outputs not the rectification transformations in the object (3D) space, but the planar perspective transformations, encoded by the homography matrices H1 and H2. The function implements the following algorithm [Hartley99]. 
            </summary>
            <remarks>
            Note that while the algorithm does not need to know the intrinsic parameters of the cameras, it heavily depends on the epipolar geometry. Therefore, if the camera lenses have significant distortion, it would better be corrected before computing the fundamental matrix and calling this function. For example, distortion coefficients can be estimated for each head of stereo camera separately by using cvCalibrateCamera2 and then the images can be corrected using cvUndistort2
            </remarks>
            <param name="points1">The array of 2D points</param>
            <param name="points2">The array of 2D points</param>
            <param name="f">Fundamental matrix. It can be computed using the same set of point pairs points1 and points2 using cvFindFundamentalMat</param>
            <param name="imgSize">Size of the image</param>
            <param name="h1">The rectification homography matrices for the first images</param>
            <param name="h2">The rectification homography matrices for the second images</param>
            <param name="threshold">If the parameter is greater than zero, then all the point pairs that do not comply the epipolar geometry well enough (that is, the points for which fabs(points2[i]T*F*points1[i])>threshold) are rejected prior to computing the homographies</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.StereoRectify(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.StereoRectifyType,System.Double,System.Drawing.Size,System.Drawing.Rectangle@,System.Drawing.Rectangle@)">
            <summary>
            computes the rotation matrices for each camera that (virtually) make both camera image planes the same plane. Consequently, that makes all the epipolar lines parallel and thus simplifies the dense stereo correspondence problem. On input the function takes the matrices computed by cvStereoCalibrate and on output it gives 2 rotation matrices and also 2 projection matrices in the new coordinates. The function is normally called after cvStereoCalibrate that computes both camera matrices, the distortion coefficients, R and T
            </summary>
            <param name="cameraMatrix1">The camera matrices [fx_k 0 cx_k; 0 fy_k cy_k; 0 0 1]</param>
            <param name="cameraMatrix2">The camera matrices [fx_k 0 cx_k; 0 fy_k cy_k; 0 0 1]</param>
            <param name="distCoeffs1">The vectors of distortion coefficients for first camera, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="distCoeffs2">The vectors of distortion coefficients for second camera, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="imageSize">Size of the image used for stereo calibration</param>
            <param name="r">The rotation matrix between the 1st and the 2nd cameras' coordinate systems</param>
            <param name="t">The translation vector between the cameras' coordinate systems</param>
            <param name="r1">3x3 Rectification transforms (rotation matrices) for the first camera</param>
            <param name="r2">3x3 Rectification transforms (rotation matrices) for the second camera</param>
            <param name="p1">3x4 Projection matrices in the new (rectified) coordinate systems</param>
            <param name="p2">3x4 Projection matrices in the new (rectified) coordinate systems</param>
            <param name="q">The optional output disparity-to-depth mapping matrix, 4x4, see cvReprojectImageTo3D. </param>
            <param name="flags">The operation flags, use ZeroDisparity for default</param>
            <param name="alpha">Use -1 for default</param>
            <param name="newImageSize">Use Size.Empty for default</param>
            <param name="validPixRoi1">The valid pixel ROI for image1</param>
            <param name="validPixRoi2">The valid pixel ROI for image2</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Find4QuadCornerSubpix(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,System.Drawing.Size)">
            <summary>
            Finds subpixel-accurate positions of the chessboard corners
            </summary>
            <param name="image">Source chessboard view; it must be 8-bit grayscale or color image</param>
            <param name="corners">Pointer to the output array of corners(PointF) detected</param>
            <param name="regionSize">region size</param>
            <returns>True if successfull</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindChessboardCorners(Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.CalibCbType)">
            <summary>
            Attempts to determine whether the input image is a view of the chessboard pattern and locate internal chessboard corners
            </summary>
            <param name="image">Source chessboard view; it must be 8-bit grayscale or color image</param>
            <param name="patternSize">The number of inner corners per chessboard row and column</param>
            <param name="corners">Pointer to the output array of corners(PointF) detected</param>
            <param name="flags">Various operation flags</param>
            <returns>True if all the corners have been found and they have been placed in a certain order (row by row, left to right in every row), otherwise, if the function fails to find all the corners or reorder them, it returns 0</returns>
            <remarks>The coordinates detected are approximate, and to determine their position more accurately, the user may use the function cvFindCornerSubPix</remarks>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FilterSpeckles(Emgu.CV.IInputOutputArray,System.Double,System.Int32,System.Double,Emgu.CV.IInputOutputArray)">
            <summary>
            Filters off small noise blobs (speckles) in the disparity map.
            </summary>
            <param name="img">The input 16-bit signed disparity image</param>
            <param name="newVal">The disparity value used to paint-off the speckles</param>
            <param name="maxSpeckleSize">The maximum speckle size to consider it a speckle. Larger blobs are not affected by the algorithm</param>
            <param name="maxDiff">Maximum difference between neighbor disparity pixels to put them into the same blob. Note that since StereoBM, StereoSGBM and may be other algorithms return a fixed-point disparity map, where disparity values are multiplied by 16, this scale factor should be taken into account when specifying this parameter value.</param>
            <param name="buf">The optional temporary buffer to avoid memory allocation within the function.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.DrawChessboardCorners(Emgu.CV.IInputOutputArray,System.Drawing.Size,Emgu.CV.IInputArray,System.Boolean)">
            <summary>
            Draws the individual chessboard corners detected (as red circles) in case if the board was not found (pattern_was_found=0) or the colored corners connected with lines when the board was found (pattern_was_found != 0). 
            </summary>
            <param name="image">The destination image; it must be 8-bit color image</param>
            <param name="patternSize">The number of inner corners per chessboard row and column</param>
            <param name="corners">The array of corners detected</param>
            <param name="patternWasFound">Indicates whether the complete board was found (!=0) or not (=0). One may just pass the return value cvFindChessboardCorners here. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.TriangulatePoints(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Reconstructs points by triangulation.
            </summary>
            <param name="projMat1">3x4 projection matrix of the first camera.</param>
            <param name="projMat2">3x4 projection matrix of the second camera.</param>
            <param name="projPoints1">2xN array of feature points in the first image. It can be also a vector of feature points or two-channel matrix of size 1xN or Nx1</param>
            <param name="projPoints2">2xN array of corresponding points in the second image. It can be also a vector of feature points or two-channel matrix of size 1xN or Nx1.</param>
            <param name="points4D">4xN array of reconstructed points in homogeneous coordinates.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CorrectMatches(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray)">
            <summary>
            Refines coordinates of corresponding points.
            </summary>
            <param name="f">3x3 fundamental matrix.</param>
            <param name="points1">1xN array containing the first set of points.</param>
            <param name="points2">1xN array containing the second set of points.</param>
            <param name="newPoints1">The optimized points1.</param>
            <param name="newPoints2">The optimized points2.</param>
        </member>
        <member name="F:Emgu.CV.CvInvoke.CvErrorHandlerThrowException">
            <summary>
            The default Exception callback to handle Error thrown by OpenCV
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.CvErrorHandlerIgnoreError">
            <summary>
            An error handler which will ignore any error and continue
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvIgnoreErrorErrorHandler(System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            A custom error handler for OpenCV
            </summary>
            <param name="status">The numeric code for error status</param>
            <param name="funcName">The source file name where error is encountered</param>
            <param name="errMsg">A description of the error</param>
            <param name="fileName">The source file name where error is encountered</param>
            <param name="line">The line number in the source where error is encountered</param>
            <param name="userData">Arbitrary pointer that is transparently passed to the error handler.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvErrorHandler(System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            A custom error handler for OpenCV
            </summary>
            <param name="status">The numeric code for error status</param>
            <param name="funcName">The source file name where error is encountered</param>
            <param name="errMsg">A description of the error</param>
            <param name="fileName">The source file name where error is encountered</param>
            <param name="line">The line number in the source where error is encountered</param>
            <param name="userData">Arbitrary pointer that is transparently passed to the error handler.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.RedirectError(Emgu.CV.CvInvoke.CvErrorCallback,System.IntPtr,System.IntPtr)">
            <summary>
            Sets a new error handler that can be one of standard handlers or a custom handler that has the certain interface. The handler takes the same parameters as cvError function. If the handler returns non-zero value, the program is terminated, otherwise, it continues. The error handler may check the current error mode with cvGetErrMode to make a decision.
            </summary>
            <param name="errorHandler">The new error handler</param>
            <param name="userdata">Arbitrary pointer that is transparently passed to the error handler.</param>
            <param name="prevUserdata">Pointer to the previously assigned user data pointer.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.RedirectError(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Sets a new error handler that can be one of standard handlers or a custom handler that has the certain interface. The handler takes the same parameters as cvError function. If the handler returns non-zero value, the program is terminated, otherwise, it continues. The error handler may check the current error mode with cvGetErrMode to make a decision.
            </summary>
            <param name="errorHandler">Pointer to the new error handler</param>
            <param name="userdata">Arbitrary pointer that is transparently passed to the error handler.</param>
            <param name="prevUserdata">Pointer to the previously assigned user data pointer.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SetErrMode(System.Int32)">
            <summary>
            Sets the specified error mode.
            </summary>
            <param name="errorMode">The error mode</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetErrMode">
            <summary>
            Returns the current error mode
            </summary>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetErrStatus">
            <summary>
            Returns the current error status - the value set with the last cvSetErrStatus call. Note, that in Leaf mode the program terminates immediately after error occurred, so to always get control after the function call, one should call cvSetErrMode and set Parent or Silent error mode.
            </summary>
            <returns>the current error status</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SetErrStatus(Emgu.CV.CvEnum.ErrorCodes)">
            <summary>
            Sets the error status to the specified value. Mostly, the function is used to reset the error status (set to it CV_StsOk) to recover after error. In other cases it is more natural to call cvError or CV_ERROR.
            </summary>
            <param name="code">The error status.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ErrorStr(System.Int32)">
            <summary>
            Returns the textual description for the specified error status code. In case of unknown status the function returns NULL pointer. 
            </summary>
            <param name="status">The error status</param>
            <returns>the textual description for the specified error status code.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReshape(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            initializes CvMat header so that it points to the same data as the original array but has different shape - different number of channels, different number of rows or both
            </summary>
            <param name="arr">Input array</param>
            <param name="header">Output header to be filled</param>
            <param name="newCn">New number of channels. new_cn = 0 means that number of channels remains unchanged</param>
            <param name="newRows">New number of rows. new_rows = 0 means that number of rows remains unchanged unless it needs to be changed according to new_cn value. destination array to be changed</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Repeat(Emgu.CV.IInputArray,System.Int32,System.Int32,Emgu.CV.IOutputArray)">
            <summary>
            Fills the destination array with source array tiled:
            dst(i,j)=src(i mod rows(src), j mod cols(src))So the destination array may be as larger as well as smaller than the source array
            </summary>
            <param name="src">Source array, image or matrix</param>
            <param name="dst">Destination array, image or matrix</param>
            <param name="nx">Flag to specify how many times the src is repeated along the vertical axis.</param>
            <param name="ny">Flag to specify how many times the src is repeated along the horizontal axis.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Merge(Emgu.CV.IInputArrayOfArrays,Emgu.CV.IOutputArray)">
            <summary>
            This function is the opposite to cvSplit. If the destination array has N channels then if the first N input channels are not IntPtr.Zero, all they are copied to the destination array, otherwise if only a single source channel of the first N is not IntPtr.Zero, this particular channel is copied into the destination array, otherwise an error is raised. Rest of source channels (beyond the first N) must always be IntPtr.Zero. For IplImage cvCopy with COI set can be also used to insert a single channel into the image. 
            </summary>
            <param name="mv">Input vector of matrices to be merged; all the matrices in mv must have the same size and the same depth.</param>
            <param name="dst">output array of the same size and the same depth as mv[0]; The number of channels will be the total number of channels in the matrix array.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MixChannels(Emgu.CV.IInputArrayOfArrays,Emgu.CV.IInputOutputArray,System.Int32[])">
            <summary>
            The function cvMixChannels is a generalized form of cvSplit and cvMerge and some forms of cvCvtColor. It can be used to change the order of the planes, add/remove alpha channel, extract or insert a single plane or multiple planes etc.
            </summary>
            <param name="src">The array of input arrays.</param>
            <param name="dst">The array of output arrays</param>
            <param name="fromTo">The array of pairs of indices of the planes copied. from_to[k*2] is the 0-based index of the input plane, and from_to[k*2+1] is the index of the output plane, where the continuous numbering of the planes over all the input and over all the output arrays is used. When from_to[k*2] is negative, the corresponding output plane is filled with 0's.</param>
            <remarks>Unlike many other new-style C++ functions in OpenCV, mixChannels requires the output arrays to be pre-allocated before calling the function.</remarks>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ExtractChannel(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32)">
            <summary>
            Extract the specific channel from the image
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The channel</param>
            <param name="coi">0 based index of the channel to be extracted</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.InsertChannel(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,System.Int32)">
            <summary>
            Insert the specific channel to the image
            </summary>
            <param name="src">The source channel</param>
            <param name="dst">The destination image where the channel will be inserted into</param>
            <param name="coi">0-based index of the channel to be inserted</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.RandShuffle(Emgu.CV.IInputOutputArray,System.Double,System.UInt64)">
            <summary>
            Shuffles the matrix by swapping randomly chosen pairs of the matrix elements on each iteration (where each element may contain several components in case of multi-channel arrays)
            </summary>
            <param name="mat">The input/output matrix. It is shuffled in-place. </param>
            <param name="rng">Pointer to MCvRNG random number generator. Use 0 if not sure</param>
            <param name="iterFactor">The relative parameter that characterizes intensity of the shuffling performed. The number of iterations (i.e. pairs swapped) is round(iter_factor*rows(mat)*cols(mat)), so iter_factor=0 means that no shuffling is done, iter_factor=1 means that the function swaps rows(mat)*cols(mat) random pairs etc</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BitwiseNot(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Inverses every bit of every array element:
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array</param>
            <param name="mask">The optional mask for the operation, use null to ignore</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Max(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Calculates per-element maximum of two arrays:
            dst(I)=max(src1(I), src2(I))
            All the arrays must have a single channel, the same data type and the same size (or ROI size).
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array. </param>
            <param name="dst">The destination array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CountNonZero(Emgu.CV.IInputArray)">
            <summary>
            Returns the number of non-zero elements in arr:
            result = sumI arr(I)!=0
            In case of IplImage both ROI and COI are supported.
            </summary>
            <param name="arr">The image</param>
            <returns>the number of non-zero elements in image</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindNonZero(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Find the location of the non-zero pixel
            </summary>
            <param name="src">The source array</param>
            <param name="idx">The output array where the location of the pixels are sorted</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PSNR(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Computes PSNR image/video quality metric
            </summary>
            <param name="src1">The first source image</param>
            <param name="src2">The second source image</param>
            <returns>the quality metric</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Min(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Calculates per-element minimum of two arrays:
            dst(I)=min(src1(I),src2(I))
            All the arrays must have a single channel, the same data type and the same size (or ROI size).
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Add(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Adds one array to another one:
            dst(I)=src1(I)+src2(I) if mask(I)!=0All the arrays must have the same type, except the mask, and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array.</param>
            <param name="src2">The second source array.</param>
            <param name="dst">The destination array.</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed. </param>
            <param name="dtype">Optional depth type of the output array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Subtract(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Subtracts one array from another one:
            dst(I)=src1(I)-src2(I) if mask(I)!=0
            All the arrays must have the same type, except the mask, and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
            <param name="dtype">Optional depth of the output array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Divide(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Divides one array by another:
            dst(I)=scale * src1(I)/src2(I), if src1!=IntPtr.Zero;
            dst(I)=scale/src2(I),      if src1==IntPtr.Zero;
            All the arrays must have the same type, and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array. If the pointer is IntPtr.Zero, the array is assumed to be all 1s. </param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="scale">Optional scale factor </param>
            <param name="dtype">Optional depth of the output array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Multiply(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Calculates per-element product of two arrays:
            dst(I)=scale*src1(I)*src2(I)
            All the arrays must have the same type, and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array. </param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="scale">Optional scale factor</param>
            <param name="dtype">Optional depth of the output array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BitwiseAnd(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Calculates per-element bit-wise logical conjunction of two arrays:
            dst(I)=src1(I) &amp; src2(I) if mask(I)!=0
            In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BitwiseOr(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Calculates per-element bit-wise disjunction of two arrays:
            dst(I)=src1(I)|src2(I)
            In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BitwiseXor(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Calculates per-element bit-wise logical conjunction of two arrays:
            dst(I)=src1(I)^src2(I) if mask(I)!=0
            In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="mask">Mask, 8-bit single channel array; specifies elements of destination array to be changed.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCopy(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Copies selected elements from input array to output array:
            dst(I)=src(I) if mask(I)!=0. 
            If any of the passed arrays is of IplImage type, then its ROI and COI fields are used. Both arrays must have the same type, the same number of dimensions and the same size. The function can also copy sparse arrays (mask is not supported in this case).
            </summary>
            <param name="src">The source array</param>
            <param name="des">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SetIdentity(Emgu.CV.IInputOutputArray,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Initializes scaled identity matrix:
            arr(i,j)=value if i=j,
            0 otherwise
            </summary>
            <param name="mat">The matrix to initialize (not necessarily square).</param>
            <param name="value">The value to assign to the diagonal elements.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvRange(System.IntPtr,System.Double,System.Double)">
            <summary>
            Initializes the matrix as following:
            arr(i,j)=(end-start)*(i*cols(arr)+j)/(cols(arr)*rows(arr))
            </summary>
            <param name="mat">The matrix to initialize. It should be single-channel 32-bit, integer or floating-point</param>
            <param name="start">The lower inclusive boundary of the range</param>
            <param name="end">The upper exclusive boundary of the range</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CartToPolar(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Boolean)">
            <summary>
            Calculates either magnitude, angle, or both of every 2d vector (x(I),y(I)):
            magnitude(I)=sqrt( x(I)2+y(I)2 ),
            angle(I)=atan( y(I)/x(I) )
            The angles are calculated with ~0.1 degree accuracy. For (0,0) point the angle is set to 0
            </summary>
            <param name="x">The array of x-coordinates </param>
            <param name="y">The array of y-coordinates</param>
            <param name="magnitude">The destination array of magnitudes, may be set to IntPtr.Zero if it is not needed </param>
            <param name="angle">The destination array of angles, may be set to IntPtr.Zero if it is not needed. The angles are measured in radians (0..2?) or in degrees (0..360?). </param>
            <param name="angleInDegrees">The flag indicating whether the angles are measured in radians or in degrees</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PolarToCart(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Boolean)">
            <summary>
            Calculates either x-coordinate, y-coordinate or both of every vector magnitude(I)* exp(angle(I)*j), j=sqrt(-1):
            x(I)=magnitude(I)*cos(angle(I)),
            y(I)=magnitude(I)*sin(angle(I))
            </summary>
            <param name="magnitude">Input floating-point array of magnitudes of 2D vectors; it can be an empty matrix (=Mat()), in this case, the function assumes that all the magnitudes are =1; if it is not empty, it must have the same size and type as angle</param>
            <param name="angle">input floating-point array of angles of 2D vectors.</param>
            <param name="x">Output array of x-coordinates of 2D vectors; it has the same size and type as angle.</param>
            <param name="y">Output array of y-coordinates of 2D vectors; it has the same size and type as angle.</param>
            <param name="angleInDegrees">The flag indicating whether the angles are measured in radians or in degrees</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Pow(Emgu.CV.IInputArray,System.Double,Emgu.CV.IOutputArray)">
            <summary>
            Raises every element of input array to p:
            dst(I)=src(I)p, if p is integer
            dst(I)=abs(src(I))p, otherwise
            That is, for non-integer power exponent the absolute values of input array elements are used. However, it is possible to get true values for negative values using some extra operations, as the following sample, computing cube root of array elements, shows:
            CvSize size = cvGetSize(src);
            CvMat* mask = cvCreateMat( size.height, size.width, CV_8UC1 );
            cvCmpS( src, 0, mask, CV_CMP_LT ); /* find negative elements */
            cvPow( src, dst, 1./3 );
            cvSubRS( dst, cvScalarAll(0), dst, mask ); /* negate the results of negative inputs */
            cvReleaseMat( &amp;mask );
            For some values of power, such as integer values, 0.5 and -0.5, specialized faster algorithms are used.
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array, should be the same type as the source</param>
            <param name="power">The exponent of power</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Exp(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Calculates exponent of every element of input array:
            dst(I)=exp(src(I))
            Maximum relative error is 7e-6. Currently, the function converts denormalized values to zeros on output
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array, it should have double type or the same type as the source</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Log(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Calculates natural logarithm of absolute value of every element of input array:
            dst(I)=log(abs(src(I))), src(I)!=0
            dst(I)=C,  src(I)=0
            Where C is large negative number (-700 in the current implementation)
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array, it should have double type or the same type as the source</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SolveCubic(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            finds real roots of a cubic equation:
            coeffs[0]*x^3 + coeffs[1]*x^2 + coeffs[2]*x + coeffs[3] = 0
            (if coeffs is 4-element vector)
            or
            x^3 + coeffs[0]*x^2 + coeffs[1]*x + coeffs[2] = 0
            (if coeffs is 3-element vector)
            </summary>
            <param name="coeffs">The equation coefficients, array of 3 or 4 elements</param>
            <param name="roots">The output array of real roots. Should have 3 elements. Padded with zeros if there is only one root</param>
            <returns>the number of real roots found</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SolvePoly(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32)">
            <summary>
            Finds all real and complex roots of any degree polynomial with real coefficients
            </summary>
            <param name="coeffs">The (degree + 1)-length array of equation coefficients (CV_32FC1 or CV_64FC1)</param>
            <param name="roots">The degree-length output array of real or complex roots (CV_32FC2 or CV_64FC2)</param>
            <param name="maxiter">The maximum number of iterations</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Solve(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DecompMethod)">
            <summary>
            Solves linear system (src1)*(dst) = (src2)
            </summary>
            <param name="src1">The source matrix in the LHS</param>
            <param name="src2">The source matrix in the RHS</param>
            <param name="dst">The result</param>
            <param name="method">The method for solving the equation</param>
            <returns>0 if src1 is a singular and CV_LU method is used</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Dft(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DxtType,System.Int32)">
            <summary>
            Performs forward or inverse transform of 1D or 2D floating-point array
            In case of real (single-channel) data, the packed format, borrowed from IPL, is used to to represent a result of forward Fourier transform or input for inverse Fourier transform
            </summary>
            <param name="src">Source array, real or complex</param>
            <param name="dst">Destination array of the same size and same type as the source</param>
            <param name="flags">Transformation flags</param>
            <param name="nonzeroRows">Number of nonzero rows to in the source array (in case of forward 2d transform), or a number of rows of interest in the destination array (in case of inverse 2d transform). If the value is negative, zero, or greater than the total number of rows, it is ignored. The parameter can be used to speed up 2d convolution/correlation when computing them via DFT. See the sample below</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetOptimalDFTSize(System.Int32)">
            <summary>
            Returns the minimum number N that is greater to equal to size0, such that DFT of a vector of size N can be computed fast. In the current implementation N=2^p x 3^q x 5^r for some p, q, r. 
            </summary>
            <param name="vecsize">Vector size</param>
            <returns>The minimum number N that is greater to equal to size0, such that DFT of a vector of size N can be computed fast. In the current implementation N=2^p x 3^q x 5^r for some p, q, r. </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MulSpectrums(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.MulSpectrumsType,System.Boolean)">
            <summary>
            Performs per-element multiplication of the two CCS-packed or complex matrices that are results of real or complex Fourier transform. 
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array of the same type and the same size of the sources</param>
            <param name="flags">Operation flags; currently, the only supported flag is DFT_ROWS, which indicates that each row of src1 and src2 is an independent 1D Fourier spectrum.</param>
            <param name="conjB">Optional flag that conjugates the second input array before the multiplication (true) or not (false).</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Dct(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DctType)">
            <summary>
            Performs forward or inverse transform of 1D or 2D floating-point array
            </summary>
            <param name="src">Source array, real 1D or 2D array</param>
            <param name="dst">Destination array of the same size and same type as the source</param>
            <param name="flags">Transformation flags</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ClipLine(System.Drawing.Rectangle,System.Drawing.Point@,System.Drawing.Point@)">
            <summary>
            Calculates a part of the line segment which is entirely in the rectangle.
            </summary>
            <param name="rectangle">The rectangle</param>
            <param name="pt1">First ending point of the line segment. It is modified by the function</param>
            <param name="pt2">Second ending point of the line segment. It is modified by the function.</param>
            <returns>It returns false if the line segment is completely outside the rectangle and true otherwise.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.AbsDiff(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Calculates absolute difference between two arrays.
            dst(I)c = abs(src1(I)c - src2(I)c).
            All the arrays must have the same data type and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.AddWeighted(Emgu.CV.IInputArray,System.Double,Emgu.CV.IInputArray,System.Double,System.Double,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Calculated weighted sum of two arrays as following:
            dst(I)=src1(I)*alpha+src2(I)*beta+gamma
            All the arrays must have the same type and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array.</param>
            <param name="alpha">Weight of the first array elements.</param>
            <param name="src2">The second source array. </param>
            <param name="beta">Weight of the second array elements.</param>
            <param name="gamma">Scalar, added to each sum. </param>
            <param name="dst">The destination array.</param>
            <param name="dtype">Optional depth of the output array; when both input arrays have the same depth</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.InRange(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Performs range check for every element of the input array:
            dst(I)=lower(I)_0 &lt;= src(I)_0 &lt;= upper(I)_0
            For single-channel arrays,
            dst(I)=lower(I)_0 &lt;= src(I)_0 &lt;= upper(I)_0 &amp;&amp;
            lower(I)_1 &lt;= src(I)_1 &lt;= upper(I)_1
            For two-channel arrays etc.
            dst(I) is set to 0xff (all '1'-bits) if src(I) is within the range and 0 otherwise. All the arrays must have the same type, except the destination, and the same size (or ROI size)
            </summary>
            <param name="src">The source image</param>
            <param name="lower">The lower values stored in an image of same type &amp; size as <paramref name="src"/></param>
            <param name="upper">The upper values stored in an image of same type &amp; size as <paramref name="src"/></param>
            <param name="dst">The resulting mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Norm(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.CvEnum.NormType,Emgu.CV.IInputArray)">
            <summary>
            Returns the calculated norm. The multiple-channel array are treated as single-channel, that is, the results for all channels are combined. 
            </summary>
            <param name="arr1">The first source image</param>
            <param name="arr2">The second source image. If it is null, the absolute norm of arr1 is calculated, otherwise absolute or relative norm of arr1-arr2 is calculated</param>
            <param name="normType">Type of norm</param>
            <param name="mask">The optional operation mask</param>
            <returns>The calculated norm</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Norm(Emgu.CV.IInputArray,Emgu.CV.CvEnum.NormType,Emgu.CV.IInputArray)">
            <summary>
            Returns the calculated norm. The multiple-channel array are treated as single-channel, that is, the results for all channels are combined. 
            </summary>
            <param name="arr1">The first source image</param>
            <param name="normType">Type of norm</param>
            <param name="mask">The optional operation mask</param>
            <returns>The calculated norm</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateImage(System.Drawing.Size,Emgu.CV.CvEnum.IplDepth,System.Int32)">
            <summary>
            Creates the header and allocates data. 
            </summary>
            <param name="size">Image width and height.</param>
            <param name="depth">Bit depth of image elements</param>
            <param name="channels">
            Number of channels per element(pixel). Can be 1, 2, 3 or 4. The channels are interleaved, for example the usual data layout of a color image is:
            b0 g0 r0 b1 g1 r1 ...
            </param>
            <returns>A pointer to IplImage </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateImageHeader(System.Drawing.Size,Emgu.CV.CvEnum.IplDepth,System.Int32)">
            <summary>
            Allocates, initializes, and returns the structure IplImage.
            </summary>
            <param name="size">Image width and height.</param>
            <param name="depth">Bit depth of image elements</param>
            <param name="channels">
            Number of channels per element(pixel). Can be 1, 2, 3 or 4. The channels are interleaved, for example the usual data layout of a color image is:
            b0 g0 r0 b1 g1 r1 ...
            </param>
            <returns> The structure IplImage</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInitImageHeader(System.IntPtr,System.Drawing.Size,Emgu.CV.CvEnum.IplDepth,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes the image header structure, pointer to which is passed by the user, and returns the pointer.
            </summary>
            <param name="image">Image header to initialize.</param>
            <param name="size">Image width and height.</param>
            <param name="depth">Image depth </param>
            <param name="channels">Number of channels </param>
            <param name="origin">IPL_ORIGIN_TL or IPL_ORIGIN_BL.</param>
            <param name="align">Alignment for image rows, typically 4 or 8 bytes.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetData(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Assigns user data to the array header.
            </summary>
            <param name="arr">Array header.</param>
            <param name="data">User data.</param>
            <param name="step">Full row length in bytes.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseImageHeader(System.IntPtr@)">
            <summary>
            Releases the header.
            </summary>
            <param name="image">Pointer to the deallocated header.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInitMatHeader(System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Initializes already allocated CvMat structure. It can be used to process raw data with OpenCV matrix functions.
            </summary>
            <param name="mat">Pointer to the matrix header to be initialized.</param>
            <param name="rows">Number of rows in the matrix.</param>
            <param name="cols">Number of columns in the matrix.</param>
            <param name="type">Type of the matrix elements.</param>
            <param name="data">Optional data pointer assigned to the matrix header</param>
            <param name="step">Full row width in bytes of the data assigned. By default, the minimal possible step is used, i.e., no gaps is assumed between subsequent rows of the matrix.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetImageCOI(System.IntPtr,System.Int32)">
            <summary>
            Sets the channel of interest to a given value. Value 0 means that all channels are selected, 1 means that the first channel is selected etc. If ROI is NULL and coi != 0, ROI is allocated.
            </summary>
            <param name="image">Image header</param>
            <param name="coi">Channel of interest starting from 1. If 0, the COI is unset.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetImageCOI(System.IntPtr)">
            <summary>
            Returns channel of interest of the image (it returns 0 if all the channels are selected).
            </summary>
            <param name="image">Image header. </param>
            <returns>channel of interest of the image (it returns 0 if all the channels are selected)</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvResetImageROI(System.IntPtr)">
            <summary>
            Releases image ROI. After that the whole image is considered selected.
            </summary>
            <param name="image">Image header</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetImageROI(System.IntPtr,System.Drawing.Rectangle)">
            <summary>
            Sets the image ROI to a given rectangle. If ROI is NULL and the value of the parameter rect is not equal to the whole image, ROI is allocated. 
            </summary>
            <param name="image">Image header.</param>
            <param name="rect">ROI rectangle.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetImageROI(System.IntPtr)">
            <summary>
            Returns channel of interest of the image (it returns 0 if all the channels are selected).
            </summary>
            <param name="image">Image header.</param>
            <returns>channel of interest of the image (it returns 0 if all the channels are selected)</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateMat(System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Allocates header for the new matrix and underlying data, and returns a pointer to the created matrix. Matrices are stored row by row. All the rows are aligned by 4 bytes. 
            </summary>
            <param name="rows">Number of rows in the matrix.</param>
            <param name="cols">Number of columns in the matrix.</param>
            <param name="type">Type of the matrix elements.</param>
            <returns>A pointer to the created matrix</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInitMatNDHeader(System.IntPtr,System.Int32,System.Int32[],Emgu.CV.CvEnum.DepthType,System.IntPtr)">
            <summary>
            Initializes CvMatND structure allocated by the user
            </summary>
            <param name="mat">Pointer to the array header to be initialized</param>
            <param name="dims">Number of array dimensions</param>
            <param name="sizes">Array of dimension sizes</param>
            <param name="type">Type of array elements</param>
            <param name="data">Optional data pointer assigned to the matrix header</param>
            <returns>Pointer to the array header</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseMat(System.IntPtr@)">
            <summary>
            Decrements the matrix data reference counter and releases matrix header
            </summary>
            <param name="mat">Double pointer to the matrix.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateSparseMat(System.Int32,System.IntPtr,Emgu.CV.CvEnum.DepthType)">
            <summary>
            The function allocates a multi-dimensional sparse array. Initially the array contain no elements, that is Get or GetReal returns zero for every index
            </summary>
            <param name="dims">Number of array dimensions</param>
            <param name="sizes">Array of dimension sizes</param>
            <param name="type">Type of array elements</param>
            <returns>Pointer to the array header</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseSparseMat(System.IntPtr@)">
            <summary>
            The function releases the sparse array and clears the array pointer upon exit.
            </summary>
            <param name="mat">Reference of the pointer to the array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetReal1D(System.IntPtr,System.Int32,System.Double)">
            <summary>
            Assign the new value to the particular element of single-channel array
            </summary>
            <param name="arr">Input array</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <param name="value">The assigned value </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetReal2D(System.IntPtr,System.Int32,System.Int32,System.Double)">
            <summary>
            Assign the new value to the particular element of single-channel array
            </summary>
            <param name="arr">Input array</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <param name="idx1">The second zero-based component of the element index </param>
            <param name="value">The assigned value </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetReal3D(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Double)">
            <summary>
            Assign the new value to the particular element of single-channel array
            </summary>
            <param name="arr">Input array</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <param name="idx1">The second zero-based component of the element index </param>
            <param name="idx2">The third zero-based component of the element index </param>
            <param name="value">The assigned value </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetRealND(System.IntPtr,System.Int32[],System.Double)">
            <summary>
            Assign the new value to the particular element of single-channel array
            </summary>
            <param name="arr">Input array</param>
            <param name="idx">Array of the element indices </param>
            <param name="value">The assigned value </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvClearND(System.IntPtr,System.Int32[])">
            <summary>
            Clears (sets to zero) the particular element of dense array or deletes the element of sparse array. If the element does not exists, the function does nothing
            </summary>
            <param name="arr">Input array</param>
            <param name="idx">Array of the element indices </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSet2D(System.IntPtr,System.Int32,System.Int32,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Assign the new value to the particular element of array
            </summary>
            <param name="arr">Input array. </param>
            <param name="idx0">The first zero-based component of the element index</param>
            <param name="idx1">The second zero-based component of the element index</param>
            <param name="value">The assigned value</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Flip(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.FlipType)">
            <summary>
            Flips the array in one of different 3 ways (row and column indices are 0-based)
            </summary>
            <param name="src">Source array.</param>
            <param name="dst">Destination array.</param>
            <param name="flipType">Specifies how to flip the array.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetSubRect(System.IntPtr,System.IntPtr,System.Drawing.Rectangle)">
            <summary>
            Returns header, corresponding to a specified rectangle of the input array. In other words, it allows the user to treat a rectangular part of input array as a stand-alone array. ROI is taken into account by the function so the sub-array of ROI is actually extracted.
            </summary>
            <param name="arr">Input array</param>
            <param name="submat">Pointer to the resultant sub-array header.</param>
            <param name="rect">Zero-based coordinates of the rectangle of interest.</param>
            <returns>the resultant sub-array header</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetRows(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Return the header, corresponding to a specified row span of the input array
            </summary>
            <param name="arr">Input array</param>
            <param name="submat">Pointer to the prelocated memory of resulting sub-array header</param>
            <param name="startRow">Zero-based index of the starting row (inclusive) of the span</param>
            <param name="endRow">Zero-based index of the ending row (exclusive) of the span</param>
            <param name="deltaRow">Index step in the row span. That is, the function extracts every delta_row-th row from start_row and up to (but not including) end_row</param>
            <returns>The header, corresponding to a specified row span of the input array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetRow(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Return the header, corresponding to a specified row of the input array
            </summary>
            <param name="arr">Input array</param>
            <param name="submat">Pointer to the prelocate memory of the resulting sub-array header</param>
            <param name="row">Zero-based index of the selected row</param>
            <returns>The header, corresponding to a specified row of the input array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetCols(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Return the header, corresponding to a specified col span of the input array
            </summary>
            <param name="arr">Input array</param>
            <param name="submat">Pointer to the prelocated memory of the resulting sub-array header</param>
            <param name="startCol">Zero-based index of the selected column</param>
            <param name="endCol">Zero-based index of the ending column (exclusive) of the span</param>
            <returns>The header, corresponding to a specified col span of the input array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetCol(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Return the header, corresponding to a specified column of the input array
            </summary>
            <param name="arr">Input array</param>
            <param name="submat">Pointer to the prelocate memory of the resulting sub-array header</param>
            <param name="col">Zero-based index of the selected column</param>
            <returns>The header, corresponding to a specified column of the input array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetDiag(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            returns the header, corresponding to a specified diagonal of the input array
            </summary>
            <param name="arr">Input array</param>
            <param name="submat">Pointer to the resulting sub-array header</param>
            <param name="diag">Array diagonal. Zero corresponds to the main diagonal, -1 corresponds to the diagonal above the main etc., 1 corresponds to the diagonal below the main etc</param>
            <returns>Pointer to the resulting sub-array header</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetSize(System.IntPtr)">
            <summary>
            Returns number of rows (CvSize::height) and number of columns (CvSize::width) of the input matrix or image. In case of image the size of ROI is returned.
            </summary>
            <param name="arr">array header</param>
            <returns>number of rows (CvSize::height) and number of columns (CvSize::width) of the input matrix or image. In case of image the size of ROI is returned.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Circle(Emgu.CV.IInputOutputArray,System.Drawing.Point,System.Int32,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draws a simple or filled circle with given center and radius. The circle is clipped by ROI rectangle.
            </summary>
            <param name="img">Image where the circle is drawn</param>
            <param name="center">Center of the circle</param>
            <param name="radius">Radius of the circle.</param>
            <param name="color">Color of the circle</param>
            <param name="thickness">Thickness of the circle outline if positive, otherwise indicates that a filled circle has to be drawn</param>
            <param name="lineType">Line type</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Split(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Divides a multi-channel array into separate single-channel arrays. Two modes are available for the operation. If the source array has N channels then if the first N destination channels are not IntPtr.Zero, all they are extracted from the source array, otherwise if only a single destination channel of the first N is not IntPtr.Zero, this particular channel is extracted, otherwise an error is raised. Rest of destination channels (beyond the first N) must always be IntPtr.Zero. For IplImage cvCopy with COI set can be also used to extract a single channel from the image
            </summary>
            <param name="src">Input multi-channel array</param>
            <param name="mv">Output array or vector of arrays</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Ellipse(Emgu.CV.IInputOutputArray,System.Drawing.Point,System.Drawing.Size,System.Double,System.Double,System.Double,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draws a simple or thick elliptic arc or fills an ellipse sector. The arc is clipped by ROI rectangle. A piecewise-linear approximation is used for antialiased arcs and thick arcs. All the angles are given in degrees.
            </summary>
            <param name="img">Image</param>
            <param name="center">Center of the ellipse</param>
            <param name="axes">Length of the ellipse axes</param>
            <param name="angle">Rotation angle</param>
            <param name="startAngle">Starting angle of the elliptic arc</param>
            <param name="endAngle">Ending angle of the elliptic arc</param>
            <param name="color">Ellipse color</param>
            <param name="thickness">Thickness of the ellipse arc</param>
            <param name="lineType">Type of the ellipse boundary</param>
            <param name="shift">Number of fractional bits in the center coordinates and axes' values</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Ellipse(Emgu.CV.IInputOutputArray,Emgu.CV.Structure.RotatedRect,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draws a simple or thick elliptic arc or fills an ellipse sector. The arc is clipped by ROI rectangle. A piecewise-linear approximation is used for antialiased arcs and thick arcs. All the angles are given in degrees.
            </summary>
            <param name="img">Image</param>
            <param name="box">The box the define the ellipse area</param>
            <param name="color">Ellipse color</param>
            <param name="thickness">Thickness of the ellipse arc</param>
            <param name="lineType">Type of the ellipse boundary</param>
            <param name="shift">Number of fractional bits in the center coordinates and axes' values</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.LUT(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Fills the destination array with values from the look-up table. Indices of the entries are taken from the source array. That is, the function processes each element of src as following:
            dst(I)=lut[src(I)+DELTA]
            where DELTA=0 if src has depth CV_8U, and DELTA=128 if src has depth CV_8S
            </summary>
            <param name="src">Source array of 8-bit elements</param>
            <param name="dst">Destination array of arbitrary depth and of the same number of channels as the source array</param>
            <param name="lut">Look-up table of 256 elements; should have the same depth as the destination array. In case of multi-channel source and destination arrays, the table should either have a single-channel (in this case the same table is used for all channels), or the same number of channels as the source/destination array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvConvertScale(System.IntPtr,System.IntPtr,System.Double,System.Double)">
            <summary>
            This function has several different purposes and thus has several synonyms. It copies one array to another with optional scaling, which is performed first, and/or optional type conversion, performed after:
            dst(I)=src(I)*scale + (shift,shift,...)
            All the channels of multi-channel arrays are processed independently.
            The type conversion is done with rounding and saturation, that is if a result of scaling + conversion can not be represented exactly by a value of destination array element type, it is set to the nearest representable value on the real axis.
            In case of scale=1, shift=0 no prescaling is done. This is a specially optimized case and it has the appropriate cvConvert synonym. If source and destination array types have equal types, this is also a special case that can be used to scale and shift a matrix or an image and that fits to cvScale synonym.
            </summary>
            <param name="src">Source array</param>
            <param name="dst">Destination array</param>
            <param name="scale">Scale factor</param>
            <param name="shift">Value added to the scaled source array elements</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ConvertScaleAbs(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double)">
            <summary>
            Similar to cvCvtScale but it stores absolute values of the conversion results:
            dst(I)=abs(src(I)*scale + (shift,shift,...))
            The function supports only destination arrays of 8u (8-bit unsigned integers) type, for other types the function can be emulated by combination of cvConvertScale and cvAbs functions.
            </summary>
            <param name="src">Source array</param>
            <param name="dst">Destination array (should have 8u depth). </param>
            <param name="scale">ScaleAbs factor</param>
            <param name="shift">Value added to the scaled source array elements</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Mean(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
             <summary>
             Calculates the average value M of array elements, independently for each channel:
            N = sumI mask(I)!=0
            Mc = 1/N * sumI,mask(I)!=0 arr(I)c
            If the array is IplImage and COI is set, the function processes the selected channel only and stores the average to the first scalar component (S0).
             </summary>
             <param name="arr">The array</param>
             <param name="mask">The optional operation mask</param>
             <returns>average (mean) of array elements</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MeanStdDev(Emgu.CV.IInputArray,Emgu.CV.Structure.MCvScalar@,Emgu.CV.Structure.MCvScalar@,Emgu.CV.IInputArray)">
            <summary>
            The function cvAvgSdv calculates the average value and standard deviation of array elements, independently for each channel
            </summary>
            <remarks>If the array is IplImage and COI is set, the function processes the selected channel only and stores the average and standard deviation to the first compoenents of output scalars (M0 and S0).</remarks>
            <param name="arr">The array</param>
            <param name="mean">Pointer to the mean value</param>
            <param name="stdDev">Pointer to the standard deviation</param>
            <param name="mask">The optional operation mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MeanStdDev(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Calculates a mean and standard deviation of array elements.
            </summary>
            <param name="arr">Input array that should have from 1 to 4 channels so that the results can be stored in MCvScalar</param>
            <param name="mean">Calculated mean value</param>
            <param name="stdDev">Calculated standard deviation</param>
            <param name="mask">Optional operation mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Sum(Emgu.CV.IInputArray)">
            <summary>
            Calculates sum S of array elements, independently for each channel
            Sc = sumI arr(I)c
            If the array is IplImage and COI is set, the function processes the selected channel only and stores the sum to the first scalar component (S0).
            </summary>
            <param name="src">The array</param>
            <returns>The sum of array elements</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Reduce(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.ReduceDimension,Emgu.CV.CvEnum.ReduceType,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Reduces matrix to a vector by treating the matrix rows/columns as a set of 1D vectors and performing the specified operation on the vectors until a single row/column is obtained. 
            </summary>
            <remarks>
            The function can be used to compute horizontal and vertical projections of an raster image. 
            In case of CV_REDUCE_SUM and CV_REDUCE_AVG the output may have a larger element bit-depth to preserve accuracy. 
            And multi-channel arrays are also supported in these two reduction modes
            </remarks>
            <param name="src">The input matrix</param>
            <param name="dst">The output single-row/single-column vector that accumulates somehow all the matrix rows/columns</param>
            <param name="dim">The dimension index along which the matrix is reduce.</param>
            <param name="type">The reduction operation type</param>
            <param name="dtype">Optional depth type of the output array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseImage(System.IntPtr@)">
            <summary>
            Releases the header and the image data.
            </summary>
            <param name="image">Double pointer to the header of the deallocated image</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.DrawContours(Emgu.CV.IInputOutputArray,Emgu.CV.IInputArrayOfArrays,System.Int32,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,Emgu.CV.IInputArray,System.Int32,System.Drawing.Point)">
            <summary>
            Draws contours outlines or filled contours.
            </summary>
            <param name="image">Image where the contours are to be drawn. Like in any other drawing function, the contours are clipped with the ROI</param>
            <param name="contours">All the input contours. Each contour is stored as a point vector.</param>
            <param name="contourIdx">Parameter indicating a contour to draw. If it is negative, all the contours are drawn.</param>
            <param name="color">Color of the contours </param>
            <param name="maxLevel">Maximal level for drawn contours. If 0, only contour is drawn. If 1, the contour and all contours after it on the same level are drawn. If 2, all contours after and all contours one level below the contours are drawn, etc. If the value is negative, the function does not draw the contours following after contour but draws child contours of contour up to abs(maxLevel)-1 level. </param>
            <param name="thickness">Thickness of lines the contours are drawn with. If it is negative the contour interiors are drawn</param>
            <param name="lineType">Type of the contour segments</param>
            <param name="hierarchy">Optional information about hierarchy. It is only needed if you want to draw only some of the contours</param>
            <param name="offset">Shift all the point coordinates by the specified value. It is useful in case if the contours retrieved in some image ROI and then the ROI offset needs to be taken into account during the rendering. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FillConvexPoly(Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray,Emgu.CV.Structure.MCvScalar,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Fills convex polygon interior. This function is much faster than The function cvFillPoly and can fill not only the convex polygons but any monotonic polygon, i.e. a polygon whose contour intersects every horizontal line (scan line) twice at the most
            </summary>
            <param name="img">Image</param>
            <param name="points">Array of pointers to a single polygon</param>
            <param name="color">Polygon color</param>
            <param name="lineType">Type of the polygon boundaries</param>
            <param name="shift">Number of fractional bits in the vertex coordinates</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FillPoly(Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray,Emgu.CV.Structure.MCvScalar,Emgu.CV.CvEnum.LineType,System.Int32,System.Drawing.Point)">
            <summary>
            Fills the area bounded by one or more polygons.
            </summary>
            <param name="img">Image.</param>
            <param name="points">Array of polygons where each polygon is represented as an array of points.</param>
            <param name="color">Polygon color</param>
            <param name="lineType">Type of the polygon boundaries.</param>
            <param name="shift">Number of fractional bits in the vertex coordinates.</param>
            <param name="offset">Optional offset of all points of the contours.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PutText(Emgu.CV.IInputOutputArray,System.String,System.Drawing.Point,Emgu.CV.CvEnum.FontFace,System.Double,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,System.Boolean)">
            <summary>
            Renders the text in the image with the specified font and color. The printed text is clipped by ROI rectangle. Symbols that do not belong to the specified font are replaced with the rectangle symbol.
            </summary>
            <param name="img">Input image</param>
            <param name="text">String to print</param>
            <param name="org">Coordinates of the bottom-left corner of the first letter</param>
            <param name="fontFace">Font type.</param>
            <param name="fontScale">Font scale factor that is multiplied by the font-specific base size.</param>
            <param name="color">Text color</param>
            <param name="thickness">Thickness of the lines used to draw a text.</param>
            <param name="lineType">Line type</param>
            <param name="bottomLeftOrigin">When true, the image data origin is at the bottom-left corner. Otherwise, it is at the top-left corner.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetTextSize(System.String,Emgu.CV.CvEnum.FontFace,System.Double,System.Int32,System.Int32@)">
            <summary>
            Calculates the width and height of a text string.
            </summary>
            <param name="text">Input text string.</param>
            <param name="fontFace">Font to use</param>
            <param name="fontScale">Font scale factor that is multiplied by the font-specific base size.</param>
            <param name="thickness">Thickness of lines used to render the text. </param>
            <param name="baseLine">Y-coordinate of the baseline relative to the bottom-most text point.</param>
            <returns>The size of a box that contains the specified text.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MinMaxLoc(Emgu.CV.IInputArray,System.Double@,System.Double@,System.Drawing.Point@,System.Drawing.Point@,Emgu.CV.IInputArray)">
            <summary>
            Finds minimum and maximum element values and their positions. The extremums are searched over the whole array, selected ROI (in case of IplImage) or, if mask is not IntPtr.Zero, in the specified array region. If the array has more than one channel, it must be IplImage with COI set. In case if multi-dimensional arrays min_loc->x and max_loc->x will contain raw (linear) positions of the extremums
            </summary>
            <param name="arr">The source array, single-channel or multi-channel with COI set</param>
            <param name="minVal">Pointer to returned minimum value</param>
            <param name="maxVal">Pointer to returned maximum value</param>
            <param name="minLoc">Pointer to returned minimum location</param>
            <param name="maxLoc">Pointer to returned maximum location</param>
            <param name="mask">The optional mask that is used to select a subarray. Use IntPtr.Zero if not needed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CopyMakeBorder(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Int32,System.Int32,System.Int32,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Copies the source 2D array into interior of destination array and makes a border of the specified type around the copied area. The function is useful when one needs to emulate border type that is different from the one embedded into a specific algorithm implementation. For example, morphological functions, as well as most of other filtering functions in OpenCV, internally use replication border type, while the user may need zero border or a border, filled with 1's or 255's
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image</param>
            <param name="bordertype">Type of the border to create around the copied source image rectangle</param>
            <param name="value">Value of the border pixels if bordertype=CONSTANT</param>
            <param name="bottom">Parameter specifying how many pixels in each direction from the source image rectangle to extrapolate.</param>
            <param name="left">Parameter specifying how many pixels in each direction from the source image rectangle to extrapolate.</param>
            <param name="right">Parameter specifying how many pixels in each direction from the source image rectangle to extrapolate.</param>
            <param name="top">Parameter specifying how many pixels in each direction from the source image rectangle to extrapolate.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGet1D(System.IntPtr,System.Int32)">
            <summary>
            Return the particular array element
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index</param>
            <returns>the particular array element</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGet2D(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Return the particular array element
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index</param>
            <param name="idx1">The second zero-based component of the element index</param>
            <returns>the particular array element</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGet3D(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Return the particular array element
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index</param>
            <param name="idx1">The second zero-based component of the element index</param>
            <param name="idx2">The third zero-based component of the element index</param>
            <returns>the particular array element</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetReal1D(System.IntPtr,System.Int32)">
            <summary>
            Return the particular element of single-channel array. If the array has multiple channels, runtime error is raised. Note that cvGet*D function can be used safely for both single-channel and multiple-channel arrays though they are a bit slower.
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <returns>the particular element of single-channel array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetReal2D(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Return the particular element of single-channel array. If the array has multiple channels, runtime error is raised. Note that cvGet*D function can be used safely for both single-channel and multiple-channel arrays though they are a bit slower.
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <param name="idx1">The second zero-based component of the element index</param>
            <returns>the particular element of single-channel array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetReal3D(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Return the particular element of single-channel array. If the array has multiple channels, runtime error is raised. Note that cvGet*D function can be used safely for both single-channel and multiple-channel arrays though they are a bit slower.
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <param name="idx1">The second zero-based component of the element index</param>
            <param name="idx2">The third zero-based component of the element index </param>
            <returns>the particular element of single-channel array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Randn(Emgu.CV.IInputOutputArray,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Fills the array with normally distributed random numbers.
            </summary>
            <param name="dst">Output array of random numbers; the array must be pre-allocated and have 1 to 4 channels.</param>
            <param name="mean">Mean value (expectation) of the generated random numbers.</param>
            <param name="stddev">Standard deviation of the generated random numbers; it can be either a vector (in which case a diagonal standard deviation matrix is assumed) or a square matrix.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Randn(Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Fills the array with normally distributed random numbers.
            </summary>
            <param name="dst">Output array of random numbers; the array must be pre-allocated and have 1 to 4 channels.</param>
            <param name="mean">Mean value (expectation) of the generated random numbers.</param>
            <param name="stddev">Standard deviation of the generated random numbers; it can be either a vector (in which case a diagonal standard deviation matrix is assumed) or a square matrix.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Randu(Emgu.CV.IInputOutputArray,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Generates a single uniformly-distributed random number or an array of random numbers.
            </summary>
            <param name="dst">Output array of random numbers; the array must be pre-allocated.</param>
            <param name="low">Inclusive lower boundary of the generated random numbers.</param>
            <param name="high">Exclusive upper boundary of the generated random numbers.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Randu(Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Generates a single uniformly-distributed random number or an array of random numbers.
            </summary>
            <param name="dst">Output array of random numbers; the array must be pre-allocated.</param>
            <param name="low">Inclusive lower boundary of the generated random numbers.</param>
            <param name="high">Exclusive upper boundary of the generated random numbers.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Eigen(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray)">
            <summary>
            Computes eigenvalues and eigenvectors of a symmetric matrix
            </summary>
            <param name="src">The input symmetric square matrix, modified during the processing</param>
            <param name="eigenVectors">The output matrix of eigenvectors, stored as subsequent rows</param>
            <param name="eigenValues">The output vector of eigenvalues, stored in the descending order (order of eigenvalues and eigenvectors is syncronized, of course)</param>
            <remarks>Currently the function is slower than cvSVD yet less accurate, so if A is known to be positivelydefined (for example, it is a covariance matrix)it is recommended to use cvSVD to find eigenvalues and eigenvectors of A, especially if eigenvectors are not required.</remarks>
            <example>To calculate the largest eigenvector/-value set lowindex = highindex = 1. For legacy reasons this function always returns a square matrix the same size as the source matrix with eigenvectors and a vector the length of the source matrix with eigenvalues. The selected eigenvectors/-values are always in the first highindex - lowindex + 1 rows.</example>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Normalize(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,Emgu.CV.CvEnum.NormType,Emgu.CV.CvEnum.DepthType,Emgu.CV.IInputArray)">
            <summary>
            normalizes the input array so that it's norm or value range takes the certain value(s).
            </summary>
            <param name="src">The input array</param>
            <param name="dst">The output array; in-place operation is supported</param>
            <param name="alpha">The minimum/maximum value of the output array or the norm of output array</param>
            <param name="beta">The maximum/minimum value of the output array</param>
            <param name="normType">The normalization type</param>
            <param name="mask">The operation mask. Makes the function consider and normalize only certain array elements</param>
            <param name="dType">Optional depth type for the dst array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Gemm(Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Double,Emgu.CV.IInputArray,System.Double,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.GemmType)">
            <summary>
            Performs generalized matrix multiplication:
            dst = alpha*op(src1)*op(src2) + beta*op(src3), where op(X) is X or XT
            </summary>
            <param name="src1">The first source array. </param>
            <param name="src2">The second source array. </param>
            <param name="alpha">The scalar</param>
            <param name="src3">The third source array (shift). Can be null, if there is no shift.</param>
            <param name="beta">The scalar</param>
            <param name="dst">The destination array.</param>
            <param name="tAbc">The Gemm operation type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Transform(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Performs matrix transformation of every element of array src and stores the results in dst
            Both source and destination arrays should have the same depth and the same size or selected ROI size. transmat and shiftvec should be real floating-point matrices.
            </summary>
            <param name="src">The first source array</param>
            <param name="dst">The destination array</param>
            <param name="m"> transformation 2x2 or 2x3 floating-point matrix.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PerspectiveTransform(System.Drawing.PointF[],Emgu.CV.IInputArray)">
            <summary>
            Transforms every element of src in the following way:
            (x, y) -> (x'/w, y'/w),
            where
            (x', y', w') = mat3x3 * (x, y, 1)
            and w = w'   if w'!=0,
                   inf  otherwise
            </summary>
            <param name="src">The source points</param>
            <param name="mat">3x3 floating-point transformation matrix.</param>
            <returns>The destination points</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PerspectiveTransform(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Transforms every element of src (by treating it as 2D or 3D vector) in the following way:
            (x, y, z) -> (x'/w, y'/w, z'/w) or
            (x, y) -> (x'/w, y'/w),
            where
            (x', y', z', w') = mat4x4 * (x, y, z, 1) or
            (x', y', w') = mat3x3 * (x, y, 1)
            and w = w'   if w'!=0,
                   inf  otherwise
            </summary>
            <param name="src">The source three-channel floating-point array</param>
            <param name="dst">The destination three-channel floating-point array</param>
            <param name="mat">3x3 or 4x4 floating-point transformation matrix.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MulTransposed(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Boolean,Emgu.CV.IInputArray,System.Double,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Calculates the product of src and its transposition.
            The function evaluates dst=scale(src-delta)*(src-delta)^T if order=0, and dst=scale(src-delta)^T*(src-delta) otherwise.
            </summary>
            <param name="src">The source matrix</param>
            <param name="dst">The destination matrix</param>
            <param name="aTa">Order of multipliers</param>
            <param name="delta">An optional array, subtracted from <paramref name="src"/> before multiplication</param>
            <param name="scale">An optional scaling</param>
            <param name="dtype">Optional depth type of the output array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Trace(Emgu.CV.IInputArray)">
            <summary>
            Returns sum of diagonal elements of the matrix <paramref name="mat"/>.
            </summary>
            <param name="mat">the matrix</param>
            <returns>sum of diagonal elements of the matrix src1</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Transpose(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Transposes matrix src1:
            dst(i,j)=src(j,i)
            Note that no complex conjugation is done in case of complex matrix. Conjugation should be done separately: look at the sample code in cvXorS for example
            </summary>
            <param name="src">The source matrix</param>
            <param name="dst">The destination matrix</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Determinant(Emgu.CV.IInputArray)">
            <summary>
            Returns determinant of the square matrix mat. The direct method is used for small matrices and Gaussian elimination is used for larger matrices. For symmetric positive-determined matrices it is also possible to run SVD with U=V=NULL and then calculate determinant as a product of the diagonal elements of W
            </summary>
            <param name="mat">The pointer to the matrix</param>
            <returns>determinant of the square matrix mat</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Invert(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DecompMethod)">
            <summary>
            Inverts matrix src1 and stores the result in src2
            </summary>
            <param name="src">The source matrix.</param>
            <param name="dst">The destination matrix</param>
            <param name="method">Inversion method</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SVDecomp(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.SvdFlag)">
            <summary>
            Decomposes matrix A into a product of a diagonal matrix and two orthogonal matrices:
            A=U*W*VT
            Where W is diagonal matrix of singular values that can be coded as a 1D vector of singular values and U and V. All the singular values are non-negative and sorted (together with U and V columns) in descenting order.
            </summary>
            <remarks>
            SVD algorithm is numerically robust and its typical applications include: 
            1. accurate eigenvalue problem solution when matrix A is square, symmetric and positively defined matrix, for example, when it is a covariation matrix. W in this case will be a vector of eigen values, and U=V is matrix of eigen vectors (thus, only one of U or V needs to be calculated if the eigen vectors are required) 
            2. accurate solution of poor-conditioned linear systems 
            3. least-squares solution of overdetermined linear systems. This and previous is done by cvSolve function with CV_SVD method 
            4. accurate calculation of different matrix characteristics such as rank (number of non-zero singular values), condition number (ratio of the largest singular value to the smallest one), determinant (absolute value of determinant is equal to the product of singular values). All the things listed in this item do not require calculation of U and V matrices. 
            </remarks>
            <param name="src">Source MxN matrix</param>
            <param name="w">Resulting singular value matrix (MxN or NxN) or vector (Nx1). </param>
            <param name="u">Optional left orthogonal matrix (MxM or MxN). If CV_SVD_U_T is specified, the number of rows and columns in the sentence above should be swapped</param>
            <param name="v">Optional right orthogonal matrix (NxN)</param>
            <param name="flags">Operation flags</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SVBackSubst(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Performs a singular value back substitution.
            </summary>
            <param name="w">Singular values</param>
            <param name="u">Left singular vectors</param>
            <param name="vt">Transposed matrix of right singular vectors.</param>
            <param name="rhs">Right-hand side of a linear system</param>
            <param name="dst">Found solution of the system.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcCovarMatrix(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.CvEnum.CovarMethod,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Calculates the covariance matrix of a set of vectors.
            </summary>
            <param name="samples">Samples stored either as separate matrices or as rows/columns of a single matrix.</param>
            <param name="covar">Output covariance matrix of the type ctype and square size.</param>
            <param name="mean">Input or output (depending on the flags) array as the average value of the input vectors.</param>
            <param name="flags">Operation flags</param>
            <param name="ctype">Type of the matrix</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Mahalanobis(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Calculates the weighted distance between two vectors and returns it
            </summary>
            <param name="v1">The first 1D source vector</param>
            <param name="v2">The second 1D source vector</param>
            <param name="iconvar">The inverse covariation matrix</param>
            <returns>the Mahalanobis distance</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PCACompute(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IOutputArray,System.Int32)">
            <summary>
            Performs Principal Component Analysis of the supplied dataset.
            </summary>
            <param name="data">Input samples stored as the matrix rows or as the matrix columns.</param>
            <param name="mean">Optional mean value; if the matrix is empty, the mean is computed from the data.</param>
            <param name="eigenvectors">The eigenvectors.</param>
            <param name="maxComponents">Maximum number of components that PCA should retain; by default, all the components are retained.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PCACompute(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IOutputArray,System.Double)">
            <summary>
            Performs Principal Component Analysis of the supplied dataset.
            </summary>
            <param name="data">Input samples stored as the matrix rows or as the matrix columns.</param>
            <param name="mean">Optional mean value; if the matrix is empty, the mean is computed from the data.</param>
            <param name="eigenvectors">The eigenvectors.</param>
            <param name="retainedVariance">Percentage of variance that PCA should retain. Using this parameter will let the PCA decided how many components to retain but it will always keep at least 2.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PCAProject(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Projects vector(s) to the principal component subspace.
            </summary>
            <param name="data">Input vector(s); must have the same dimensionality and the same layout as the input data used at PCA phase</param>
            <param name="mean">The mean.</param>
            <param name="eigenvectors">The eigenvectors.</param>
            <param name="result">The result.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PCABackProject(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Reconstructs vectors from their PC projections.
            </summary>
            <param name="data">Coordinates of the vectors in the principal component subspace</param>
            <param name="mean">The mean.</param>
            <param name="eigenvectors">The eigenvectors.</param>
            <param name="result">The result.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetRawData(System.IntPtr,System.IntPtr@,System.Int32@,System.Drawing.Size@)">
            <summary>
            Fills output variables with low-level information about the array data. All output parameters are optional, so some of the pointers may be set to NULL. If the array is IplImage with ROI set, parameters of ROI are returned. 
            </summary>
            <param name="arr">Array header</param>
            <param name="data">Output pointer to the whole image origin or ROI origin if ROI is set</param>
            <param name="step">Output full row length in bytes</param>
            <param name="roiSize">Output ROI size</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetMat(System.IntPtr,System.IntPtr,System.Int32@,System.Int32)">
            <summary>
            Returns matrix header for the input array that can be matrix - CvMat, image - IplImage or multi-dimensional dense array - CvMatND* (latter case is allowed only if allowND != 0) . In the case of matrix the function simply returns the input pointer. In the case of IplImage* or CvMatND* it initializes header structure with parameters of the current image ROI and returns pointer to this temporary structure. Because COI is not supported by CvMat, it is returned separately. 
            </summary>
            <param name="arr">Input array</param>
            <param name="header">Pointer to CvMat structure used as a temporary buffer</param>
            <param name="coi">Optional output parameter for storing COI</param>
            <param name="allowNd">If non-zero, the function accepts multi-dimensional dense arrays (CvMatND*) and returns 2D (if CvMatND has two dimensions) or 1D matrix (when CvMatND has 1 dimension or more than 2 dimensions). The array must be continuous</param>
            <returns>Returns matrix header for the input array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetImage(System.IntPtr,System.IntPtr)">
            <summary>
            Returns image header for the input array that can be matrix - CvMat*, or image - IplImage*.
            </summary>
            <param name="arr">Input array. </param>
            <param name="imageHeader">Pointer to IplImage structure used as a temporary buffer.</param>
            <returns>Returns image header for the input array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCheckArr(System.IntPtr,Emgu.CV.CvEnum.CheckType,System.Double,System.Double)">
            <summary>
            Checks that every array element is neither NaN nor Infinity. If CV_CHECK_RANGE is set, it also checks that every element is greater than or equal to minVal and less than maxVal. 
            </summary>
            <param name="arr">The array to check.</param>
            <param name="flags">The operation flags, CHECK_NAN_INFINITY or combination of
            CHECK_RANGE - if set, the function checks that every value of array is within [minVal,maxVal) range, otherwise it just checks that every element is neither NaN nor Infinity.
            CHECK_QUIET - if set, the function does not raises an error if an element is invalid or out of range 
            </param>
            <param name="minVal">The inclusive lower boundary of valid values range. It is used only if CHECK_RANGE is set.</param>
            <param name="maxVal">The exclusive upper boundary of valid values range. It is used only if CHECK_RANGE is set.</param>
            <returns>Returns nonzero if the check succeeded, i.e. all elements are valid and within the range, and zero otherwise. In the latter case if CV_CHECK_QUIET flag is not set, the function raises runtime error.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetNumThreads">
            <summary>
            Return the current number of threads that are used by parallelized (via OpenMP) OpenCV functions.
            </summary>
            <returns>the current number of threads that are used by parallelized (via OpenMP) OpenCV functions</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SetNumThreads(System.Int32)">
            <summary>
            Sets the number of threads that are used by parallelized OpenCV functions. 
            </summary>
            <param name="threadsCount">The number of threads that are used by parallelized OpenCV functions. When the argument is zero or negative, and at the beginning of the program, the number of threads is set to the number of processors in the system, as returned by the function omp_get_num_procs() from OpenMP runtime. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetThreadNum">
            <summary>
            Returns the index, from 0 to cvGetNumThreads()-1, of the thread that called the function. It is a wrapper for the function omp_get_thread_num() from OpenMP runtime. The retrieved index may be used to access local-thread data inside the parallelized code fragments. 
            </summary>
            <returns>The index, from 0 to cvGetNumThreads()-1, of the thread that called the function. It is a wrapper for the function omp_get_thread_num() from OpenMP runtime. The retrieved index may be used to access local-thread data inside the parallelized code fragments. </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Compare(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.CmpType)">
            <summary>
            Compares the corresponding elements of two arrays and fills the destination mask array:
            dst(I)=src1(I) op src2(I),
            dst(I) is set to 0xff (all '1'-bits) if the particular relation between the elements is true and 0 otherwise. 
            All the arrays must have the same type, except the destination, and the same size (or ROI size)
            </summary>
            <param name="src1">The first image to compare with</param>
            <param name="src2">The second image to compare with</param>
            <param name="dst">dst(I) is set to 0xff (all '1'-bits) if the particular relation between the elements is true and 0 otherwise.</param>
            <param name="cmpOp">The comparison operator type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvArrToMat(System.IntPtr,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Converts CvMat, IplImage , or CvMatND to Mat.
            </summary>
            <param name="arr">Input CvMat, IplImage , or CvMatND.</param>
            <param name="allowND">When true (default value), CvMatND is converted to 2-dimensional Mat, if it is possible (see the discussion below); if it is not possible, or when the parameter is false, the function will report an error</param>
            <param name="copyData">When false (default value), no data is copied and only the new header is created, in this case, the original array should not be deallocated while the new matrix header is used; if the parameter is true, all the data is copied and you may deallocate the original array right after the conversion.</param>
            <param name="coiMode">Parameter specifying how the IplImage COI (when set) is handled. If coiMode=0 and COI is set, the function reports an error. If coiMode=1 , the function never reports an error. Instead, it returns the header to the whole original image and you will have to check and process COI manually. </param>
            <returns>The Mat header</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HConcat(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Horizontally concatenate two images
            </summary>
            <param name="src1">The first image</param>
            <param name="src2">The second image</param>
            <param name="dst">The result image</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.VConcat(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Vertically concatenate two images
            </summary>
            <param name="src1">The first image</param>
            <param name="src2">The second image</param>
            <param name="dst">The result image</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Swap(Emgu.CV.Mat,Emgu.CV.Mat)">
            <summary>
            Swaps two matrices
            </summary>
            <param name="m1">The Mat to be swapped</param>
            <param name="m2">The Mat to be swapped</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Swap(Emgu.CV.UMat,Emgu.CV.UMat)">
            <summary>
            Swaps two matrices
            </summary>
            <param name="m1">The UMat to be swapped</param>
            <param name="m2">The UMat to be swapped</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.OclFinish">
            <summary>
            Finishes OpenCL queue.
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.OclGetPlatformsSummary">
            <summary>
            Get the OpenCL platform summary as a string
            </summary>
            <returns>An OpenCL platform summary</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.OclSetDefaultDevice(System.String)">
            <summary>
            Set the default opencl device
            </summary>
            <param name="deviceName">The name of the opencl device</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Kmeans(Emgu.CV.IInputArray,System.Int32,Emgu.CV.IOutputArray,Emgu.CV.Structure.MCvTermCriteria,System.Int32,Emgu.CV.CvEnum.KMeansInitType,Emgu.CV.IOutputArray)">
            <summary>
            Implements k-means algorithm that finds centers of cluster_count clusters and groups the input samples around the clusters. On output labels(i) contains a cluster index for sample stored in the i-th row of samples matrix
            </summary>
            <param name="data">Floating-point matrix of input samples, one row per sample</param>
            <param name="bestLabels">Output integer vector storing cluster indices for every sample</param>
            <param name="termcrit">Specifies maximum number of iterations and/or accuracy (distance the centers move by between the subsequent iterations)</param>
            <param name="attempts">The number of attempts. Use 2 if not sure</param>
            <param name="flags">Flags, use 0 if not sure</param>
            <param name="centers">Pointer to array of centers, use IntPtr.Zero if not sure</param>
            <param name="k">Number of clusters to split the set by.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GrabCut(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,System.Drawing.Rectangle,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,System.Int32,Emgu.CV.CvEnum.GrabcutInitType)">
             <summary>
             The grab cut algorithm for segmentation
             </summary>
             <param name="img">The 8-bit 3-channel image to be segmented</param>
             <param name="mask">Input/output 8-bit single-channel mask. The mask is initialized by the function
             when mode is set to GC_INIT_WITH_RECT. Its elements may have one of following values:
             0 (GC_BGD) defines an obvious background pixels.
             1 (GC_FGD) defines an obvious foreground (object) pixel.
             2 (GC_PR_BGR) defines a possible background pixel.
             3 (GC_PR_FGD) defines a possible foreground pixel.
            </param>
             <param name="rect">The rectangle to initialize the segmentation</param>
             <param name="bgdModel">
             Temporary array for the background model. Do not modify it while you are
             processing the same image.
             </param>
             <param name="fgdModel">
             Temporary arrays for the foreground model. Do not modify it while you are
             processing the same image.
             </param>
             <param name="iterCount">The number of iterations</param>
             <param name="type">The initialization type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Sqrt(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Calculate square root of each source array element. in the case of multichannel
            arrays each channel is processed independently. The function accuracy is approximately
            the same as of the built-in std::sqrt.
            </summary>
            <param name="src">The source floating-point array</param>
            <param name="dst">The destination array; will have the same size and the same type as src</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ApplyColorMap(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.ColorMapType)">
            <summary>
            Apply color map to the image
            </summary>
            <param name="src">
            The source image.         
            This function expects Image&lt;Bgr, Byte&gt; or Image&lt;Gray, Byte&gt;. If the wrong image type is given, the original image
            will be returned.</param>
            <param name="dst">The destination image</param>
            <param name="colorMapType">The type of color map</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CheckRange(Emgu.CV.IInputArray,System.Boolean,System.Drawing.Point@,System.Double,System.Double)">
            <summary>
            Check that every array element is neither NaN nor +- inf. The functions also check that each value
            is between minVal and maxVal. in the case of multi-channel arrays each channel is processed
            independently. If some values are out of range, position of the first outlier is stored in pos, 
            and then the functions either return false (when quiet=true) or throw an exception.
            </summary>
            <param name="arr">The array to check</param>
            <param name="quiet">The flag indicating whether the functions quietly return false when the array elements are
            out of range, or they throw an exception</param>
            <param name="pos">This will be filled with the position of the first outlier</param>
            <param name="minVal">The inclusive lower boundary of valid values range</param>
            <param name="maxVal">The exclusive upper boundary of valid values range</param>
            <returns>If quiet, return true if all values are in range</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.EstimateAffine3D(Emgu.CV.Structure.MCvPoint3D32f[],Emgu.CV.Structure.MCvPoint3D32f[],Emgu.CV.Matrix{System.Double}@,System.Byte[]@,System.Double,System.Double)">
            <summary>
            Computes an optimal affine transformation between two 3D point sets.
            </summary>
            <param name="src">First input 3D point set.</param>
            <param name="dst">Second input 3D point set.</param>
            <param name="estimate">Output 3D affine transformation matrix.</param>
            <param name="inliers">Output vector indicating which points are inliers.</param>
            <param name="ransacThreshold">Maximum reprojection error in the RANSAC algorithm to consider a point as an inlier.</param>
            <param name="confidence">Confidence level, between 0 and 1, for the estimated transformation. Anything between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.EstimateAffine3D(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Double,System.Double)">
            <summary>
            Computes an optimal affine transformation between two 3D point sets.
            </summary>
            <param name="src"> First input 3D point set.</param>
            <param name="dst">Second input 3D point set.</param>
            <param name="affineEstimate">Output 3D affine transformation matrix 3 x 4</param>
            <param name="inliers"> Output vector indicating which points are inliers.</param>
            <param name="ransacThreshold">Maximum reprojection error in the RANSAC algorithm to consider a point as an inlier.</param>
            <param name="confidence">Confidence level, between 0 and 1, for the estimated transformation. Anything between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MinMaxIdx(Emgu.CV.IInputArray,System.Double@,System.Double@,System.Int32[],System.Int32[],Emgu.CV.IInputArray)">
            <summary>
            Finds the global minimum and maximum in an array
            </summary>
            <param name="src">Input single-channel array.</param>
            <param name="minVal">The returned minimum value</param>
            <param name="maxVal">The returned maximum value</param>
            <param name="minIdx">The returned minimum location</param>
            <param name="maxIdx">The returned maximum location</param>
            <param name="mask">The extremums are searched across the whole array if mask is IntPtr.Zert. Otherwise, search is performed in the specified array region.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Filter2D(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,System.Drawing.Point,System.Double,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Applies arbitrary linear filter to the image. In-place operation is supported. When the aperture is partially outside the image, the function interpolates outlier pixel values from the nearest pixels that is inside the image
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image</param>
            <param name="kernel">Convolution kernel, single-channel floating point matrix. If you want to apply different kernels to different channels, split the image using cvSplit into separate color planes and process them individually</param>
            <param name="anchor">The anchor of the kernel that indicates the relative position of a filtered point within the kernel. The anchor shoud lie within the kernel. The special default value (-1,-1) means that it is at the kernel center</param>
            <param name="delta">The optional value added to the filtered pixels before storing them in dst</param>
            <param name="borderType">The pixel extrapolation method.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CLAHE(Emgu.CV.IInputArray,System.Double,System.Drawing.Size,Emgu.CV.IOutputArray)">
            <summary>
            Contrast Limited Adaptive Histogram Equalization (CLAHE)
            </summary>
            <param name="src">The source image</param>
            <param name="clipLimit">Clip Limit, use 40 for default</param>
            <param name="tileGridSize">Tile grid size, use (8, 8) for default</param>
            <param name="dst">The destination image</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetCvStructSizes">
            <summary>
            This function retrieve the Open CV structure sizes in unmanaged code
            </summary>
            <returns>The structure that will hold the Open CV structure sizes</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindCirclesGrid(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},System.Drawing.Size,Emgu.CV.CvEnum.CalibCgType,Emgu.CV.Features2D.Feature2D)">
            <summary>
            Finds centers in the grid of circles
            </summary>
            <param name="image">Source chessboard view</param>
            <param name="patternSize">The number of inner circle per chessboard row and column</param>
            <param name="flags">Various operation flags</param>
            <param name="featureDetector">The feature detector. Use a SimpleBlobDetector for default</param>
            <returns>The center of circles detected if the chess board pattern is found, otherwise null is returned</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindCirclesGrid(Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.CalibCgType,Emgu.CV.Features2D.Feature2D)">
            <summary>
            Finds centers in the grid of circles
            </summary>
            <param name="image">Source chessboard view</param>
            <param name="patternSize">The number of inner circle per chessboard row and column</param>
            <param name="flags">Various operation flags</param>
            <param name="featureDetector">The feature detector. Use a SimpleBlobDetector for default</param>
            <param name="centers">output array of detected centers.</param>
            <returns>True if grid found.</returns>
        </member>
        <member name="F:Emgu.CV.CvInvoke.OpenCVModuleList">
            <summary>
            The List of the opencv modules
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.NamedWindow(System.String,Emgu.CV.CvEnum.NamedWindowType)">
            <summary>
            Creates a window which can be used as a placeholder for images and trackbars. Created windows are reffered by their names. 
            If the window with such a name already exists, the function does nothing.
            </summary>
            <param name="name">Name of the window which is used as window identifier and appears in the window caption</param>
            <param name="flags">Flags of the window.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.WaitKey(System.Int32)">
            <summary>
            Waits for key event infinitely (delay &lt;= 0) or for "delay" milliseconds. 
            </summary>
            <param name="delay">Delay in milliseconds.</param>
            <returns>The code of the pressed key or -1 if no key were pressed until the specified timeout has elapsed</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Imshow(System.String,Emgu.CV.IInputArray)">
            <summary>
            Shows the image in the specified window
            </summary>
            <param name="name">Name of the window</param>
            <param name="image">Image to be shown</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.DestroyWindow(System.String)">
            <summary>
            Destroys the window with a given name
            </summary>
            <param name="name">Name of the window to be destroyed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.DestroyAllWindows">
            <summary>
            Destroys all of the HighGUI windows.
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Imread(System.String,Emgu.CV.CvEnum.ImreadModes)">
            <summary>
            Loads an image from the specified file and returns the pointer to the loaded image. Currently the following file formats are supported: 
            Windows bitmaps - BMP, DIB; 
            JPEG files - JPEG, JPG, JPE; 
            Portable Network Graphics - PNG; 
            Portable image format - PBM, PGM, PPM; 
            Sun rasters - SR, RAS; 
            TIFF files - TIFF, TIF; 
            OpenEXR HDR images - EXR; 
            JPEG 2000 images - jp2. 
            </summary>
            <param name="filename">The name of the file to be loaded</param>
            <param name="loadType">The image loading type</param>
            <returns>The loaded image</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Imreadmulti(System.String,Emgu.CV.CvEnum.ImreadModes)">
            <summary>
            The function imreadmulti loads a multi-page image from the specified file into a vector of Mat objects.
            </summary>
            <param name="filename">Name of file to be loaded.</param>
            <param name="flags">Read flags</param>
            <returns>Null if the reading fails, otherwise, an array of Mat from the file</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Imwrite(System.String,Emgu.CV.IInputArray,System.Collections.Generic.KeyValuePair{Emgu.CV.CvEnum.ImwriteFlags,System.Int32}[])">
            <summary>
            Saves the image to the specified file. The image format is chosen depending on the filename extension, see cvLoadImage. Only 8-bit single-channel or 3-channel (with 'BGR' channel order) images can be saved using this function. If the format, depth or channel order is different, use cvCvtScale and cvCvtColor to convert it before saving, or use universal cvSave to save the image to XML or YAML format
            </summary>
            <param name="filename">The name of the file to be saved to</param>
            <param name="image">The image to be saved</param>
            <param name="parameters">The parameters</param>
            <returns>true if success</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Imdecode(System.Byte[],Emgu.CV.CvEnum.ImreadModes,Emgu.CV.Mat)">
            <summary>
            Decode image stored in the buffer
            </summary>
            <param name="buf">The buffer</param>
            <param name="loadType">The image loading type</param>
            <param name="dst">The output placeholder for the decoded matrix.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Imdecode(Emgu.CV.IInputArray,Emgu.CV.CvEnum.ImreadModes,Emgu.CV.Mat)">
            <summary>
            Decode image stored in the buffer
            </summary>
            <param name="buf">The buffer</param>
            <param name="loadType">The image loading type</param>
            <param name="dst">The output placeholder for the decoded matrix.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Imencode(System.String,Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfByte,System.Collections.Generic.KeyValuePair{Emgu.CV.CvEnum.ImwriteFlags,System.Int32}[])">
            <summary>
            encode image and store the result as a byte vector.
            </summary>
            <param name="ext">The image format</param>
            <param name="image">The image</param>
            <param name="buf">Output buffer resized to fit the compressed image.</param>
            <param name="parameters">The pointer to the array of integers, which contains the parameter for encoding, use IntPtr.Zero for default</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSampleLine(System.IntPtr,System.Drawing.Point@,System.Drawing.Point@,System.IntPtr,Emgu.CV.CvEnum.Connectivity)">
            <summary>
            Implements a particular case of application of line iterators. The function reads all the image points lying on the line between pt1 and pt2, including the ending points, and stores them into the buffer
            </summary>
            <param name="image">Image to sample the line from</param>
            <param name="pt1">Starting the line point.</param>
            <param name="pt2">Ending the line point</param>
            <param name="buffer">Buffer to store the line points; must have enough size to store max( |pt2.x-pt1.x|+1, |pt2.y-pt1.y|+1 ) points in case of 8-connected line and |pt2.x-pt1.x|+|pt2.y-pt1.y|+1 in case of 4-connected line</param>
            <param name="connectivity">The line connectivity, 4 or 8</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetRectSubPix(Emgu.CV.IInputArray,System.Drawing.Size,System.Drawing.PointF,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Extracts pixels from src:
            dst(x, y) = src(x + center.x - (width(dst)-1)*0.5, y + center.y - (height(dst)-1)*0.5)
            where the values of pixels at non-integer coordinates are retrieved using bilinear interpolation. Every channel of multiple-channel images is processed independently. Whereas the rectangle center must be inside the image, the whole rectangle may be partially occluded. In this case, the replication border mode is used to get pixel values beyond the image boundaries.
            </summary>
            <param name="image">Source image</param>
            <param name="patchSize">Size of the extracted patch.</param>
            <param name="patch">Extracted rectangle</param>
            <param name="patchType">Depth of the extracted pixels. By default, they have the same depth as <paramref name="image"/>.</param>
            <param name="center">Floating point coordinates of the extracted rectangle center within the source image. The center must be inside the image.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Resize(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Drawing.Size,System.Double,System.Double,Emgu.CV.CvEnum.Inter)">
            <summary>
            Resizes the image src down to or up to the specified size
            </summary>
            <param name="src">Source image.</param>
            <param name="dst">Destination image</param>
            <param name="dsize">Output image size; if it equals zero, it is computed as: dsize=Size(round(fx*src.cols), round(fy * src.rows)). Either dsize or both fx and fy must be non-zero.</param>
            <param name="fx">Scale factor along the horizontal axis</param>
            <param name="fy">Scale factor along the vertical axis;</param>
            <param name="interpolation">Interpolation method</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ResizeForFrame(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Drawing.Size,Emgu.CV.CvEnum.Inter,System.Boolean)">
            <summary>
            Resize an image such that it fits in a given frame
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The result image</param>
            <param name="frameSize">The size of the frame</param>
            <param name="interpolationMethod">The interpolation method</param>
            <param name="scaleDownOnly">If true, it will not try to scale up the image to fit the frame</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.WarpAffine(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Applies an affine transformation to an image.
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="mapMatrix">2x3 transformation matrix</param>
            <param name="dsize">Size of the output image.</param>
            <param name="interpMethod">Interpolation method</param>
            <param name="warpMethod">Warp method</param>
            <param name="borderMode">Pixel extrapolation method</param>
            <param name="borderValue">A value used to fill outliers</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetAffineTransform(System.Drawing.PointF[],System.Drawing.PointF[])">
            <summary>
            Calculates the matrix of an affine transform such that:
            (x'_i,y'_i)^T=map_matrix (x_i,y_i,1)^T
            where dst(i)=(x'_i,y'_i), src(i)=(x_i,y_i), i=0..2.
            </summary>
            <param name="src">Coordinates of 3 triangle vertices in the source image. If the array contains more than 3 points, only the first 3 will be used</param>
            <param name="dest">Coordinates of the 3 corresponding triangle vertices in the destination image. If the array contains more than 3 points, only the first 3 will be used</param>
            <returns>The 2x3 rotation matrix that defines the Affine transform</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetAffineTransform(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Calculates the matrix of an affine transform such that:
            (x'_i,y'_i)^T=map_matrix (x_i,y_i,1)^T
            where dst(i)=(x'_i,y'_i), src(i)=(x_i,y_i), i=0..2.
            </summary>
            <param name="src">Pointer to an array of PointF, Coordinates of 3 triangle vertices in the source image.</param>
            <param name="dst">Pointer to an array of PointF, Coordinates of the 3 corresponding triangle vertices in the destination image</param>
            <returns>The destination 2x3 matrix</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetRotationMatrix2D(System.Drawing.PointF,System.Double,System.Double,Emgu.CV.IOutputArray)">
            <summary>
            Calculates rotation matrix
            </summary>
            <param name="center">Center of the rotation in the source image. </param>
            <param name="angle">The rotation angle in degrees. Positive values mean couter-clockwise rotation (the coordiate origin is assumed at top-left corner).</param>
            <param name="scale">Isotropic scale factor</param>
            <param name="mapMatrix">Pointer to the destination 2x3 matrix</param>
            <returns>Pointer to the destination 2x3 matrix</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.WarpPerspective(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Applies a perspective transformation to an image
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="mapMatrix">3x3 transformation matrix</param>
            <param name="dsize">Size of the output image</param>
            <param name="interpolationType">Interpolation method</param>
            <param name="warpType">Warp method</param>
            <param name="borderMode">Pixel extrapolation method</param>
            <param name="borderValue">value used in case of a constant border</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetPerspectiveTransform(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            calculates matrix of perspective transform such that:
            (t_i x'_i,t_i y'_i,t_i)^T=map_matrix (x_i,y_i,1)T
            where dst(i)=(x'_i,y'_i), src(i)=(x_i,y_i), i=0..3.
            </summary>
            <param name="src">Coordinates of 4 quadrangle vertices in the source image</param>
            <param name="dst">Coordinates of the 4 corresponding quadrangle vertices in the destination image</param>
            <returns>The perspective transform matrix</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetPerspectiveTransform(System.Drawing.PointF[],System.Drawing.PointF[])">
            <summary>
            calculates matrix of perspective transform such that:
            (t_i x'_i,t_i y'_i,t_i)^T=map_matrix (x_i,y_i,1)^T
            where dst(i)=(x'_i,y'_i), src(i)=(x_i,y_i), i=0..3.
            </summary>
            <param name="src">Coordinates of 4 quadrangle vertices in the source image</param>
            <param name="dest">Coordinates of the 4 corresponding quadrangle vertices in the destination image</param>
            <returns>The 3x3 Homography matrix</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Remap(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Applies a generic geometrical transformation to an image.
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="map1">The first map of either (x,y) points or just x values having the type CV_16SC2 , CV_32FC1 , or CV_32FC2 . See convertMaps() for details on converting a floating point representation to fixed-point for speed.</param>
            <param name="map2">The second map of y values having the type CV_16UC1 , CV_32FC1 , or none (empty map if map1 is (x,y) points), respectively.</param>
            <param name="interpolation">Interpolation method (see resize() ). The method 'Area' is not supported by this function. </param>
            <param name="borderMode">Pixel extrapolation method </param>
            <param name="borderValue">A value used to fill outliers</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.InvertAffineTransform(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Inverts an affine transformation
            </summary>
            <param name="m">Original affine transformation</param>
            <param name="im">Output reverse affine transformation.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetDefaultNewCameraMatrix(Emgu.CV.IInputArray,System.Drawing.Size,System.Boolean)">
            <summary>
            Returns the default new camera matrix.
            </summary>
            <param name="cameraMatrix">Input camera matrix.</param>
            <param name="imgsize">Camera view image size in pixels.</param>
            <param name="centerPrincipalPoint">Location of the principal point in the new camera matrix. The parameter indicates whether this location should be at the image center or not.</param>
            <returns>The default new camera matrix.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.LogPolar(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Drawing.PointF,System.Double,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp)">
            <summary>
            The function emulates the human "foveal" vision and can be used for fast scale and rotation-invariant template matching, for object tracking etc.
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="center">The transformation center, where the output precision is maximal</param>
            <param name="M">Magnitude scale parameter</param>
            <param name="interpolationType">Interpolation method</param>
            <param name="warpType">warp method</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.LinearPolar(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Drawing.PointF,System.Double,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp)">
            <summary>
            The function emulates the human "foveal" vision and can be used for fast scale and rotation-invariant template matching, for object tracking etc.
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="center">The transformation center, where the output precision is maximal</param>
            <param name="maxRadius">Maximum radius</param>
            <param name="interpolationType">Interpolation method</param>
            <param name="warpType">Warp method</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PyrDown(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Performs downsampling step of Gaussian pyramid decomposition. First it convolves source image with the specified filter and then downsamples the image by rejecting even rows and columns.
            </summary>
            <param name="src">The source image.</param>
            <param name="dst">The destination image, should have 2x smaller width and height than the source.</param>
            <param name="borderType">Border type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PyrUp(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Performs up-sampling step of Gaussian pyramid decomposition. First it upsamples the source image by injecting even zero rows and columns and then convolves result with the specified filter multiplied by 4 for interpolation. So the destination image is four times larger than the source image.
            </summary>
            <param name="src">The source image.</param>
            <param name="dst">The destination image, should have 2x smaller width and height than the source.</param>
            <param name="borderType">Border type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Watershed(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray)">
            <summary>
            Implements one of the variants of watershed, non-parametric marker-based segmentation algorithm, described in [Meyer92] Before passing the image to the function, user has to outline roughly the desired regions in the image markers with positive (>0) indices, i.e. every region is represented as one or more connected components with the pixel values 1, 2, 3 etc. Those components will be "seeds" of the future image regions. All the other pixels in markers, which relation to the outlined regions is not known and should be defined by the algorithm, should be set to 0's. On the output of the function, each pixel in markers is set to one of values of the "seed" components, or to -1 at boundaries between the regions.
            </summary>
            <remarks>Note, that it is not necessary that every two neighbor connected components are separated by a watershed boundary (-1's pixels), for example, in case when such tangent components exist in the initial marker image. </remarks>
            <param name="image">The input 8-bit 3-channel image</param>
            <param name="markers">The input/output Int32 depth single-channel image (map) of markers. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMaxRect(System.Drawing.Rectangle,System.Drawing.Rectangle)">
            <summary>
            Finds minimum area rectangle that contains both input rectangles inside
            </summary>
            <param name="rect1">First rectangle </param>
            <param name="rect2">Second rectangle </param>
            <returns>The minimum area rectangle that contains both input rectangles inside</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FitLine(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DistType,System.Double,System.Double,System.Double)">
            <summary>
            Fits line to 2D or 3D point set 
            </summary>
            <param name="points">Input vector of 2D or 3D points, stored in std::vector or Mat.</param>
            <param name="distType">The distance used for fitting </param>
            <param name="param">Numerical parameter (C) for some types of distances, if 0 then some optimal value is chosen</param>
            <param name="reps">Sufficient accuracy for radius (distance between the coordinate origin and the line),  0.01 would be a good default</param>
            <param name="aeps">Sufficient accuracy for angle, 0.01 would be a good default</param>
            <param name="line">Output line parameters. In case of 2D ?tting, it should be a vector of 4 elements (like Vec4f) - (vx, vy, x0, y0), where (vx, vy) is a normalized vector collinear to the line 
            and (x0, y0) is a point on the line. In case of 3D ?tting, it should be a vector of 6 elements
            (like Vec6f) - (vx, vy, vz, x0, y0, z0), where (vx, vy, vz) is a normalized vector
            collinear to the line and (x0, y0, z0) is a point on the line.
            </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FitLine(System.Drawing.PointF[],System.Drawing.PointF@,System.Drawing.PointF@,Emgu.CV.CvEnum.DistType,System.Double,System.Double,System.Double)">
            <summary>
            Fits line to 2D or 3D point set 
            </summary>
            <param name="points">Input vector of 2D points.</param>
            <param name="distType">The distance used for fitting </param>
            <param name="param">Numerical parameter (C) for some types of distances, if 0 then some optimal value is chosen</param>
            <param name="reps">Sufficient accuracy for radius (distance between the coordinate origin and the line),  0.01 would be a good default</param>
            <param name="aeps">Sufficient accuracy for angle, 0.01 would be a good default</param>
            <param name="direction">A normalized vector collinear to the line </param>
            <param name="pointOnLine">A point on the line.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.RotatedRectangleIntersection(Emgu.CV.Structure.RotatedRect,Emgu.CV.Structure.RotatedRect,Emgu.CV.IOutputArray)">
            <summary>
            Finds out if there is any intersection between two rotated rectangles.
            </summary>
            <param name="rect1">First rectangle</param>
            <param name="rect2">Second rectangle</param>
            <param name="intersectingRegion">The output array of the verticies of the intersecting region. It returns at most 8 vertices. Stored as VectorOfPointF or Mat as Mx1 of type CV_32FC2.</param>
            <returns>The intersect type</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BoxPoints(Emgu.CV.Structure.RotatedRect)">
            <summary>
            Calculates vertices of the input 2d box.
            </summary>
            <param name="box">The box</param>
            <returns>The four vertices of rectangles.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BoxPoints(Emgu.CV.Structure.RotatedRect,Emgu.CV.IOutputArray)">
            <summary>
            Calculates vertices of the input 2d box.
            </summary>
            <param name="box">The box</param>
            <param name="points">The output array of four vertices of rectangles.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FitEllipse(Emgu.CV.IInputArray)">
            <summary>
            Fits an ellipse around a set of 2D points.
            </summary>
            <param name="points">Input 2D point set</param>
            <returns>The ellipse that fits best (in least-squares sense) to a set of 2D points</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ConvexHull(System.Drawing.PointF[],System.Boolean)">
            <summary>
            Finds convex hull of 2D point set using Sklansky's algorithm
            </summary>
            <param name="points">The points to find convex hull from</param>
            <param name="clockwise">Orientation flag. If it is true, the output convex hull is oriented clockwise. Otherwise, it is oriented counter-clockwise. The assumed coordinate system has its X axis pointing to the right, and its Y axis pointing upwards.</param>
            <returns>The convex hull of the points</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ConvexHull(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Boolean,System.Boolean)">
            <summary>
            The function cvConvexHull2 finds convex hull of 2D point set using Sklansky's algorithm. 
            </summary>
            <param name="points"> Input 2D point set</param>
            <param name="hull">Output convex hull. It is either an integer vector of indices or vector of points. In the first case, the hull elements are 0-based indices of the convex hull points in the original array (since the set of convex hull points is a subset of the original point set). In the second case, hull elements are the convex hull points themselves.</param>
            <param name="clockwise">Orientation flag. If it is true, the output convex hull is oriented clockwise. Otherwise, it is oriented counter-clockwise. The assumed coordinate system has its X axis pointing to the right, and its Y axis pointing upwards.</param>
            <param name="returnPoints">Operation flag. In case of a matrix, when the flag is true, the function returns convex hull points. Otherwise, it returns indices of the convex hull points. When the output array is std::vector, the flag is ignored, and the output depends on the type of the vector</param>
        </member>
        <member name="F:Emgu.CV.CvInvoke.MorphologyDefaultBorderValue">
            <summary>
            The default morphology value.
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Erode(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,System.Drawing.Point,System.Int32,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Erodes the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the minimum is taken:
            dst=erode(src,element):  dst(x,y)=min((x',y') in element)) src(x+x',y+y')
            The function supports the in-place mode. Erosion can be applied several (iterations) times. In case of color image each channel is processed independently.
            </summary>
            <param name="src">Source image. </param>
            <param name="dst">Destination image</param>
            <param name="element">Structuring element used for erosion. If it is IntPtr.Zero, a 3x3 rectangular structuring element is used.</param>
            <param name="iterations">Number of times erosion is applied.</param>
            <param name="borderType">Pixel extrapolation method</param>
            <param name="borderValue">Border value in case of a constant border, use Constant for default</param>
            <param name="anchor">Position of the anchor within the element; default value (-1, -1) means that the anchor is at the element center.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Dilate(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,System.Drawing.Point,System.Int32,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Dilates the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the maximum is taken
            The function supports the in-place mode. Dilation can be applied several (iterations) times. In case of color image each channel is processed independently
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="element">Structuring element used for erosion. If it is IntPtr.Zero, a 3x3 rectangular structuring element is used</param>
            <param name="iterations">Number of times erosion is applied</param>
            <param name="borderType">Pixel extrapolation method</param>
            <param name="borderValue">Border value in case of a constant border </param>
            <param name="anchor">Position of the anchor within the element; default value (-1, -1) means that the anchor is at the element center.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GaussianBlur(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Drawing.Size,System.Double,System.Double,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Blurs an image using a Gaussian filter.
            </summary>
            <param name="src">input image; the image can have any number of channels, which are processed independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</param>
            <param name="dst">output image of the same size and type as src.</param>
            <param name="ksize">Gaussian kernel size. ksize.width and ksize.height can differ but they both must be positive and odd. Or, they can be zeros and then they are computed from sigma* .</param>
            <param name="sigmaX">Gaussian kernel standard deviation in X direction.</param>
            <param name="sigmaY">Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be equal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height , respectively (see getGaussianKernel() for details); to fully control the result regardless of possible future modifications of all this semantics, it is recommended to specify all of ksize, sigmaX, and sigmaY.</param>
            <param name="borderType">Pixel extrapolation method</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Blur(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Drawing.Size,System.Drawing.Point,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Blurs an image using the normalized box filter.
            </summary>
            <param name="src">input image; it can have any number of channels, which are processed independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</param>
            <param name="dst">Output image of the same size and type as src.</param>
            <param name="ksize">Blurring kernel size.</param>
            <param name="anchor">Anchor point; default value Point(-1,-1) means that the anchor is at the kernel center.</param>
            <param name="borderType">Border mode used to extrapolate pixels outside of the image.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MedianBlur(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32)">
            <summary>
            Blurs an image using the median filter.
            </summary>
            <param name="src">Input 1-, 3-, or 4-channel image; when ksize is 3 or 5, the image depth should be CV_8U, CV_16U, or CV_32F, for larger aperture sizes, it can only be CV_8U.</param>
            <param name="dst">Destination array of the same size and type as src.</param>
            <param name="ksize">Aperture linear size; it must be odd and greater than 1, for example: 3, 5, 7 ...</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BoxFilter(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,System.Drawing.Size,System.Drawing.Point,System.Boolean,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Blurs an image using the box filter.
            </summary>
            <param name="src">Input image.</param>
            <param name="dst">Output image of the same size and type as src.</param>
            <param name="ddepth">The output image depth (-1 to use src.depth()).</param>
            <param name="ksize">Blurring kernel size.</param>
            <param name="anchor">Anchor point; default value Point(-1,-1) means that the anchor is at the kernel center.</param>
            <param name="normalize">Specifying whether the kernel is normalized by its area or not.</param>
            <param name="borderType">Border mode used to extrapolate pixels outside of the image.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BilateralFilter(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Double,System.Double,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Applies the bilateral filter to an image.
            </summary>
            <param name="src">Source 8-bit or floating-point, 1-channel or 3-channel image.</param>
            <param name="dst">Destination image of the same size and type as src .</param>
            <param name="d">Diameter of each pixel neighborhood that is used during filtering. If it is non-positive, it is computed from sigmaSpace .</param>
            <param name="sigmaColor">Filter sigma in the color space. A larger value of the parameter means that farther colors within the pixel neighborhood (see sigmaSpace ) will be mixed together, resulting in larger areas of semi-equal color.</param>
            <param name="sigmaSpace">Filter sigma in the coordinate space. A larger value of the parameter means that farther pixels will influence each other as long as their colors are close enough (see sigmaColor ). When d>0 , it specifies the neighborhood size regardless of sigmaSpace. Otherwise, d is proportional to sigmaSpace.</param>
            <param name="borderType">Border mode used to extrapolate pixels outside of the image.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Sobel(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,System.Int32,System.Int32,System.Int32,System.Double,System.Double,Emgu.CV.CvEnum.BorderType)">
             <summary>
             The Sobel operators combine Gaussian smoothing and differentiation so the result is more or less robust to the noise. Most often, the function is called with (xorder=1, yorder=0, aperture_size=3) or (xorder=0, yorder=1, aperture_size=3) to calculate first x- or y- image derivative. The first case corresponds to
             <pre> 
              |-1  0  1|
              |-2  0  2|
              |-1  0  1|</pre>
             kernel and the second one corresponds to
             <pre>
              |-1 -2 -1|
              | 0  0  0|
              | 1  2  1|</pre>
             or
             <pre>
              | 1  2  1|
              | 0  0  0|
              |-1 -2 -1|</pre>
             kernel, depending on the image origin (origin field of IplImage structure). No scaling is done, so the destination image usually has larger by absolute value numbers than the source image. To avoid overflow, the function requires 16-bit destination image if the source image is 8-bit. The result can be converted back to 8-bit using cvConvertScale or cvConvertScaleAbs functions. Besides 8-bit images the function can process 32-bit floating-point images. Both source and destination must be single-channel images of equal size or ROI size
             </summary>
             <param name="src">Source image.</param>
             <param name="dst">Destination image</param>
             <param name="ddepth">output image depth; the following combinations of src.depth() and ddepth are supported:
             <para> src.depth() = CV_8U, ddepth = -1/CV_16S/CV_32F/CV_64F </para>
             <para> src.depth() = CV_16U/CV_16S, ddepth = -1/CV_32F/CV_64F</para>
             <para> src.depth() = CV_32F, ddepth = -1/CV_32F/CV_64F</para>
             <para>src.depth() = CV_64F, ddepth = -1/CV_64F</para>
             when ddepth=-1, the destination image will have the same depth as the source; in the case of 8-bit input images it will result in truncated derivatives.</param>
             <param name="xorder">Order of the derivative x </param>
             <param name="yorder">Order of the derivative y</param>
             <param name="kSize">Size of the extended Sobel kernel, must be 1, 3, 5 or 7. </param>
            <param name="borderType">Pixel extrapolation method </param>
            <param name="scale">Optional scale factor for the computed derivative values</param>
            <param name="delta">Optional delta value that is added to the results prior to storing them in <paramref name="dst"/></param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Laplacian(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,System.Int32,System.Double,System.Double,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Calculates Laplacian of the source image by summing second x- and y- derivatives calculated using Sobel operator:
            dst(x,y) = d2src/dx2 + d2src/dy2
            Specifying aperture_size=1 gives the fastest variant that is equal to convolving the image with the following kernel:
            |0  1  0|
            |1 -4  1|
            |0  1  0|
            Similar to cvSobel function, no scaling is done and the same combinations of input and output formats are supported. 
            </summary>
            <param name="src">Source image. </param>
            <param name="dst">Destination image. Should have type of float</param>
            <param name="ddepth">Desired depth of the destination image.</param>
            <param name="ksize">Aperture size used to compute the second-derivative filters.</param>
            <param name="scale">Optional scale factor for the computed Laplacian values. By default, no scaling is applied. </param>
            <param name="delta">Optional delta value that is added to the results prior to storing them in dst.</param>
            <param name="borderType"> Pixel extrapolation method.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Canny(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,System.Int32,System.Boolean)">
             <summary>
             Finds the edges on the input <paramref name="image"/> and marks them in the output image edges using the Canny algorithm. The smallest of threshold1 and threshold2 is used for edge linking, the largest - to find initial segments of strong edges.
             </summary>
             <param name="image">Input image</param>
             <param name="edges">Image to store the edges found by the function</param>
             <param name="threshold1">The first threshold</param>
             <param name="threshold2">The second threshold.</param>
             <param name="apertureSize">Aperture parameter for Sobel operator </param>
            <param name="l2Gradient">a flag, indicating whether a more accurate norm should be used to calculate the image gradient magnitude ( L2gradient=true ), or whether the default norm is enough ( L2gradient=false ).</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.IsContourConvex(Emgu.CV.IInputArray)">
            <summary>
            The function tests whether the input contour is convex or not. The contour must be simple, that is, without self-intersections. Otherwise, the function output is undefined.
            </summary>
            <param name="contour">Input vector of 2D points </param>
            <returns>true if input is convex</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PointPolygonTest(Emgu.CV.IInputArray,System.Drawing.PointF,System.Boolean)">
            <summary>
            Determines whether the point is inside contour, outside, or lies on an edge (or coinsides with a vertex). It returns positive, negative or zero value, correspondingly
            </summary>
            <param name="contour">Input contour</param>
            <param name="pt">The point tested against the contour</param>
            <param name="measureDist">If != 0, the function estimates distance from the point to the nearest contour edge</param>
            <returns>
            When measureDist = false, the return value is &gt;0 (inside), &lt;0 (outside) and =0 (on edge), respectively. 
            When measureDist != true, it is a signed distance between the point and the nearest contour edge
            </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ConvexityDefects(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Finds the convexity defects of a contour.
            </summary>
            <param name="contour">Input contour</param>
            <param name="convexhull">Convex hull obtained using ConvexHull that should contain pointers or indices to the contour points, not the hull points themselves, i.e. return_points parameter in cvConvexHull2 should be 0</param>
            <param name="convexityDefects">The output vector of convexity defects. Each convexity defect is represented as 4-element integer vector (a.k.a. cv::Vec4i): (start_index, end_index, farthest_pt_index, fixpt_depth), where indices are 0-based indices in the original contour of the convexity defect beginning, end and the farthest point, and fixpt_depth is fixed-point approximation (with 8 fractional bits) of the distance between the farthest contour point and the hull. That is, to get the floating-point value of the depth will be fixpt_depth/256.0. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MinAreaRect(System.Drawing.PointF[])">
            <summary>
            Find the bounding rectangle for the specific array of points
            </summary>
            <param name="points">The collection of points</param>
            <returns>The bounding rectangle for the array of points</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MinAreaRect(Emgu.CV.IInputArray)">
            <summary>
            Finds a rotated rectangle of the minimum area enclosing the input 2D point set.
            </summary>
            <param name="points">Input vector of 2D points</param>
            <returns>a circumscribed rectangle of the minimal area for 2D point set</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MinEnclosingCircle(System.Drawing.PointF[])">
             <summary>
             Finds the minimal circumscribed circle for 2D point set using iterative algorithm. It returns nonzero if the resultant circle contains all the input points and zero otherwise (i.e. algorithm failed)
             </summary>
             <param name="points">Sequence or array of 2D points</param>
            <returns>The minimal circumscribed circle for 2D point set</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MinEnclosingCircle(Emgu.CV.IInputArray)">
             <summary>
             Finds the minimal circumscribed circle for 2D point set using iterative algorithm. It returns nonzero if the resultant circle contains all the input points and zero otherwise (i.e. algorithm failed)
             </summary>
             <param name="points">Sequence or array of 2D points</param>
            <returns>The minimal circumscribed circle for 2D point set</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MinEnclosingTriangle(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Finds a triangle of minimum area enclosing a 2D point set and returns its area.
            </summary>
            <param name="points">Input vector of 2D points with depth CV_32S or CV_32F</param>
            <param name="triangles">Output vector of three 2D points defining the vertices of the triangle. The depth of the OutputArray must be CV_32F.</param>
            <returns>The triangle's area</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ApproxPolyDP(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Boolean)">
             <summary>
             Approximates a polygonal curve(s) with the specified precision.
             </summary>
            <param name="curve">Input vector of a 2D point</param>
             <param name="approxCurve">Result of the approximation. The type should match the type of the input curve. </param>
             <param name="epsilon">Parameter specifying the approximation accuracy. This is the maximum distance between the original curve and its approximation.</param>
             <param name="closed"> If true, the approximated curve is closed (its first and last vertices are connected). Otherwise, it is not closed.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.BoundingRectangle(Emgu.CV.IInputArray)">
            <summary>
            Returns the up-right bounding rectangle for 2d point set
            </summary>
            <param name="points"> Input 2D point set, stored in std::vector or Mat.</param>
            <returns>The up-right bounding rectangle for 2d point set</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ContourArea(Emgu.CV.IInputArray,System.Boolean)">
            <summary>
            Calculates area of the whole contour or contour section. 
            </summary>
            <param name="contour">Input vector of 2D points (contour vertices), stored in std::vector or Mat. </param>
            <param name="oriented">Oriented area flag. If it is true, the function returns a signed area value, depending on the contour orientation (clockwise or counter-clockwise).
            Using this feature you can determine orientation of a contour by taking the sign of an area. 
            By default, the parameter is false, which means that the absolute value is returned.</param>
            <returns>The area of the whole contour or contour section</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ArcLength(Emgu.CV.IInputArray,System.Boolean)">
            <summary>
            Calculates a contour perimeter or a curve length
            </summary>
            <param name="curve">Sequence or array of the curve points</param>
            <param name="isClosed">
            Indicates whether the curve is closed or not.
            </param>
            <returns>Contour perimeter or a curve length</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Threshold(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,Emgu.CV.CvEnum.ThresholdType)">
            <summary>
            Applies fixed-level thresholding to single-channel array. The function is typically used to get bi-level (binary) image out of grayscale image (cvCmpS could be also used for this purpose) or for removing a noise, i.e. filtering out pixels with too small or too large values. There are several types of thresholding the function supports that are determined by threshold_type
            </summary>
            <param name="src">Source array (single-channel, 8-bit of 32-bit floating point). </param>
            <param name="dst">Destination array; must be either the same type as src or 8-bit. </param>
            <param name="threshold">Threshold value</param>
            <param name="maxValue">Maximum value to use with CV_THRESH_BINARY and CV_THRESH_BINARY_INV thresholding types</param>
            <param name="thresholdType">Thresholding type </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.AdaptiveThreshold(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,Emgu.CV.CvEnum.AdaptiveThresholdType,Emgu.CV.CvEnum.ThresholdType,System.Int32,System.Double)">
            <summary>
            Transforms grayscale image to binary image. 
            Threshold calculated individually for each pixel. 
            For the method CV_ADAPTIVE_THRESH_MEAN_C it is a mean of <paramref name="blockSize"/> x <paramref name="blockSize"/> pixel
            neighborhood, subtracted by param1. 
            For the method CV_ADAPTIVE_THRESH_GAUSSIAN_C it is a weighted sum (gaussian) of <paramref name="blockSize"/> x <paramref name="blockSize"/> pixel neighborhood, subtracted by param1.
            </summary>
            <param name="src">Source array (single-channel, 8-bit of 32-bit floating point). </param>
            <param name="dst">Destination array; must be either the same type as src or 8-bit. </param>
            <param name="maxValue">Maximum value to use with CV_THRESH_BINARY and CV_THRESH_BINARY_INV thresholding types</param>
            <param name="adaptiveType">Adaptive_method </param>
            <param name="thresholdType">Thresholding type. must be one of CV_THRESH_BINARY, CV_THRESH_BINARY_INV  </param>
            <param name="blockSize">The size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, ... </param>
            <param name="param1">Constant subtracted from mean or weighted mean. It may be negative. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindContours(Emgu.CV.IInputOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.RetrType,Emgu.CV.CvEnum.ChainApproxMethod,System.Drawing.Point)">
            <summary>
            Retrieves contours from the binary image and returns the number of retrieved contours. The pointer firstContour is filled by the function. It will contain pointer to the first most outer contour or IntPtr.Zero if no contours is detected (if the image is completely black). Other contours may be reached from firstContour using h_next and v_next links. The sample in cvDrawContours discussion shows how to use contours for connected component detection. Contours can be also used for shape analysis and object recognition - see squares.c in OpenCV sample directory
            The function modifies the source image content
            </summary>
            <param name="image">The source 8-bit single channel image. Non-zero pixels are treated as 1s, zero pixels remain 0s - that is image treated as binary. To get such a binary image from grayscale, one may use cvThreshold, cvAdaptiveThreshold or cvCanny. The function modifies the source image content</param>
            <param name="contours">Detected contours. Each contour is stored as a vector of points.</param>
            <param name="hierarchy">Optional output vector, containing information about the image topology.</param>
            <param name="mode">Retrieval mode</param>
            <param name="method">Approximation method (for all the modes, except CV_RETR_RUNS, which uses built-in approximation). </param>
            <param name="offset">Offset, by which every contour point is shifted. This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context</param>
            <returns>The number of countours</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FindContourTree(Emgu.CV.IInputOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.ChainApproxMethod,System.Drawing.Point)">
            <summary>
            Retrieves contours from the binary image as a contour tree. The pointer firstContour is filled by the function. It is provided as a convenient way to obtain the hierarchy value as int[,].
            The function modifies the source image content
            </summary>
            <param name="image">The source 8-bit single channel image. Non-zero pixels are treated as 1s, zero pixels remain 0s - that is image treated as binary. To get such a binary image from grayscale, one may use cvThreshold, cvAdaptiveThreshold or cvCanny. The function modifies the source image content</param>
            <param name="contours">Detected contours. Each contour is stored as a vector of points.</param>
            <param name="method">Approximation method (for all the modes, except CV_RETR_RUNS, which uses built-in approximation). </param>
            <param name="offset">Offset, by which every contour point is shifted. This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context</param>
            <returns>The contour hierarchy</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.RawDataToBitmap(System.IntPtr,System.Int32,System.Drawing.Size,System.Type,System.Int32,System.Type,System.Boolean)">
            <summary>
            Convert raw data to bitmap
            </summary>
            <param name="scan0">The pointer to the raw data</param>
            <param name="step">The step</param>
            <param name="size">The size of the image</param>
            <param name="srcColorType">The source image color type</param>
            <param name="numberOfChannels">The number of channels</param>
            <param name="srcDepthType">The source image depth type</param>
            <param name="tryDataSharing">Try to create Bitmap that shares the data with the image</param>
            <returns>The Bitmap</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvtColor(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Type,System.Type)">
            <summary>
            Converts input image from one color space to another. The function ignores colorModel and channelSeq fields of IplImage header, so the source image color space should be specified correctly (including order of the channels in case of RGB space, e.g. BGR means 24-bit format with B0 G0 R0 B1 G1 R1 ... layout, whereas RGB means 24-bit format with R0 G0 B0 R1 G1 B1 ... layout). 
            </summary>
            <param name="src">The source 8-bit (8u), 16-bit (16u) or single-precision floating-point (32f) image</param>
            <param name="dest">The destination image of the same data type as the source one. The number of channels may be different</param>
            <param name="srcColor">Source color type. </param>
            <param name="destColor">Destination color type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvtColor(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.ColorConversion,System.Int32)">
            <summary>
            Converts input image from one color space to another. The function ignores colorModel and channelSeq fields of IplImage header, so the source image color space should be specified correctly (including order of the channels in case of RGB space, e.g. BGR means 24-bit format with B0 G0 R0 B1 G1 R1 ... layout, whereas RGB means 24-bit format with R0 G0 B0 R1 G1 B1 ... layout). 
            </summary>
            <param name="src">The source 8-bit (8u), 16-bit (16u) or single-precision floating-point (32f) image</param>
            <param name="dst">The destination image of the same data type as the source one. The number of channels may be different</param>
            <param name="code">Color conversion operation that can be specifed using CV_src_color_space2dst_color_space constants </param>
            <param name="dstCn">number of channels in the destination image; if the parameter is 0, the number of the channels is derived automatically from src and code .</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HoughCircles(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.HoughType,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32)">
            <summary>
            Finds circles in grayscale image using some modification of Hough transform
            </summary>
            <param name="image">The input 8-bit single-channel grayscale image</param>
            <param name="circles">The storage for the circles detected. It can be a memory storage (in this case a sequence of circles is created in the storage and returned by the function) or single row/single column matrix (CvMat*) of type CV_32FC3, to which the circles' parameters are written. The matrix header is modified by the function so its cols or rows will contain a number of lines detected. If circle_storage is a matrix and the actual number of lines exceeds the matrix size, the maximum possible number of circles is returned. Every circle is encoded as 3 floating-point numbers: center coordinates (x,y) and the radius</param>
            <param name="method">Currently, the only implemented method is CV_HOUGH_GRADIENT</param>
            <param name="dp">Resolution of the accumulator used to detect centers of the circles. For example, if it is 1, the accumulator will have the same resolution as the input image, if it is 2 - accumulator will have twice smaller width and height, etc</param>
            <param name="minDist">Minimum distance between centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed</param>
            <param name="param1">The first method-specific parameter. In case of CV_HOUGH_GRADIENT it is the higher threshold of the two passed to Canny edge detector (the lower one will be twice smaller). </param>
            <param name="param2">The second method-specific parameter. In case of CV_HOUGH_GRADIENT it is accumulator threshold at the center detection stage. The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator values, will be returned first</param>
            <param name="minRadius">Minimal radius of the circles to search for</param>
            <param name="maxRadius">Maximal radius of the circles to search for. By default the maximal radius is set to max(image_width, image_height). </param>
            <returns>Pointer to the sequence of circles</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HoughCircles(Emgu.CV.IInputArray,Emgu.CV.CvEnum.HoughType,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32)">
            <summary>
            Finds circles in a grayscale image using the Hough transform
            </summary>
            <param name="image">8-bit, single-channel, grayscale input image.</param>
            <param name="method">Detection method to use. Currently, the only implemented method is CV_HOUGH_GRADIENT , which is basically 21HT</param>
            <param name="dp">Inverse ratio of the accumulator resolution to the image resolution. For example, if dp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has half as big width and height.</param>
            <param name="minDist">Minimum distance between the centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed.</param>
            <param name="param1">First method-specific parameter. In case of CV_HOUGH_GRADIENT , it is the higher threshold of the two passed to the Canny() edge detector (the lower one is twice smaller).</param>
            <param name="param2">Second method-specific parameter. In case of CV_HOUGH_GRADIENT , it is the accumulator threshold for the circle centers at the detection stage. The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator values, will be returned first.</param>
            <param name="minRadius"> Minimum circle radius.</param>
            <param name="maxRadius">Maximum circle radius.</param>
            <returns>The circles detected</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HoughLines(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Finds lines in a binary image using the standard Hough transform.
            </summary>
            <param name="image">8-bit, single-channel binary source image. The image may be modified by the function.</param>
            <param name="lines">Output vector of lines. Each line is represented by a two-element vector</param>
            <param name="rho">Distance resolution of the accumulator in pixels.</param>
            <param name="theta">Angle resolution of the accumulator in radians.</param>
            <param name="threshold">Accumulator threshold parameter. Only those lines are returned that get enough votes (&gt; threshold)</param>
            <param name="srn">For the multi-scale Hough transform, it is a divisor for the distance resolution rho . The coarse accumulator distance resolution is rho and the accurate accumulator resolution is rho/srn . If both srn=0 and stn=0 , the classical Hough transform is used. Otherwise, both these parameters should be positive.</param>
            <param name="stn"> For the multi-scale Hough transform, it is a divisor for the distance resolution theta</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HoughLinesP(Emgu.CV.IInputArray,System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Finds line segments in a binary image using the probabilistic Hough transform.
            </summary>
            <param name="image">8-bit, single-channel binary source image. The image may be modified by the function.</param>
            <param name="rho">Distance resolution of the accumulator in pixels</param>
            <param name="theta">Angle resolution of the accumulator in radians</param>
            <param name="threshold">Accumulator threshold parameter. Only those lines are returned that get enough votes</param>
            <param name="minLineLength">Minimum line length. Line segments shorter than that are rejected.</param>
            <param name="maxGap">Maximum allowed gap between points on the same line to link them.</param>
            <returns>The found line segments</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HoughLinesP(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Finds line segments in a binary image using the probabilistic Hough transform.
            </summary>
            <param name="image">8-bit, single-channel binary source image. The image may be modified by the function.</param>
            <param name="lines"> Output vector of lines. Each line is represented by a 4-element vector (x1, y1, x2, y2)</param>
            <param name="rho">Distance resolution of the accumulator in pixels</param>
            <param name="theta">Angle resolution of the accumulator in radians</param>
            <param name="threshold">Accumulator threshold parameter. Only those lines are returned that get enough votes</param>
            <param name="minLineLength">Minimum line length. Line segments shorter than that are rejected.</param>
            <param name="maxGap">Maximum allowed gap between points on the same line to link them.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Moments(Emgu.CV.IInputArray,System.Boolean)">
            <summary>
            Calculates spatial and central moments up to the third order and writes them to moments. The moments may be used then to calculate gravity center of the shape, its area, main axises and various shape characeteristics including 7 Hu invariants.
            </summary>
            <param name="arr">Image (1-channel or 3-channel with COI set) or polygon (CvSeq of points or a vector of points)</param>
            <param name="binaryImage">(For images only) If the flag is true, all the zero pixel values are treated as zeroes, all the others are treated as 1s</param>
            <returns>The moment</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MatchTemplate(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.TemplateMatchingType,Emgu.CV.IInputArray)">
            <summary>
            This function is similiar to cvCalcBackProjectPatch. It slids through image, compares overlapped patches of size wxh with templ using the specified method and stores the comparison results to result
            </summary>
            <param name="image">Image where the search is running. It should be 8-bit or 32-bit floating-point</param>
            <param name="templ">Searched template; must be not greater than the source image and the same data type as the image</param>
            <param name="result">A map of comparison results; single-channel 32-bit floating-point. If image is WxH and templ is wxh then result must be W-w+1xH-h+1.</param>
            <param name="method">Specifies the way the template must be compared with image regions </param>
            <param name="mask">Mask of searched template. It must have the same datatype and size with templ. It is not set by default.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MatchShapes(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.ContoursMatchType,System.Double)">
            <summary>
            Compares two shapes. The 3 implemented methods all use Hu moments
            </summary>
            <param name="contour1">First contour or grayscale image</param>
            <param name="contour2">Second contour or grayscale image</param>
            <param name="method">Comparison method</param>
            <param name="parameter">Method-specific parameter (is not used now)</param>
            <returns>The result of the comparison</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GetStructuringElement(Emgu.CV.CvEnum.ElementShape,System.Drawing.Size,System.Drawing.Point)">
            <summary>
            Returns a structuring element of the specified size and shape for morphological operations.
            </summary>
            <param name="shape">Element shape</param>
            <param name="ksize">Size of the structuring element.</param>
            <param name="anchor">Anchor position within the element. The value (-1, -1) means that the anchor is at the center. Note that only the shape of a cross-shaped element depends on the anchor position. In other cases the anchor just regulates how much the result of the morphological operation is shifted.</param>
            <returns>The structuring element</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MorphologyEx(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.MorphOp,Emgu.CV.IInputArray,System.Drawing.Point,System.Int32,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Performs advanced morphological transformations.
            </summary>
            <param name="src">Source image.</param>
            <param name="dst">Destination image.</param>
            <param name="kernel">Structuring element.</param>
            <param name="operation">Type of morphological operation.</param>
            <param name="iterations">Number of times erosion and dilation are applied.</param>
            <param name="borderType">Pixel extrapolation method.</param>
            <param name="anchor">Anchor position with the kernel. Negative values mean that the anchor is at the kernel center.</param>
            <param name="borderValue">Border value in case of a constant border. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.EqualizeHist(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            The algorithm normalizes brightness and increases contrast of the image
            </summary>
            <param name="src">The input 8-bit single-channel image</param>
            <param name="dst">The output image of the same size and the same data type as src</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcHist(Emgu.CV.IInputArrayOfArrays,System.Int32[],Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32[],System.Single[],System.Boolean)">
            <summary>
            Calculates a histogram of a set of arrays.
            </summary>
            <param name="images">Source arrays. They all should have the same depth, CV_8U or CV_32F , and the same size. Each of them can have an arbitrary number of channels.</param>
            <param name="channels">List of the channels used to compute the histogram. </param>
            <param name="mask">Optional mask. If the matrix is not empty, it must be an 8-bit array of the same size as images[i] . The non-zero mask elements mark the array elements counted in the histogram.</param>
            <param name="hist">Output histogram</param>
            <param name="histSize">Array of histogram sizes in each dimension.</param>
            <param name="ranges">Array of the dims arrays of the histogram bin boundaries in each dimension.</param>
            <param name="accumulate">Accumulation flag. If it is set, the histogram is not cleared in the beginning when it is allocated. This feature enables you to compute a single histogram from several sets of arrays, or to update the histogram in time.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcBackProject(Emgu.CV.IInputArrayOfArrays,System.Int32[],Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single[],System.Double)">
            <summary>
            Calculates the back projection of a histogram.
            </summary>
            <param name="images">Source arrays. They all should have the same depth, CV_8U or CV_32F , and the same size. Each of them can have an arbitrary number of channels.</param>
            <param name="channels">Number of source images.</param>
            <param name="hist">Input histogram that can be dense or sparse.</param>
            <param name="backProject">Destination back projection array that is a single-channel array of the same size and depth as images[0] .</param>
            <param name="ranges">Array of arrays of the histogram bin boundaries in each dimension.</param>
            <param name="scale"> Optional scale factor for the output back projection.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CompareHist(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.HistogramCompMethod)">
            <summary>
            Compares two histograms.
            </summary>
            <param name="h1">First compared histogram.</param>
            <param name="h2">Second compared histogram of the same size as H1 .</param>
            <param name="method">Comparison method</param>
            <returns>The distance between the histogram</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetSpatialMoment(Emgu.CV.Structure.MCvMoments@,System.Int32,System.Int32)">
            <summary>
            Retrieves the spatial moment, which in case of image moments is defined as:
            M_{x_order,y_order}=sum_{x,y}(I(x,y) * x^{x_order} * y^{y_order})
            where I(x,y) is the intensity of the pixel (x, y). 
            </summary>
            <param name="moments">The moment state</param>
            <param name="xOrder">x order of the retrieved moment, xOrder &gt;= 0. </param>
            <param name="yOrder">y order of the retrieved moment, yOrder &gt;= 0 and xOrder + y_order &lt;= 3</param>
            <returns>The spatial moment</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetCentralMoment(Emgu.CV.Structure.MCvMoments@,System.Int32,System.Int32)">
            <summary>
            Retrieves the central moment, which in case of image moments is defined as:
            mu_{x_order,y_order}=sum_{x,y}(I(x,y)*(x-x_c)^{x_order} * (y-y_c)^{y_order}),
            where x_c=M10/M00, y_c=M01/M00 - coordinates of the gravity center
            </summary>
            <param name="moments">Reference to the moment state structure</param>
            <param name="xOrder">x order of the retrieved moment, xOrder &gt;= 0.</param>
            <param name="yOrder">y order of the retrieved moment, yOrder &gt;= 0 and xOrder + y_order &lt;= 3</param>
            <returns>The center moment</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetNormalizedCentralMoment(Emgu.CV.Structure.MCvMoments@,System.Int32,System.Int32)">
            <summary>
            Retrieves normalized central moment, which in case of image moments is defined as:
            eta_{x_order,y_order}=mu_{x_order,y_order} / M00^{(y_order+x_order)/2+1},
            where mu_{x_order,y_order} is the central moment
            </summary>
            <param name="moments">Reference to the moment state structure</param>
            <param name="xOrder">x order of the retrieved moment, xOrder &gt;= 0.</param>
            <param name="yOrder">y order of the retrieved moment, yOrder &gt;= 0 and xOrder + y_order &lt;= 3</param>
            <returns>The normalized center moment</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Accumulate(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Adds the whole image or its selected region to accumulator sum
            </summary>
            <param name="src">Input image, 1- or 3-channel, 8-bit or 32-bit floating point. (each channel of multi-channel image is processed independently). </param>
            <param name="dst">Accumulator of the same number of channels as input image, 32-bit or 64-bit floating-point. </param>
            <param name="mask">Optional operation mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.AccumulateSquare(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Adds the input <paramref name="src"/> or its selected region, raised to power 2, to the accumulator sqsum
            </summary>
            <param name="src">Input image, 1- or 3-channel, 8-bit or 32-bit floating point (each channel of multi-channel image is processed independently)</param>
            <param name="dst">Accumulator of the same number of channels as input image, 32-bit or 64-bit floating-point</param>
            <param name="mask">Optional operation mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.AccumulateProduct(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Adds product of 2 images or thier selected regions to accumulator acc
            </summary>
            <param name="src1">First input image, 1- or 3-channel, 8-bit or 32-bit floating point (each channel of multi-channel image is processed independently)</param>
            <param name="src2">Second input image, the same format as the first one</param>
            <param name="dst">Accumulator of the same number of channels as input images, 32-bit or 64-bit floating-point</param>
            <param name="mask">Optional operation mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.AccumulateWeighted(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,System.Double,Emgu.CV.IInputArray)">
            <summary>
            Calculates weighted sum of input <paramref name="src"/> and the accumulator acc so that acc becomes a running average of frame sequence:
            acc(x,y)=(1-<paramref name="alpha"/>) * acc(x,y) + <paramref name="alpha"/> * image(x,y) if mask(x,y)!=0
            where <paramref name="alpha"/> regulates update speed (how fast accumulator forgets about previous frames). 
            </summary>
            <param name="src">Input image, 1- or 3-channel, 8-bit or 32-bit floating point (each channel of multi-channel image is processed independently). </param>
            <param name="dst">Accumulator of the same number of channels as input image, 32-bit or 64-bit floating-point. </param>
            <param name="alpha">Weight of input image</param>
            <param name="mask">Optional operation mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.HuMoments(Emgu.CV.Structure.MCvMoments,Emgu.CV.IOutputArray)">
            <summary>
            Calculates seven Hu invariants
            </summary>
            <param name="moments">Pointer to the moment state structure</param>
            <param name="hu">Pointer to Hu moments structure.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CornerHarris(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Int32,System.Double,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Runs the Harris edge detector on image. Similarly to cvCornerMinEigenVal and cvCornerEigenValsAndVecs, for each pixel it calculates 2x2 gradient covariation matrix M over block_size x block_size neighborhood. Then, it stores
            det(M) - k*trace(M)^2
            to the destination image. Corners in the image can be found as local maxima of the destination image.
            </summary>
            <param name="image">Input image</param>
            <param name="harrisResponse">Image to store the Harris detector responces. Should have the same size as image </param>
            <param name="blockSize">Neighborhood size </param>
            <param name="apertureSize">Aperture parameter for Sobel operator (see cvSobel). format. In the case of floating-point input format this parameter is the number of the fixed float filter used for differencing. </param>
            <param name="k">Harris detector free parameter.</param>
            <param name="borderType">Pixel extrapolation method.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CornerSubPix(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,System.Drawing.Size,System.Drawing.Size,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Iterates to find the sub-pixel accurate location of corners, or radial saddle points
            </summary>
            <param name="image">Input image</param>
            <param name="corners">Initial coordinates of the input corners and refined coordinates on output</param>
            <param name="win">Half sizes of the search window. For example, if win=(5,5) then 5*2+1 x 5*2+1 = 11 x 11 search window is used</param>
            <param name="zeroZone">Half size of the dead region in the middle of the search zone over which the summation in formulae below is not done. It is used sometimes to avoid possible singularities of the autocorrelation matrix. The value of (-1,-1) indicates that there is no such size</param>
            <param name="criteria">Criteria for termination of the iterative process of corner refinement. That is, the process of corner position refinement stops either after certain number of iteration or when a required accuracy is achieved. The criteria may specify either of or both the maximum number of iteration and the required accuracy</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Integral(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Calculates one or more integral images for the source image 
            Using these integral images, one may calculate sum, mean, standard deviation over arbitrary up-right or rotated rectangular region of the image in a constant time.
            It makes possible to do a fast blurring or fast block correlation with variable window size etc. In case of multi-channel images sums for each channel are accumulated independently. 
            </summary>
            <param name="image">The source image, WxH, 8-bit or floating-point (32f or 64f) image.</param>
            <param name="sum">The integral image, W+1xH+1, 32-bit integer or double precision floating-point (64f). </param>
            <param name="sqsum">The integral image for squared pixel values, W+1xH+1, double precision floating-point (64f). </param>
            <param name="tiltedSum">The integral for the image rotated by 45 degrees, W+1xH+1, the same data type as sum.</param>
            <param name="sdepth">Desired depth of the integral and the tilted integral images, CV_32S, CV_32F, or CV_64F.</param>
            <param name="sqdepth">Desired depth of the integral image of squared pixel values, CV_32F or CV_64F.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.DistanceTransform(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DistType,System.Int32,Emgu.CV.CvEnum.DistLabelType)">
            <summary>
            Calculates distance to closest zero pixel for all non-zero pixels of source image
            </summary>
            <param name="src">Source 8-bit single-channel (binary) image.</param>
            <param name="dst">Output image with calculated distances (32-bit floating-point, single-channel). </param>
            <param name="distanceType">Type of distance</param>
            <param name="maskSize">Size of distance transform mask; can be 3 or 5.
            In case of CV_DIST_L1 or CV_DIST_C the parameter is forced to 3, because 3x3 mask gives the same result as 5x5 yet it is faster.</param>
            <param name="labels">The optional output 2d array of labels of integer type and the same size as src and dst. Can be null if not needed</param>
            <param name="labelType">Type of the label array to build. If labelType==CCOMP then each connected component of zeros in src (as well as all the non-zero pixels closest to the connected component) will be assigned the same label. If labelType==PIXEL then each zero pixel (and all the non-zero pixels closest to it) gets its own label.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FloodFill(Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,System.Drawing.Point,Emgu.CV.Structure.MCvScalar,System.Drawing.Rectangle@,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar,Emgu.CV.CvEnum.Connectivity,Emgu.CV.CvEnum.FloodFillType)">
            <summary>
            Fills a connected component with given color.
            </summary>
            <param name="src">Input 1- or 3-channel, 8-bit or floating-point image. It is modified by the function unless CV_FLOODFILL_MASK_ONLY flag is set.</param>
            <param name="seedPoint">The starting point.</param>
            <param name="newVal">New value of repainted domain pixels.</param>
            <param name="loDiff">Maximal lower brightness/color difference
            between the currently observed pixel and one of its neighbor belong to the component
            or seed pixel to add the pixel to component.
            In case of 8-bit color images it is packed value.</param>
            <param name="upDiff">Maximal upper brightness/color difference
            between the currently observed pixel and one of its neighbor belong to the component
            or seed pixel to add the pixel to component.
            In case of 8-bit color images it is packed value.</param>
            <param name="flags">The operation flags.
            Lower bits contain connectivity value, 4 (by default) or 8, used within the function.
            Connectivity determines which neighbors of a pixel are considered.
            Upper bits can be 0 or combination of the following flags:
            CV_FLOODFILL_FIXED_RANGE - if set the difference between the current pixel and seed pixel is considered,
            otherwise difference between neighbor pixels is considered (the range is floating).
            CV_FLOODFILL_MASK_ONLY - if set, the function does not fill the image (new_val is ignored),
            but the fills mask (that must be non-NULL in this case). </param>
            <param name="mask">Operation mask,
            should be singe-channel 8-bit image, 2 pixels wider and 2 pixels taller than image.
            If not IntPtr.Zero, the function uses and updates the mask, so user takes responsibility of initializing mask content.
            Floodfilling can't go across non-zero pixels in the mask, for example, an edge detector output can be used as a mask to stop filling at edges.
            Or it is possible to use the same mask in multiple calls to the function to make sure the filled area do not overlap.
            Note: because mask is larger than the filled image, pixel in mask that corresponds to (x,y) pixel in image will have coordinates (x+1,y+1).</param>
            <param name="rect">Output parameter set by the function to the minimum bounding rectangle of the repainted domain.</param>
            <param name="connectivity">Flood fill connectivity</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PyrMeanShiftFiltering(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,System.Int32,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Filters image using meanshift algorithm
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Result image</param>
            <param name="sp">The spatial window radius.</param>
            <param name="sr">The color window radius.</param>
            <param name="maxLevel">Maximum level of the pyramid for the segmentation. Use 1 as default value</param>
            <param name="termcrit">Termination criteria: when to stop meanshift iterations. Use new MCvTermCriteria(5, 1) as default value</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ConvertMaps(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,System.Int32,System.Boolean)">
            <summary>
            Converts image transformation maps from one representation to another.
            </summary>
            <param name="map1">The first input map of type CV_16SC2 , CV_32FC1 , or CV_32FC2 .</param>
            <param name="map2">The second input map of type CV_16UC1 , CV_32FC1 , or none (empty matrix), respectively.</param>
            <param name="dstmap1">The first output map that has the type dstmap1type and the same size as src .</param>
            <param name="dstmap2">The second output map.</param>
            <param name="dstmap1Depth">Depth type of the first output map that should be CV_16SC2 , CV_32FC1 , or CV_32FC2.</param>
            <param name="dstmap1Channels">The number of channels in the dst map.</param>
            <param name="nninterpolation">Flag indicating whether the fixed-point maps are used for the nearest-neighbor or for a more complex interpolation.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Undistort(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Transforms the image to compensate radial and tangential lens distortion. 
            </summary>
            <param name="src">The input (distorted) image</param>
            <param name="dst">The output (corrected) image</param>
            <param name="cameraMatrix">The camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1].</param>
            <param name="distortionCoeffs">The vector of distortion coefficients, 4x1 or 1x4 [k1, k2, p1, p2].</param>
            <param name="newCameraMatrix">Camera matrix of the distorted image. By default it is the same as cameraMatrix, but you may additionally scale and shift the result by using some different matrix</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.InitUndistortRectifyMap(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.CvEnum.DepthType,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray)">
            <summary>
            This function is an extended version of cvInitUndistortMap. That is, in addition to the correction of lens distortion, the function can also apply arbitrary perspective transformation R and finally it can scale and shift the image according to the new camera matrix
            </summary>
            <param name="cameraMatrix">The camera matrix A=[fx 0 cx; 0 fy cy; 0 0 1]</param>
            <param name="distCoeffs">The vector of distortion coefficients, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="R">The rectification transformation in object space (3x3 matrix). R1 or R2, computed by cvStereoRectify can be passed here. If the parameter is IntPtr.Zero, the identity matrix is used</param>
            <param name="newCameraMatrix">The new camera matrix A'=[fx' 0 cx'; 0 fy' cy'; 0 0 1]</param>
            <param name="depthType">Depth type of the first output map that can be CV_32FC1 or CV_16SC2 .</param>
            <param name="map1">The first output map.</param>
            <param name="map2">The second output map.</param>
            <param name="size">Undistorted image size.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.UndistortPoints(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Similar to cvInitUndistortRectifyMap and is opposite to it at the same time. 
            The functions are similar in that they both are used to correct lens distortion and to perform the optional perspective (rectification) transformation. 
            They are opposite because the function cvInitUndistortRectifyMap does actually perform the reverse transformation in order to initialize the maps properly, while this function does the forward transformation. 
            </summary>
            <param name="src">The observed point coordinates</param>
            <param name="dst">The ideal point coordinates, after undistortion and reverse perspective transformation. </param>
            <param name="cameraMatrix">The camera matrix A=[fx 0 cx; 0 fy cy; 0 0 1]</param>
            <param name="distCoeffs">The vector of distortion coefficients, 4x1, 1x4, 5x1 or 1x5. </param>
            <param name="R">The rectification transformation in object space (3x3 matrix). R1 or R2, computed by cvStereoRectify can be passed here. If the parameter is IntPtr.Zero, the identity matrix is used.</param>
            <param name="P">The new camera matrix (3x3) or the new projection matrix (3x4). P1 or P2, computed by cvStereoRectify can be passed here. If the parameter is IntPtr.Zero, the identity matrix is used.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.EMD(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.DistType,Emgu.CV.IInputArray,System.Single[],Emgu.CV.IOutputArray)">
            <summary>
            Computes the 'minimal work' distance between two weighted point configurations.
            </summary>
            <param name="signature1">First signature, a size1 x dims + 1  floating-point matrix. Each row stores the point weight followed by the point coordinates. The matrix is allowed to have a single column (weights only) if the user-defined cost matrix is used.</param>
            <param name="signature2">Second signature of the same format as signature1 , though the number of rows may be different. The total weights may be different. In this case an extra 'dummy' point is added to either signature1 or signature2</param>
            <param name="distType"> Used metric. CV_DIST_L1, CV_DIST_L2 , and CV_DIST_C stand for one of the standard metrics. CV_DIST_USER means that a pre-calculated cost matrix cost is used.</param>
            <param name="cost">User-defined size1 x size2 cost matrix. Also, if a cost matrix is used, lower boundary lowerBound cannot be calculated because it needs a metric function.</param>
            <param name="lowerBound">Optional input/output parameter: lower boundary of a distance between the two signatures that is a distance between mass centers. The lower boundary may not be calculated if the user-defined cost matrix is used, the total weights of point configurations are not equal, or if the signatures consist of weights only (the signature matrices have a single column). </param>
            <param name="flow"> Resultant size1 x size2 flow matrix</param>
            <returns>The 'minimal work' distance between two weighted point configurations.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PhaseCorrelate(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Double@)">
            <summary>
            The function is used to detect translational shifts that occur between two images. The operation takes advantage of the Fourier shift theorem for detecting the translational shift in the frequency domain. It can be used for fast image registration as well as motion estimation. 
            </summary>
            <param name="src1">Source floating point array (CV_32FC1 or CV_64FC1)</param>
            <param name="src2">Source floating point array (CV_32FC1 or CV_64FC1)</param>
            <param name="window">Floating point array with windowing coefficients to reduce edge effects (optional).</param>
            <param name="response">Signal power within the 5x5 centroid around the peak, between 0 and 1 </param>
            <returns>The translational shifts that occur between two images</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CreateHanningWindow(Emgu.CV.IOutputArray,System.Drawing.Size,Emgu.CV.CvEnum.DepthType)">
            <summary>
            This function computes a Hanning window coefficients in two dimensions.
            </summary>
            <param name="dst">Destination array to place Hann coefficients in</param>
            <param name="winSize">The window size specifications</param>
            <param name="type">Created array type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Line(Emgu.CV.IInputOutputArray,System.Drawing.Point,System.Drawing.Point,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draws the line segment between pt1 and pt2 points in the image. The line is clipped by the image or ROI rectangle. For non-antialiased lines with integer coordinates the 8-connected or 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased lines are drawn using Gaussian filtering.
            </summary>
            <param name="img">The image</param>
            <param name="pt1">First point of the line segment</param>
            <param name="pt2">Second point of the line segment</param>
            <param name="color">Line color</param>
            <param name="thickness">Line thickness. </param>
            <param name="lineType">Type of the line:
            8 (or 0) - 8-connected line.
            4 - 4-connected line.
            CV_AA - antialiased line. 
            </param>
            <param name="shift">Number of fractional bits in the point coordinates</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ArrowedLine(Emgu.CV.IInputOutputArray,System.Drawing.Point,System.Drawing.Point,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32,System.Double)">
            <summary>
            Draws a arrow segment pointing from the first point to the second one.
            </summary>
            <param name="img">Image</param>
            <param name="pt1">The point the arrow starts from.</param>
            <param name="pt2">The point the arrow points to.</param>
            <param name="color">Line color.</param>
            <param name="thickness">Line thickness.</param>
            <param name="lineType">Type of the line.</param>
            <param name="shift">Number of fractional bits in the point coordinates.</param>
            <param name="tipLength">The length of the arrow tip in relation to the arrow length</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Polylines(Emgu.CV.IInputOutputArray,System.Drawing.Point[],System.Boolean,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draws a single or multiple polygonal curves
            </summary>
            <param name="img">Image</param>
            <param name="pts">Array points</param>
            <param name="isClosed">
            Indicates whether the polylines must be drawn closed. 
            If !=0, the function draws the line from the last vertex of every contour to the first vertex.
            </param>
            <param name="color">Polyline color</param>
            <param name="thickness">Thickness of the polyline edges</param>
            <param name="lineType">Type of the line segments, see cvLine description</param>
            <param name="shift">Number of fractional bits in the vertex coordinates</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Polylines(Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray,System.Boolean,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draws a single or multiple polygonal curves
            </summary>
            <param name="img">Image</param>
            <param name="pts">Array of pointers to polylines</param>
            <param name="isClosed">
            Indicates whether the polylines must be drawn closed. 
            If !=0, the function draws the line from the last vertex of every contour to the first vertex.
            </param>
            <param name="color">Polyline color</param>
            <param name="thickness">Thickness of the polyline edges</param>
            <param name="lineType">Type of the line segments, see cvLine description</param>
            <param name="shift">Number of fractional bits in the vertex coordinates</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Rectangle(Emgu.CV.IInputOutputArray,System.Drawing.Rectangle,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draws a rectangle specified by a CvRect structure
            </summary>
            /// <param name="img">Image</param>
            <param name="rect">The rectangle to be drawn</param>
            <param name="color">Line color </param>
            <param name="thickness">Thickness of lines that make up the rectangle. Negative values make the function to draw a filled rectangle.</param>
            <param name="lineType">Type of the line</param>
            <param name="shift">Number of fractional bits in the point coordinates</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ConnectedComponents(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.LineType,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Computes the connected components labeled image of boolean image
            </summary>
            <param name="image">The boolean image</param>
            <param name="labels">The connected components labeled image of boolean image</param>
            <param name="connectivity">4 or 8 way connectivity</param>
            <param name="labelType">Specifies the output label image type, an important consideration based on the total number of labels or alternatively the total number of pixels in the source image</param>
            <returns>N, the total number of labels [0, N-1] where 0 represents the background label.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ConnectedComponentsWithStats(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.LineType,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Computes the connected components labeled image of boolean image
            </summary>
            <param name="image">The boolean image</param>
            <param name="labels">The connected components labeled image of boolean image</param>
            <param name="stats">Statistics output for each label, including the background label, see below for available statistics. Statistics are accessed via stats(label, COLUMN) where COLUMN is one of cv::ConnectedComponentsTypes. The data type is CV_32S</param>
            <param name="centroids">Centroid output for each label, including the background label. Centroids are accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F.</param>
            <param name="connectivity">4 or 8 way connectivity</param>
            <param name="labelType">Specifies the output label image type, an important consideration based on the total number of labels or alternatively the total number of pixels in the source image</param>
            <returns>N, the total number of labels [0, N-1] where 0 represents the background label.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GroupRectangles(Emgu.CV.Util.VectorOfRect,System.Int32,System.Double)">
            <summary>
            Groups the object candidate rectangles.
            </summary>
            <param name="rectList">Input/output vector of rectangles. Output vector includes retained and grouped rectangles.</param>
            <param name="groupThreshold">Minimum possible number of rectangles minus 1. The threshold is used in a group of rectangles to retain it.</param>
            <param name="eps">Relative difference between sides of the rectangles to merge them into a group.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GroupRectangles(Emgu.CV.Util.VectorOfRect,Emgu.CV.Util.VectorOfInt,System.Int32,System.Double)">
            <summary>
            Groups the object candidate rectangles.
            </summary>
            <param name="rectList">Input/output vector of rectangles. Output vector includes retained and grouped rectangles.</param>
            <param name="weights"></param>
            <param name="groupThreshold">Minimum possible number of rectangles minus 1. The threshold is used in a group of rectangles to retain it.</param>
            <param name="eps">Relative difference between sides of the rectangles to merge them into a group.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GroupRectangles(Emgu.CV.Util.VectorOfRect,System.Int32,System.Double,Emgu.CV.Util.VectorOfInt,Emgu.CV.Util.VectorOfDouble)">
            <summary>
            Groups the object candidate rectangles.
            </summary>
            <param name="rectList">Input/output vector of rectangles. Output vector includes retained and grouped rectangles.</param>
            <param name="groupThreshold">Minimum possible number of rectangles minus 1. The threshold is used in a group of rectangles to retain it.</param>
            <param name="eps">Relative difference between sides of the rectangles to merge them into a group.</param>
            <param name="weights">weights</param>
            <param name="levelWeights">level weights</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GroupRectangles(Emgu.CV.Util.VectorOfRect,Emgu.CV.Util.VectorOfInt,Emgu.CV.Util.VectorOfDouble,System.Int32,System.Double)">
            <summary>
            Groups the object candidate rectangles.
            </summary>
            <param name="rectList">Input/output vector of rectangles. Output vector includes retained and grouped rectangles.</param>
            <param name="rejectLevels">reject levels</param>
            <param name="levelWeights">level weights</param>
            <param name="groupThreshold">Minimum possible number of rectangles minus 1. The threshold is used in a group of rectangles to retain it.</param>
            <param name="eps">Relative difference between sides of the rectangles to merge them into a group.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.GroupRectanglesMeanshift(Emgu.CV.Util.VectorOfRect,Emgu.CV.Util.VectorOfDouble,Emgu.CV.Util.VectorOfDouble,System.Double,System.Drawing.Size)">
            <summary>
            Groups the object candidate rectangles.
            </summary>
            <param name="rectList">Input/output vector of rectangles. Output vector includes retained and grouped rectangles.</param>
            <param name="foundWeights">found weights</param>
            <param name="foundScales">found scales</param>
            <param name="detectThreshold">detect threshold, use 0 for default</param>
            <param name="winDetSize">win det size, use (64, 128) for default</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SolveLP(Emgu.CV.Mat,Emgu.CV.Mat,Emgu.CV.Mat)">
            <summary>
            Solve given (non-integer) linear programming problem using the Simplex Algorithm (Simplex Method). 
            What we mean here by linear programming problem (or LP problem, for short) can be formulated as:
            Maximize c x subject to: Ax &lt;= b and x &gt;= 0 
            </summary>
            <param name="functionMatrix">This row-vector corresponds to c in the LP problem formulation (see above). It should contain 32- or 64-bit floating point numbers. As a convenience, column-vector may be also submitted, in the latter case it is understood to correspond to c^T.</param>
            <param name="constraintMatrix">m-by-n+1 matrix, whose rightmost column corresponds to b in formulation above and the remaining to A. It should containt 32- or 64-bit floating point numbers.</param>
            <param name="zMatrix">The solution will be returned here as a column-vector - it corresponds to c in the formulation above. It will contain 64-bit floating point numbers.</param>
            <returns>The return codes</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.DenoiseTVL1(Emgu.CV.Mat[],Emgu.CV.Mat,System.Double,System.Int32)">
            <summary>
            Primal-dual algorithm is an algorithm for solving special types of variational problems (that is, finding a function to minimize some functional).
            As the image denoising, in particular, may be seen as the variational problem, primal-dual algorithm then can be used to perform 
            denoising and this is exactly what is implemented.
            </summary>
            <param name="observations">This array should contain one or more noised versions of the image that is to be restored.</param>
            <param name="result">Here the denoised image will be stored. There is no need to do pre-allocation of storage space, as it will be automatically allocated, if necessary.</param>
            <param name="lambda">Corresponds to  in the formulas above. As it is enlarged, the smooth (blurred) images are treated more favorably than detailed (but maybe more noised) ones. Roughly speaking, as it becomes smaller, the result will be more blur but more sever outliers will be removed.</param>
            <param name="niters">Number of iterations that the algorithm will run. Of course, as more iterations as better, but it is hard to quantitatively refine this statement, so just use the default and increase it if the results are poor.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Inpaint(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,Emgu.CV.CvEnum.InpaintType)">
            <summary>
            Reconstructs the selected image area from the pixel near the area boundary. The function may be used to remove dust and scratches from a scanned photo, or to remove undesirable objects from still images or video.
            </summary>
            <param name="src">The input 8-bit 1-channel or 3-channel image</param>
            <param name="mask">The inpainting mask, 8-bit 1-channel image. Non-zero pixels indicate the area that needs to be inpainted</param>
            <param name="dst">The output image of the same format and the same size as input</param>
            <param name="flags">The inpainting method</param>
            <param name="inpaintRadius">The radius of circular neighborhood of each point inpainted that is considered by the algorithm</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FastNlMeansDenoising(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single,System.Int32,System.Int32)">
            <summary>
            Perform image denoising using Non-local Means Denoising algorithm: 
            http://www.ipol.im/pub/algo/bcm_non_local_means_denoising/ 
            with several computational optimizations. Noise expected to be a Gaussian white noise.
            </summary>
            <param name="src">Input 8-bit 1-channel, 2-channel or 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="h">Parameter regulating filter strength. Big h value perfectly removes noise but also removes image details, smaller h value preserves details but also preserves some noise.</param>
            <param name="templateWindowSize">Size in pixels of the template patch that is used to compute weights. Should be odd.</param>
            <param name="searchWindowSize">Size in pixels of the window that is used to compute weighted average for given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.FastNlMeansDenoisingColored(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Perform image denoising using Non-local Means Denoising algorithm (modified for color image): 
            http://www.ipol.im/pub/algo/bcm_non_local_means_denoising/ 
            with several computational optimizations. Noise expected to be a Gaussian white noise.
            The function converts image to CIELAB colorspace and then separately denoise L and AB components with given h parameters using fastNlMeansDenoising function.
            </summary>
            <param name="src">Input 8-bit 1-channel, 2-channel or 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="h">Parameter regulating filter strength. Big h value perfectly removes noise but also removes image details, smaller h value preserves details but also preserves some noise.</param>
            <param name="hColor">The same as h but for color components. For most images value equals 10 will be enought to remove colored noise and do not distort colors.</param>
            <param name="templateWindowSize">Size in pixels of the template patch that is used to compute weights. Should be odd.</param>
            <param name="searchWindowSize">Size in pixels of the window that is used to compute weighted average for given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater denoising time.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.EdgePreservingFilter(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.EdgePreservingFilterFlag,System.Single,System.Single)">
            <summary>
            Filtering is the fundamental operation in image and video processing. Edge-preserving smoothing filters are used in many different applications.
            </summary>
            <param name="src">Input 8-bit 3-channel image</param>
            <param name="dst">Output 8-bit 3-channel image</param>
            <param name="flags">Edge preserving filters</param>
            <param name="sigmaS">Range between 0 to 200</param>
            <param name="sigmaR">Range between 0 to 1</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.DetailEnhance(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single,System.Single)">
            <summary>
            This filter enhances the details of a particular image.
            </summary>
            <param name="src">Input 8-bit 3-channel image</param>
            <param name="dst">Output image with the same size and type as src</param>
            <param name="sigmaS">Range between 0 to 200</param>
            <param name="sigmaR">Range between 0 to 1</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.PencilSketch(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Single,System.Single,System.Single)">
            <summary>
            Pencil-like non-photorealistic line drawing
            </summary>
            <param name="src">Input 8-bit 3-channel image</param>
            <param name="dst1">Output 8-bit 1-channel image</param>
            <param name="dst2">Output image with the same size and type as src</param>
            <param name="sigmaS">Range between 0 to 200</param>
            <param name="sigmaR">Range between 0 to 1</param>
            <param name="shadeFactor">Range between 0 to 0.1</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Stylization(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single,System.Single)">
            <summary>
            Stylization aims to produce digital imagery with a wide variety of effects not focused on photorealism. Edge-aware filters are ideal for stylization, as they can abstract regions of low contrast while preserving, or enhancing, high-contrast features.
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="sigmaS">Range between 0 to 200.</param>
            <param name="sigmaR"> Range between 0 to 1.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ColorChange(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single,System.Single,System.Single)">
            <summary>
            Given an original color image, two differently colored versions of this image can be mixed seamlessly.
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="mask">Input 8-bit 1 or 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src .</param>
            <param name="redMul">R-channel multiply factor. Multiplication factor is between .5 to 2.5.</param>
            <param name="greenMul">G-channel multiply factor. Multiplication factor is between .5 to 2.5.</param>
            <param name="blueMul">B-channel multiply factor. Multiplication factor is between .5 to 2.5.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.IlluminationChange(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single,System.Single)">
            <summary>
            Applying an appropriate non-linear transformation to the gradient field inside the selection and then integrating back with a Poisson solver, modifies locally the apparent illumination of an image.
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="mask">Input 8-bit 1 or 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="alpha">Value ranges between 0-2.</param>
            <param name="beta">Value ranges between 0-2.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.TextureFlattening(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single,System.Single,System.Int32)">
            <summary>
            By retaining only the gradients at edge locations, before integrating with the Poisson solver, one washes out the texture of the selected region, giving its contents a flat aspect. Here Canny Edge Detector is used.
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="mask">Input 8-bit 1 or 3-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="lowThreshold">Range from 0 to 100.</param>
            <param name="highThreshold">Value &gt; 100</param>
            <param name="kernelSize">The size of the Sobel kernel to be used.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.Decolor(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray)">
            <summary>
            Transforms a color image to a grayscale image. It is a basic tool in digital printing, stylized black-and-white photograph rendering, and in many single channel image processing applications 
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="grayscale">Output 8-bit 1-channel image.</param>
            <param name="colorBoost">Output 8-bit 3-channel image.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SeamlessClone(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.Point,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.CloningMethod)">
            <summary>
            Image editing tasks concern either global changes (color/intensity corrections, filters, deformations) or local changes concerned to a selection. Here we are interested in achieving local changes, ones that are restricted to a region manually selected (ROI), in a seamless and effortless manner. The extent of the changes ranges from slight distortions to complete replacement by novel content 
            </summary>
            <param name="src">Input 8-bit 3-channel image.</param>
            <param name="dst">Input 8-bit 3-channel image.</param>
            <param name="mask">Input 8-bit 1 or 3-channel image.</param>
            <param name="p">Point in dst image where object is placed.</param>
            <param name="blend">Output image with the same size and type as dst.</param>
            <param name="flags">Cloning method</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CamShift(Emgu.CV.IInputArray,System.Drawing.Rectangle@,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Implements CAMSHIFT object tracking algorithm ([Bradski98]). First, it finds an object center using cvMeanShift and, after that, calculates the object size and orientation. 
            </summary>
            <param name="probImage">Back projection of object histogram </param>
            <param name="window">Initial search window</param>
            <param name="criteria">Criteria applied to determine when the window search should be finished</param>
            <returns>Circumscribed box for the object, contains object size and orientation</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.MeanShift(Emgu.CV.IInputArray,System.Drawing.Rectangle@,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Iterates to find the object center given its back projection and initial position of search window. The iterations are made until the search window center moves by less than the given value and/or until the function has done the maximum number of iterations. 
            </summary>
            <param name="probImage">Back projection of object histogram</param>
            <param name="window">Initial search window</param>
            <param name="criteria">Criteria applied to determine when the window search should be finished. </param>
            <returns>The number of iterations made</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.UpdateMotionHistory(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,System.Double,System.Double)">
            <summary>
            Updates the motion history image as following:
            mhi(x,y)=timestamp  if silhouette(x,y)!=0
                    0          if silhouette(x,y)=0 and mhi(x,y)&lt;timestamp-duration
                    mhi(x,y)   otherwise
            That is, MHI pixels where motion occurs are set to the current timestamp, while the pixels where motion happened far ago are cleared. 
            </summary>
            <param name="silhouette">Silhouette mask that has non-zero pixels where the motion occurs. </param>
            <param name="mhi">Motion history image, that is updated by the function (single-channel, 32-bit floating-point) </param>
            <param name="timestamp">Current time in milliseconds or other units. </param>
            <param name="duration">Maximal duration of motion track in the same units as timestamp. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcMotionGradient(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Double,System.Double,System.Int32)">
             <summary>
             Calculates the derivatives Dx and Dy of mhi and then calculates gradient orientation as:
            orientation(x,y)=arctan(Dy(x,y)/Dx(x,y))
            where both Dx(x,y)' and Dy(x,y)' signs are taken into account (as in cvCartToPolar function). After that mask is filled to indicate where the orientation is valid (see delta1 and delta2 description). 
             </summary>
             <param name="mhi">Motion history image</param>
             <param name="mask">Mask image; marks pixels where motion gradient data is correct. Output parameter.</param>
             <param name="orientation">Motion gradient orientation image; contains angles from 0 to ~360. </param>
             <param name="delta1">The function finds minimum (m(x,y)) and maximum (M(x,y)) mhi values over each pixel (x,y) neihborhood and assumes the gradient is valid only if min(delta1,delta2) &lt;= M(x,y)-m(x,y) &lt;= max(delta1,delta2). </param>
             <param name="delta2">The function finds minimum (m(x,y)) and maximum (M(x,y)) mhi values over each pixel (x,y) neihborhood and assumes the gradient is valid only if min(delta1,delta2) &lt;= M(x,y)-m(x,y) &lt;= max(delta1,delta2).</param>
             <param name="apertureSize">Aperture size of derivative operators used by the function: CV_SCHARR, 1, 3, 5 or 7 (see cvSobel). </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.SegmentMotion(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Util.VectorOfRect,System.Double,System.Double)">
            <summary>
            Finds all the motion segments and marks them in segMask with individual values each (1,2,...). It also returns a sequence of CvConnectedComp structures, one per each motion components. After than the motion direction for every component can be calculated with cvCalcGlobalOrientation using extracted mask of the particular component (using cvCmp) 
            </summary>
            <param name="mhi">Motion history image</param>
            <param name="segMask">Image where the mask found should be stored, single-channel, 32-bit floating-point</param>
            <param name="timestamp">Current time in milliseconds or other units</param>
            <param name="segThresh">Segmentation threshold; recommended to be equal to the interval between motion history "steps" or greater</param>
            <param name="boundingRects">Vector containing ROIs of motion connected components.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcGlobalOrientation(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Double,System.Double)">
            <summary>
            Calculates the general motion direction in the selected region and returns the angle between 0 and 360. At first the function builds the orientation histogram and finds the basic orientation as a coordinate of the histogram maximum. After that the function calculates the shift relative to the basic orientation as a weighted sum of all orientation vectors: the more recent is the motion, the greater is the weight. The resultant angle is a circular sum of the basic orientation and the shift. 
            </summary>
            <param name="orientation">Motion gradient orientation image; calculated by the function cvCalcMotionGradient.</param>
            <param name="mask">Mask image. It may be a conjunction of valid gradient mask, obtained with cvCalcMotionGradient and mask of the region, whose direction needs to be calculated. </param>
            <param name="mhi">Motion history image.</param>
            <param name="timestamp">Current time in milliseconds or other units, it is better to store time passed to cvUpdateMotionHistory before and reuse it here, because running cvUpdateMotionHistory and cvCalcMotionGradient on large images may take some time.</param>
            <param name="duration">Maximal duration of motion track in milliseconds, the same as in cvUpdateMotionHistory</param>
            <returns>The angle</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcOpticalFlowPyrLK(Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.PointF[],System.Drawing.Size,System.Int32,Emgu.CV.Structure.MCvTermCriteria,System.Drawing.PointF[]@,System.Byte[]@,System.Single[]@,Emgu.CV.CvEnum.LKFlowFlag,System.Double)">
            <summary>
            Calculates optical flow for a sparse feature set using iterative Lucas-Kanade method in pyramids
            </summary>
            <param name="prev">First frame, at time t</param>
            <param name="curr">Second frame, at time t + dt </param>
            <param name="prevFeatures">Array of points for which the flow needs to be found</param>
            <param name="winSize">Size of the search window of each pyramid level</param>
            <param name="level">Maximal pyramid level number. If 0 , pyramids are not used (single level), if 1 , two levels are used, etc</param>
            <param name="criteria">Specifies when the iteration process of finding the flow for each point on each pyramid level should be stopped</param>
            <param name="flags">Flags</param>
            <param name="currFeatures">Array of 2D points containing calculated new positions of input features in the second image</param>
            <param name="status">Array. Every element of the array is set to 1 if the flow for the corresponding feature has been found, 0 otherwise</param>
            <param name="trackError">Array of double numbers containing difference between patches around the original and moved points</param>
            <param name="minEigThreshold">the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in [Bouguet00]), divided by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcOpticalFlowPyrLK(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Drawing.Size,System.Int32,Emgu.CV.Structure.MCvTermCriteria,Emgu.CV.CvEnum.LKFlowFlag,System.Double)">
            <summary>
            Implements sparse iterative version of Lucas-Kanade optical flow in pyramids ([Bouguet00]). It calculates coordinates of the feature points on the current video frame given their coordinates on the previous frame. The function finds the coordinates with sub-pixel accuracy. 
            </summary>
            <remarks>Both parameters prev_pyr and curr_pyr comply with the following rules: if the image pointer is 0, the function allocates the buffer internally, calculates the pyramid, and releases the buffer after processing. Otherwise, the function calculates the pyramid and stores it in the buffer unless the flag CV_LKFLOW_PYR_A[B]_READY is set. The image should be large enough to fit the Gaussian pyramid data. After the function call both pyramids are calculated and the readiness flag for the corresponding image can be set in the next call (i.e., typically, for all the image pairs except the very first one CV_LKFLOW_PYR_A_READY is set). </remarks>
            <param name="prevImg">First frame, at time t. </param>
            <param name="nextImg">Second frame, at time t + dt .</param>
            <param name="prevPts">Array of points for which the flow needs to be found. </param>
            <param name="nextPts">Array of 2D points containing calculated new positions of input </param>
            <param name="winSize">Size of the search window of each pyramid level.</param>
            <param name="maxLevel">Maximal pyramid level number. If 0 , pyramids are not used (single level), if 1 , two levels are used, etc. </param>
            <param name="status">Array. Every element of the array is set to 1 if the flow for the corresponding feature has been found, 0 otherwise.</param>
            <param name="err">Array of double numbers containing difference between patches around the original and moved points. Optional parameter; can be NULL </param>
            <param name="criteria">Specifies when the iteration process of finding the flow for each point on each pyramid level should be stopped.</param>
            <param name="flags">Miscellaneous flags</param>
            <param name="minEigThreshold">the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in [Bouguet00]), divided by number of pixels in a window; if this value is less than minEigThreshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcOpticalFlowFarneback(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Single},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Single},System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,Emgu.CV.CvEnum.OpticalflowFarnebackFlag)">
            <summary>
            Computes dense optical flow using Gunnar Farneback's algorithm
            </summary>
            <param name="prev0">The first 8-bit single-channel input image</param>
            <param name="next0">The second input image of the same size and the same type as prevImg</param>
            <param name="flowX">The computed flow image for x-velocity; will have the same size as prevImg</param>
            <param name="flowY">The computed flow image for y-velocity; will have the same size as prevImg</param>
            <param name="pyrScale">Specifies the image scale (!1) to build the pyramids for each image. pyrScale=0.5 means the classical pyramid, where each next layer is twice smaller than the previous</param>
            <param name="levels">The number of pyramid layers, including the initial image. levels=1 means that no extra layers are created and only the original images are used</param>
            <param name="winSize">The averaging window size; The larger values increase the algorithm robustness to image noise and give more chances for fast motion detection, but yield more blurred motion field</param>
            <param name="iterations">The number of iterations the algorithm does at each pyramid level</param>
            <param name="polyN">Size of the pixel neighborhood used to find polynomial expansion in each pixel. The larger values mean that the image will be approximated with smoother surfaces, yielding more robust algorithm and more blurred motion field. Typically, poly n=5 or 7</param>
            <param name="polySigma">Standard deviation of the Gaussian that is used to smooth derivatives that are used as a basis for the polynomial expansion. For poly n=5 you can set poly sigma=1.1, for poly n=7 a good value would be poly sigma=1.5</param>
            <param name="flags">The operation flags</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CalcOpticalFlowFarneback(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,Emgu.CV.CvEnum.OpticalflowFarnebackFlag)">
            <summary>
            Computes dense optical flow using Gunnar Farneback's algorithm
            </summary>
            <param name="prev0">The first 8-bit single-channel input image</param>
            <param name="next0">The second input image of the same size and the same type as prevImg</param>
            <param name="flow">The computed flow image; will have the same size as prevImg and type CV 32FC2</param>
            <param name="pyrScale">Specifies the image scale (!1) to build the pyramids for each image. pyrScale=0.5 means the classical pyramid, where each next layer is twice smaller than the previous</param>
            <param name="levels">The number of pyramid layers, including the initial image. levels=1 means that no extra layers are created and only the original images are used</param>
            <param name="winSize">The averaging window size; The larger values increase the algorithm robustness to image noise and give more chances for fast motion detection, but yield more blurred motion field</param>
            <param name="iterations">The number of iterations the algorithm does at each pyramid level</param>
            <param name="polyN">Size of the pixel neighborhood used to find polynomial expansion in each pixel. The larger values mean that the image will be approximated with smoother surfaces, yielding more robust algorithm and more blurred motion field. Typically, poly n=5 or 7</param>
            <param name="polySigma">Standard deviation of the Gaussian that is used to smooth derivatives that are used as a basis for the polynomial expansion. For poly n=5 you can set poly sigma=1.1, for poly n=7 a good value would be poly sigma=1.5</param>
            <param name="flags">The operation flags</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.EstimateRigidTransform(System.Drawing.PointF[],System.Drawing.PointF[],System.Boolean)">
            <summary>
            Estimate rigid transformation between 2 point sets.
            </summary>
            <param name="sourcePoints">The points from the source image</param>
            <param name="destinationPoints">The corresponding points from the destination image</param>
            <param name="fullAffine">Indicates if full affine should be performed</param>
            <returns>If success, the 2x3 rotation matrix that defines the Affine transform. Otherwise null is returned.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.EstimateRigidTransform(Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Boolean)">
            <summary>
            Estimate rigid transformation between 2 images or 2 point sets.
            </summary>
            <param name="src">First image or 2D point set (as a 2 channel Matrix&lt;float&gt;)</param>
            <param name="dst">First image or 2D point set (as a 2 channel Matrix&lt;float&gt;)</param>
            <param name="fullAffine">Indicates if full affine should be performed</param>
            <returns>The resulting Matrix&lt;double&gt; that represent the affine transformation</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveInputArrayRelease(System.IntPtr@)">
            <summary>
            Release the InputArray
            </summary>
            <param name="arr">Pointer to the input array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveInputOutputArrayRelease(System.IntPtr@)">
            <summary>
            Release the input / output array
            </summary>
            <param name="arr">Pointer to the input output array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveOutputArrayRelease(System.IntPtr@)">
            <summary>
            Release the input / output array
            </summary>
            <param name="arr">Pointer to the input / output array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveVideoWriterCreate(System.IntPtr,System.Int32,System.Double,System.Drawing.Size@,System.Boolean)">
            <summary>
            Creates video writer structure.
            </summary>
            <param name="filename">Name of the output video file.</param>
            <param name="fourcc">4-character code of codec used to compress the frames. For example, CV_FOURCC('P','I','M','1') is MPEG-1 codec, CV_FOURCC('M','J','P','G') is motion-jpeg codec etc.</param>
            <param name="fps">Framerate of the created video stream. </param>
            <param name="frameSize">Size of video frames.</param>
            <param name="isColor">If != 0, the encoder will expect and encode color frames, otherwise it will work with grayscale frames </param>
            <returns>The video writer</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveVideoWriterRelease(System.IntPtr@)">
            <summary>
            Finishes writing to video file and releases the structure.
            </summary>
            <param name="writer">pointer to video file writer structure</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cveVideoWriterWrite(System.IntPtr,System.IntPtr)">
            <summary>
            Writes/appends one frame to video file.
            </summary>
            <param name="writer">video writer structure.</param>
            <param name="image">the written frame</param>
            <returns>True on success, false otherwise</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.ReadCloud(System.String,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray)">
            <summary>
            Read point cloud from file
            </summary>
            <param name="file">The point cloud file</param>
            <param name="colors">The color of the points</param>
            <param name="normals">The normal of the points</param>
            <returns>The points</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.WriteCloud(System.String,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Write point cloud to file
            </summary>
            <param name="file">The point cloud file name</param>
            <param name="cloud">The point cloud</param>
            <param name="colors">The color</param>
            <param name="normals">The normals</param>
        </member>
        <member name="P:Emgu.CV.CvInvoke.UseOptimized">
            <summary>
            Enables or disables the optimized code.
            </summary>
            <value>
              <c>true</c> if [use optimized]; otherwise, <c>false</c>.
            </value>
            <remarks>The function can be used to dynamically turn on and off optimized code (code that uses SSE2, AVX, and other instructions on the platforms that support it). It sets a global flag that is further checked by OpenCV functions. Since the flag is not checked in the inner OpenCV loops, it is only safe to call the function on the very top level in your application where you can be sure that no other OpenCV function is currently executed.</remarks>
        </member>
        <member name="P:Emgu.CV.CvInvoke.HaveOpenCL">
            <summary>
            Check if we have OpenCL
            </summary>
        </member>
        <member name="P:Emgu.CV.CvInvoke.UseOpenCL">
            <summary>
            Get or set if OpenCL should be used
            </summary>
        </member>
        <member name="P:Emgu.CV.CvInvoke.HaveOpenCLCompatibleGpuDevice">
            <summary>
            Gets a value indicating whether this device have open CL compatible gpu device.
            </summary>
            <value><c>true</c> if have open CL compatible gpu device; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Emgu.CV.CvInvoke.CvErrorCallback">
            <summary>
            Define an error callback that can be registered using cvRedirectError function
            </summary>
            <param name="status">The numeric code for error status</param>
            <param name="funcName">The source file name where error is encountered</param>
            <param name="errMsg">A description of the error</param>
            <param name="fileName">The source file name where error is encountered</param>
            <param name="line">The line number in the source where error is encountered</param>
            <param name="userData">Arbitrary pointer that is transparently passed to the error handler.</param>
            <returns></returns>
        </member>
        <member name="T:Emgu.CV.CameraCalibration">
            <summary>
            Camera calibration functions
            </summary>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.CalibrateCamera(Emgu.CV.Structure.MCvPoint3D32f[][],System.Drawing.PointF[][],System.Drawing.Size,Emgu.CV.IntrinsicCameraParameters,Emgu.CV.CvEnum.CalibType,Emgu.CV.Structure.MCvTermCriteria,Emgu.CV.ExtrinsicCameraParameters[]@)">
            <summary>
            Estimates intrinsic camera parameters and extrinsic parameters for each of the views
            </summary>
            <param name="objectPoints">The 3D location of the object points. The first index is the index of image, second index is the index of the point</param>
            <param name="imagePoints">The 2D image location of the points. The first index is the index of the image, second index is the index of the point</param>
            <param name="imageSize">The size of the image, used only to initialize intrinsic camera matrix</param>
            <param name="intrinsicParam">The intrisinc parameters, might contains some initial values. The values will be modified by this function.</param>
            <param name="calibrationType">cCalibration type</param>
            <param name="termCriteria">The termination criteria</param>
            <param name="extrinsicParams">The output array of extrinsic parameters.</param>
            <returns>The final reprojection error</returns>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.StereoCalibrate(Emgu.CV.Structure.MCvPoint3D32f[][],System.Drawing.PointF[][],System.Drawing.PointF[][],Emgu.CV.IntrinsicCameraParameters,Emgu.CV.IntrinsicCameraParameters,System.Drawing.Size,Emgu.CV.CvEnum.CalibType,Emgu.CV.Structure.MCvTermCriteria,Emgu.CV.ExtrinsicCameraParameters@,Emgu.CV.Matrix{System.Double}@,Emgu.CV.Matrix{System.Double}@)">
            <summary>
            Estimates transformation between the 2 cameras making a stereo pair. If we have a stereo camera, where the relative position and orientatation of the 2 cameras is fixed, and if we computed poses of an object relative to the fist camera and to the second camera, (R1, T1) and (R2, T2), respectively (that can be done with cvFindExtrinsicCameraParams2), obviously, those poses will relate to each other, i.e. given (R1, T1) it should be possible to compute (R2, T2) - we only need to know the position and orientation of the 2nd camera relative to the 1st camera. That's what the described function does. It computes (R, T) such that:
            R2=R*R1,
            T2=R*T1 + T
            </summary>
            <param name="objectPoints">The 3D location of the object points. The first index is the index of image, second index is the index of the point</param>
            <param name="imagePoints1">The 2D image location of the points for camera 1. The first index is the index of the image, second index is the index of the point</param>
            <param name="imagePoints2">The 2D image location of the points for camera 2. The first index is the index of the image, second index is the index of the point</param>
            <param name="intrinsicParam1">The intrisinc parameters for camera 1, might contains some initial values. The values will be modified by this function.</param>
            <param name="intrinsicParam2">The intrisinc parameters for camera 2, might contains some initial values. The values will be modified by this function.</param>
            <param name="imageSize">Size of the image, used only to initialize intrinsic camera matrix</param>
            <param name="flags">Different flags</param>
            <param name="extrinsicParams">The extrinsic parameters which contains:
            R - The rotation matrix between the 1st and the 2nd cameras' coordinate systems; 
            T - The translation vector between the cameras' coordinate systems. </param>
            <param name="essentialMatrix">The essential matrix</param>
            <param name="termCrit">Termination criteria for the iterative optimiziation algorithm </param>
            <param name="foundamentalMatrix">The fundamental matrix</param>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.SolvePnP(Emgu.CV.Structure.MCvPoint3D32f[],System.Drawing.PointF[],Emgu.CV.IntrinsicCameraParameters,Emgu.CV.CvEnum.SolvePnpMethod)">
            <summary>
            Estimates extrinsic camera parameters using known intrinsic parameters and extrinsic parameters for each view. The coordinates of 3D object points and their correspondent 2D projections must be specified. This function also minimizes back-projection error. 
            </summary>
            <param name="objectPoints">The array of object points</param>
            <param name="imagePoints">The array of corresponding image points</param>
            <param name="intrin">The intrinsic parameters</param>
            <param name="method">Method for solving a PnP problem</param>
            <returns>The extrinsic parameters</returns>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.ProjectPoints(Emgu.CV.Structure.MCvPoint3D32f[],Emgu.CV.ExtrinsicCameraParameters,Emgu.CV.IntrinsicCameraParameters,Emgu.CV.Matrix{System.Single}[])">
            <summary>
            Computes projections of 3D points to the image plane given intrinsic and extrinsic camera parameters. 
            Optionally, the function computes jacobians - matrices of partial derivatives of image points as functions of all the input parameters w.r.t. the particular parameters, intrinsic and/or extrinsic. 
            The jacobians are used during the global optimization in cvCalibrateCamera2 and cvFindExtrinsicCameraParams2. 
            The function itself is also used to compute back-projection error for with current intrinsic and extrinsic parameters. 
            </summary>
            <remarks>Note, that with intrinsic and/or extrinsic parameters set to special values, the function can be used to compute just extrinsic transformation or just intrinsic transformation (i.e. distortion of a sparse set of points) </remarks>
            <param name="objectPoints">The array of object points.</param>
            <param name="extrin">Extrinsic parameters</param>
            <param name="intrin">Intrinsic parameters</param>
            <param name="mats">Optional matrix supplied in the following order: dpdrot, dpdt, dpdf, dpdc, dpddist</param>
            <returns>The array of image points which is the projection of <paramref name="objectPoints"/></returns>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.GetAffineTransform(System.Drawing.PointF[],System.Drawing.PointF[])">
            <summary>
            Calculates the matrix of an affine transform such that:
            (x'_i,y'_i)^T=map_matrix (x_i,y_i,1)^T
            where dst(i)=(x'_i,y'_i), src(i)=(x_i,y_i), i=0..2.
            </summary>
            <param name="src">Coordinates of 3 triangle vertices in the source image. If the array contains more than 3 points, only the first 3 will be used</param>
            <param name="dest">Coordinates of the 3 corresponding triangle vertices in the destination image. If the array contains more than 3 points, only the first 3 will be used</param>
            <returns>The 2x3 rotation matrix that defines the Affine transform</returns>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.EstimateRigidTransform(System.Drawing.PointF[],System.Drawing.PointF[],System.Boolean)">
            <summary>
            Estimate rigid transformation between 2 point sets.
            </summary>
            <param name="sourcePoints">The points from the source image</param>
            <param name="destinationPoints">The corresponding points from the destination image</param>
            <param name="fullAffine">Indicates if full affine should be performed</param>
            <returns>If success, the 2x3 rotation matrix that defines the Affine transform. Otherwise null is returned.</returns>
        </member>
        <member name="T:Emgu.CV.ExtrinsicCameraParameters">
            <summary>
            Extrinsic camera parameters
            </summary>
        </member>
        <member name="M:Emgu.CV.ExtrinsicCameraParameters.#ctor">
            <summary>
            Create the extrinsic camera parameters
            </summary>
        </member>
        <member name="M:Emgu.CV.ExtrinsicCameraParameters.#ctor(Emgu.CV.RotationVector3D,Emgu.CV.Matrix{System.Double})">
            <summary>
            Create the extrinsic camera parameters using the specific rotation and translation matrix
            </summary>
            <param name="rotation">The rotation vector</param>
            <param name="translation">The translation vector</param>
        </member>
        <member name="M:Emgu.CV.ExtrinsicCameraParameters.Equals(Emgu.CV.ExtrinsicCameraParameters)">
            <summary>
            Return true if the two extrinsic camera parameters are equal
            </summary>
            <param name="other">The other extrinsic camera parameters to compare with</param>
            <returns>True if the two extrinsic camera parameters are equal</returns>
        </member>
        <member name="P:Emgu.CV.ExtrinsicCameraParameters.RotationVector">
            <summary>
            Get or Set the rodrigus rotation vector
            </summary>
        </member>
        <member name="P:Emgu.CV.ExtrinsicCameraParameters.TranslationVector">
            <summary>
            Get or Set the translation vector ( as 3 x 1 matrix)
            </summary>
        </member>
        <member name="P:Emgu.CV.ExtrinsicCameraParameters.ExtrinsicMatrix">
            <summary>
            Get the 3 x 4 extrinsic matrix: [[r11 r12 r13 t1] [r21 r22 r23 t2] [r31 r32 r33 t2]]
            </summary>
        </member>
        <member name="T:Emgu.CV.IntrinsicCameraParameters">
            <summary>
            Intrinsic camera parameters
            </summary>
        </member>
        <member name="M:Emgu.CV.IntrinsicCameraParameters.#ctor">
            <summary>
            Create the intrinsic camera parameters
            </summary>
        </member>
        <member name="M:Emgu.CV.IntrinsicCameraParameters.#ctor(System.Int32)">
            <summary>
            Create the intrinsic camera parameters 
            </summary>
            <param name="distortionCoeffsCount">The number of distortion coefficients. Should be either 4, 5 or 8.</param>
        </member>
        <member name="M:Emgu.CV.IntrinsicCameraParameters.InitUndistortMap(System.Int32,System.Int32,Emgu.CV.Matrix{System.Single}@,Emgu.CV.Matrix{System.Single}@)">
            <summary>
            Pre-computes the undistortion map - coordinates of the corresponding pixel in the distorted image for every pixel in the corrected image. Then, the map (together with input and output images) can be passed to cvRemap function.
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
            <param name="mapx">The output array of x-coordinates of the map</param>
            <param name="mapy">The output array of y-coordinates of the map</param>
        </member>
        <member name="M:Emgu.CV.IntrinsicCameraParameters.GetIntrinsicMatrixValues(System.Int32,System.Int32,System.Double,System.Double,System.Double@,System.Double@,System.Double@,Emgu.CV.Structure.MCvPoint2D64f@,System.Double@)">
            <summary>
            computes various useful camera (sensor/lens) characteristics using the computed camera calibration matrix, image frame resolution in pixels and the physical aperture size
            </summary>
            <param name="imgWidth">Image width in pixels</param>
            <param name="imgHeight">Image height in pixels</param>
            <param name="apertureWidth">Aperture width in realworld units (optional input parameter). Set it to 0 if not used</param>
            <param name="apertureHeight">Aperture width in realworld units (optional input parameter). Set it to 0 if not used</param>
            <param name="fovx">Field of view angle in x direction in degrees</param>
            <param name="fovy">Field of view angle in y direction in degrees </param>
            <param name="focalLength">Focal length in realworld units </param>
            <param name="principalPoint">The principal point in realworld units </param>
            <param name="pixelAspectRatio">The pixel aspect ratio ~ fy/f</param>
        </member>
        <member name="M:Emgu.CV.IntrinsicCameraParameters.Undistort(System.Drawing.PointF[],Emgu.CV.Matrix{System.Double},Emgu.CV.Matrix{System.Double})">
            <summary>
            Similar to cvInitUndistortRectifyMap and is opposite to it at the same time.
            The functions are similar in that they both are used to correct lens distortion and to perform the optional perspective (rectification) transformation.
            They are opposite because the function cvInitUndistortRectifyMap does actually perform the reverse transformation in order to initialize the maps properly, while this function does the forward transformation.
            </summary>
            <param name="src">The observed point coordinates</param>
            <param name="R">Optional rectification transformation in object space (3x3 matrix). R1 or R2, computed by cvStereoRectify can be passed here. If null, the identity matrix is used.</param>
            <param name="P">Optional new camera matrix (3x3) or the new projection matrix (3x4). P1 or P2, computed by cvStereoRectify can be passed here. If null, the identity matrix is used.</param>
        </member>
        <member name="M:Emgu.CV.IntrinsicCameraParameters.Undistort``2(Emgu.CV.Image{``0,``1})">
            <summary>
            Transforms the image to compensate radial and tangential lens distortion. 
            The camera matrix and distortion parameters can be determined using cvCalibrateCamera2. For every pixel in the output image the function computes coordinates of the corresponding location in the input image using the formulae in the section beginning. Then, the pixel value is computed using bilinear interpolation. If the resolution of images is different from what was used at the calibration stage, fx, fy, cx and cy need to be adjusted appropriately, while the distortion coefficients remain the same
            </summary>
            <typeparam name="TColor">The color type of the image</typeparam>
            <typeparam name="TDepth">The depth of the image</typeparam>
            <param name="src">The distorted image</param>
            <returns>The corrected image</returns>
        </member>
        <member name="M:Emgu.CV.IntrinsicCameraParameters.Equals(Emgu.CV.IntrinsicCameraParameters)">
            <summary>
            Return true if the two intrinsic camera parameters are equal
            </summary>
            <param name="other">The other intrinsic camera parameters to compare with</param>
            <returns>True if the two intrinsic camera parameters are equal</returns>
        </member>
        <member name="P:Emgu.CV.IntrinsicCameraParameters.DistortionCoeffs">
            <summary>
            Get or Set the DistortionCoeffs ( as a 5x1 (default), 4x1 or 8x1 matrix ). 
            The ordering of the distortion coefficients is the following:
            (k1, k2, p1, p2[, k3 [,k4, k5, k6]]).
            That is, the first 2 radial distortion coefficients are followed by 2 tangential distortion coefficients and then, optionally, by the third radial distortion coefficients. Such ordering is used to keep backward compatibility with previous versions of OpenCV
            </summary>
        </member>
        <member name="P:Emgu.CV.IntrinsicCameraParameters.IntrinsicMatrix">
            <summary>
            Get or Set the intrinsic matrix (3x3)
            </summary>
        </member>
        <member name="T:Emgu.CV.Quaternions">
            <summary>
            A unit quaternions that defines rotation in 3D
            </summary>
        </member>
        <member name="M:Emgu.CV.Quaternions.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Create a quaternion with the specific values
            </summary>
            <param name="w">The W component of the quaternion: the value for cos(rotation angle / 2)</param>
            <param name="x">The X component of the vector: rotation axis * sin(rotation angle / 2)</param>
            <param name="y">The Y component of the vector: rotation axis * sin(rotation angle / 2)</param>
            <param name="z">The Z component of the vector: rotation axis * sin(rotation angle / 2)</param>
        </member>
        <member name="M:Emgu.CV.Quaternions.SetEuler(System.Double,System.Double,System.Double)">
            <summary>
            Set the value of the quaternions using euler angle
            </summary>
            <param name="x">Rotation around x-axis (roll) in radian</param>
            <param name="y">Rotation around y-axis (pitch) in radian</param>
            <param name="z">rotation around z-axis (yaw) in radian</param>
        </member>
        <member name="M:Emgu.CV.Quaternions.GetEuler(System.Double@,System.Double@,System.Double@)">
            <summary>
            Get the equivalent euler angle
            </summary>
            <param name="x">Rotation around x-axis (roll) in radian</param>
            <param name="y">Rotation around y-axis (pitch) in radian</param>
            <param name="z">rotation around z-axis (yaw) in radian</param>
        </member>
        <member name="M:Emgu.CV.Quaternions.GetRotationMatrix(Emgu.CV.Matrix{System.Double})">
            <summary>
            Fill the (3x3) rotation matrix with the value such that it represent the quaternions
            </summary>
            <param name="rotation">The (3x3) rotation matrix which values will be set to represent this quaternions</param>
        </member>
        <member name="M:Emgu.CV.Quaternions.RotatePoints(Emgu.CV.Matrix{System.Double},Emgu.CV.Matrix{System.Double})">
            <summary>
            Rotate the points in <paramref name="pointsSrc"/> and save the result in <paramref name="pointsDst"/>. In-place operation is supported (<paramref name="pointsSrc"/> == <paramref name="pointsDst"/>).
            </summary>
            <param name="pointsSrc">The points to be rotated</param>
            <param name="pointsDst">The result of the rotation, should be the same size as <paramref name="pointsSrc"/>, can be <paramref name="pointsSrc"/> as well for inplace rotation</param>
        </member>
        <member name="M:Emgu.CV.Quaternions.RotatePoint(Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Rotate the specific point and return the result
            </summary>
            <param name="point">The point to be rotated</param>
            <returns>The rotated point</returns>
        </member>
        <member name="M:Emgu.CV.Quaternions.Multiply(Emgu.CV.Quaternions)">
            <summary>
            Multiply the current Quaternions with <paramref name="quaternionsOther"/> 
            </summary>
            <param name="quaternionsOther">The other rotation</param>
            <return>A composition of the two rotations</return>
        </member>
        <member name="M:Emgu.CV.Quaternions.Slerp(Emgu.CV.Quaternions,System.Double)">
            <summary>
            Perform quaternions linear interpolation
            </summary>
            <param name="quaternionsOther">The other quaternions to interpolate with</param>
            <param name="weightForOther">If 0.0, the result is the same as this quaternions. If 1.0 the result is the same as <paramref name="quaternionsOther"/></param>
            <returns>The linear interpolated quaternions</returns>
        </member>
        <member name="M:Emgu.CV.Quaternions.op_Multiply(Emgu.CV.Quaternions,Emgu.CV.Quaternions)">
            <summary>
            Computes the multiplication of two quaternions
            </summary>
            <param name="q1">The quaternions to be multiplied</param>
            <param name="q2">The quaternions to be multiplied</param>
            <returns>The multiplication of two quaternions</returns>
        </member>
        <member name="F:Emgu.CV.Quaternions.Empty">
            <summary>
            Get the quaternions that represent a rotation of 0 degrees.
            </summary>
        </member>
        <member name="M:Emgu.CV.Quaternions.Conjugate">
            <summary>
            Compute the conjugate of the quaternions
            </summary>
        </member>
        <member name="M:Emgu.CV.Quaternions.Equals(Emgu.CV.Quaternions)">
            <summary>
            Check if this quaternions equals to <paramref name="other"/>
            </summary>
            <param name="other">The quaternions to be compared</param>
            <returns>True if two quaternions equals, false otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Quaternions.ToString">
            <summary>
            Get the string representation of the Quaternions
            </summary>
            <returns>The string representation</returns>
        </member>
        <member name="P:Emgu.CV.Quaternions.W">
            <summary>
            The W component of the quaternion: the value for cos(rotation angle / 2)
            </summary>
        </member>
        <member name="P:Emgu.CV.Quaternions.X">
            <summary>
            The X component of the vector: rotation axis * sin(rotation angle / 2)
            </summary>
        </member>
        <member name="P:Emgu.CV.Quaternions.Y">
            <summary>
            The Y component of the vector: rotation axis * sin(rotation angle / 2)
            </summary>
        </member>
        <member name="P:Emgu.CV.Quaternions.Z">
            <summary>
            The Z component of the vector: rotation axis * sin(rotation angle / 2)
            </summary>
        </member>
        <member name="P:Emgu.CV.Quaternions.AxisAngle">
            <summary>
            Get or set the equivalent axis angle representation. (x,y,z) is the rotation axis and |(x,y,z)| is the rotation angle in radians
            </summary>
        </member>
        <member name="P:Emgu.CV.Quaternions.RotationAxis">
            <summary>
            Get the rotation axis of the quaternion
            </summary>
        </member>
        <member name="P:Emgu.CV.Quaternions.RotationAngle">
            <summary>
            Get the rotation angle in radian
            </summary>
        </member>
        <member name="T:Emgu.CV.RotationMatrix2D">
            <summary>
            A (2x3) 2D rotation matrix. This Matrix defines an Affine Transform
            </summary>
        </member>
        <member name="T:Emgu.CV.Mat">
            <summary>
            The equivalent of cv::Mat
            </summary>
        </member>
        <member name="T:Emgu.CV.MatDataAllocator">
            <summary>
            Matrix data allocator. Base class for Mat that handles the matrix data allocation and deallocation
            </summary>
        </member>
        <member name="M:Emgu.CV.MatDataAllocator.DisposeObject">
            <summary>
            Release resource associated with this object
            </summary>
        </member>
        <member name="P:Emgu.CV.MatDataAllocator.Data">
            <summary>
            Get the managed data used by the Mat
            </summary>
        </member>
        <member name="T:Emgu.CV.IImage">
            <summary>
            IImage interface
            </summary>
        </member>
        <member name="T:Emgu.CV.IInputOutputArray">
            <summary>
            This type is very similar to InputArray except that it is used for input/output function parameters.
            </summary>
        </member>
        <member name="T:Emgu.CV.IInputArray">
            <summary>
            This is the proxy class for passing read-only input arrays into OpenCV functions.
            </summary>
        </member>
        <member name="M:Emgu.CV.IInputArray.GetInputArray">
            <summary>
            The unmanaged pointer to the input array.
            </summary>
        </member>
        <member name="T:Emgu.CV.IOutputArray">
            <summary>
            This type is very similar to InputArray except that it is used for output function parameters.
            </summary>
        </member>
        <member name="M:Emgu.CV.IOutputArray.GetOutputArray">
            <summary>
            The unmanaged pointer to the output array
            </summary>
        </member>
        <member name="T:Emgu.CV.IInputArrayOfArrays">
            <summary>
            InputArrayOfArrays
            </summary>
        </member>
        <member name="T:Emgu.CV.IOutputArrayOfArrays">
            <summary>
            OutputArrayOfArrays
            </summary>
        </member>
        <member name="M:Emgu.CV.IInputOutputArray.GetInputOutputArray">
            <summary>
            The unmanaged pointer to the input/output array
            </summary>
        </member>
        <member name="M:Emgu.CV.IImage.MinMax(System.Double[]@,System.Double[]@,System.Drawing.Point[]@,System.Drawing.Point[]@)">
            <summary>
            Returns the min / max location and values for the image
            </summary>
            <returns>
            Returns the min / max location and values for the image
            </returns>
        </member>
        <member name="M:Emgu.CV.IImage.Split">
            <summary> 
             Split current IImage into an array of gray scale images where each element 
             in the array represent a single color channel of the original image
            </summary>
            <returns> 
             An array of gray scale images where each element 
             in the array represent a single color channel of the original image 
            </returns>
        </member>
        <member name="M:Emgu.CV.IImage.Save(System.String)">
            <summary>
            Save the image to the specific <paramref name="fileName"/> 
            </summary>
            <param name="fileName">The file name of the image</param>
        </member>
        <member name="P:Emgu.CV.IImage.Bitmap">
            <summary>
            Convert this image into Bitmap, when available, data is shared with this image.
            </summary>
            <returns>The Bitmap, when available, data is shared with this image</returns>
        </member>
        <member name="P:Emgu.CV.IImage.Size">
            <summary>
            The size of this image
            </summary>
        </member>
        <member name="P:Emgu.CV.IImage.Ptr">
            <summary>
            Get the pointer to the unmanaged memory
            </summary>
        </member>
        <member name="P:Emgu.CV.IImage.NumberOfChannels">
            <summary>
            Get the number of channels for this image
            </summary>
        </member>
        <member name="M:Emgu.CV.Mat.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Mat.DeserializeObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime deserailization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Mat.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">streaming context</param>
        </member>
        <member name="M:Emgu.CV.Mat.CopyTo``1(``0[])">
            <summary>
            Copy data from this Mat to the managed array
            </summary>
            <typeparam name="T">The type of managed data array</typeparam>
            <param name="data">The managed array where data will be copied to.</param>
        </member>
        <member name="M:Emgu.CV.Mat.SetTo``1(``0[])">
            <summary>
            Copy data from managed array to this Mat
            </summary>
            <typeparam name="T">The type of managed data array</typeparam>
            <param name="data">The managed array where data will be copied from</param>
        </member>
        <member name="F:Emgu.CV.Mat._parent">
            <summary>
            An option parent object to keep reference to
            </summary>
        </member>
        <member name="M:Emgu.CV.Mat.#ctor">
            <summary>
            Create an empty cv::Mat
            </summary>
        </member>
        <member name="M:Emgu.CV.Mat.#ctor(System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32)">
            <summary>
            Create a mat of the specific type.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Mat element type</param>
            <param name="channels">Number of channels</param>
        </member>
        <member name="M:Emgu.CV.Mat.#ctor(System.Drawing.Size,Emgu.CV.CvEnum.DepthType,System.Int32)">
            <summary>
            Create a mat of the specific type.
            </summary>
            <param name="size">Size of the Mat</param>
            <param name="type">Mat element type</param>
            <param name="channels">Number of channels</param>
        </member>
        <member name="M:Emgu.CV.Mat.#ctor(System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Create a Mat header from existing data
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Mat element type</param>
            <param name="channels">Number of channels</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. This operation is very efficient and can be used to process external data using OpenCV functions. The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.</param>
        </member>
        <member name="M:Emgu.CV.Mat.#ctor(System.Int32[],Emgu.CV.CvEnum.DepthType,System.IntPtr,System.IntPtr[])">
            <summary>
            Create multi-dimension mat using existing data.
            </summary>
            <param name="sizes">The sizes of each dimension</param>
            <param name="type">The type of data</param>
            <param name="data">The pointer to the unmanaged data</param>
            <param name="steps">The steps</param>
        </member>
        <member name="M:Emgu.CV.Mat.#ctor(System.Drawing.Size,Emgu.CV.CvEnum.DepthType,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Create a Mat header from existing data
            </summary>
            <param name="size">Size of the Mat</param>
            <param name="type">Mat element type</param>
            <param name="channels">Number of channels</param>
            <param name="data">Pointer to the user data. Matrix constructors that take data and step parameters do not allocate matrix data. Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. This operation is very efficient and can be used to process external data using OpenCV functions. The external data is not automatically deallocated, so you should take care of it.</param>
            <param name="step">Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any.</param>
        </member>
        <member name="M:Emgu.CV.Mat.#ctor(System.String,Emgu.CV.CvEnum.ImreadModes)">
            <summary>
            Load the Mat from file
            </summary>
            <param name="fileName">The name of the file</param>
            <param name="loadType">File loading method</param>
        </member>
        <member name="M:Emgu.CV.Mat.#ctor(Emgu.CV.Mat,System.Drawing.Rectangle)">
            <summary>
            Create a mat header for the specific ROI
            </summary>
            <param name="mat">The mat where the new Mat header will share data from</param>
            <param name="roi">The region of interest</param>
        </member>
        <member name="M:Emgu.CV.Mat.#ctor(Emgu.CV.Mat,Emgu.CV.Structure.Range,Emgu.CV.Structure.Range)">
            <summary>
            Create a mat header for the specific ROI
            </summary>
            <param name="mat">The mat where the new Mat header will share data from</param>
            <param name="rowRange">The region of interest</param>
            <param name="colRange">The region of interest</param>
        </member>
        <member name="M:Emgu.CV.Mat.GetUMat(Emgu.CV.CvEnum.AccessType,Emgu.CV.UMat.Usage)">
            <summary>
            Convert this Mat to UMat
            </summary>
            <param name="access">Access type</param>
            <param name="usageFlags">Usage flags</param>
            <returns>The UMat</returns>
        </member>
        <member name="M:Emgu.CV.Mat.Create(System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32)">
            <summary>
            Allocates new array data if needed.
            </summary>
            <param name="rows">New number of rows.</param>
            <param name="cols">New number of columns.</param>
            <param name="type">New matrix element depth type.</param>
            <param name="channels">New matrix number of channels</param>
        </member>
        <member name="M:Emgu.CV.Mat.GetData(System.Int32[])">
            <summary>
            Gets the binary data from the specific indices.
            </summary>
            <param name="indices">The indices.</param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException">Indices of length more than 2 is not implemented</exception>
        </member>
        <member name="M:Emgu.CV.Mat.CopyTo(Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Copy the data in this cv::Mat to an output array
            </summary>
            <param name="m">The output array to copy to</param>
            <param name="mask">Operation mask. Its non-zero elements indicate which matrix elements need to be copied.</param>
        </member>
        <member name="M:Emgu.CV.Mat.ConvertTo(Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,System.Double,System.Double)">
            <summary>
            Converts an array to another data type with optional scaling.
            </summary>
            <param name="m">Output matrix; if it does not have a proper size or type before the operation, it is reallocated.</param>
            <param name="rtype">Desired output matrix type or, rather, the depth since the number of channels are the same as the input has; if rtype is negative, the output matrix will have the same type as the input.</param>
            <param name="alpha">Optional scale factor.</param>
            <param name="beta">Optional delta added to the scaled values.</param>
        </member>
        <member name="M:Emgu.CV.Mat.Reshape(System.Int32,System.Int32)">
            <summary>
            Changes the shape and/or the number of channels of a 2D matrix without copying the data.
            </summary>
            <param name="cn">New number of channels. If the parameter is 0, the number of channels remains the same.</param>
            <param name="rows">New number of rows. If the parameter is 0, the number of rows remains the same.</param>
            <returns>A new mat header that has different shape</returns>
        </member>
        <member name="M:Emgu.CV.Mat.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this object.
            </summary>
        </member>
        <member name="M:Emgu.CV.Mat.GetInputArray">
            <summary>
            Pointer to the InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Mat.GetOutputArray">
            <summary>
            Pointer to the OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Mat.GetInputOutputArray">
            <summary>
            Pointer to the InputOutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Mat.GetValueRange">
            <summary>
            Get the minimum and maximum value across all channels of the mat
            </summary>
            <returns>The range that contains the minimum and maximum values</returns>
        </member>
        <member name="M:Emgu.CV.Mat.ToImage``2(System.Boolean)">
            <summary>
            Convert this Mat to Image
            </summary>
            <typeparam name="TColor">The type of Color</typeparam>
            <typeparam name="TDepth">The type of Depth</typeparam>
            <returns>The image</returns>
        </member>
        <member name="M:Emgu.CV.Mat.SetTo(Emgu.CV.Structure.MCvScalar,Emgu.CV.IInputArray)">
            <summary>
            Set the mat to the specific value
            </summary>
            <param name="value">The value to set to</param>
            <param name="mask">Optional mask</param>
        </member>
        <member name="M:Emgu.CV.Mat.SetTo(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Set the mat to the specific value
            </summary>
            <param name="value">The value to set to</param>
            <param name="mask">Optional mask</param>
        </member>
        <member name="M:Emgu.CV.Mat.MinMax(System.Double[]@,System.Double[]@,System.Drawing.Point[]@,System.Drawing.Point[]@)">
            <summary>
            Returns the min / max location and values for the image
            </summary>
            <param name="maxLocations">The maximum locations for each channel </param>
            <param name="maxValues">The maximum values for each channel</param>
            <param name="minLocations">The minimum locations for each channel</param>
            <param name="minValues">The minimum values for each channel</param>
        </member>
        <member name="M:Emgu.CV.Mat.Row(System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix row.
            </summary>
            <param name="y">A 0-based row index.</param>
            <returns>A matrix header for the specified matrix row.</returns>
        </member>
        <member name="M:Emgu.CV.Mat.Col(System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix column.
            </summary>
            <param name="x">A 0-based column index.</param>
            <returns>A matrix header for the specified matrix column.</returns>
        </member>
        <member name="M:Emgu.CV.Mat.Save(System.String)">
            <summary>
            Save this image to the specific file. 
            </summary>
            <param name="fileName">The name of the file to be saved to</param>
            <remarks>The image format is chosen depending on the filename extension, see cvLoadImage. Only 8-bit single-channel or 3-channel (with 'BGR' channel order) images can be saved using this function. If the format, depth or channel order is different, use cvCvtScale and cvCvtColor to convert it before saving, or use universal cvSave to save the image to XML or YAML format.</remarks>
        </member>
        <member name="M:Emgu.CV.Mat.Clone">
            <summary>
            Make a clone of the current Mat
            </summary>
            <returns>A clone fo the current Mat</returns>
        </member>
        <member name="M:Emgu.CV.Mat.Split">
            <summary> 
            Split current Image into an array of gray scale images where each element 
            in the array represent a single color channel of the original image
            </summary>
            <returns> 
            An array of gray scale images where each element  
            in the array represent a single color channel of the original image 
            </returns>
        </member>
        <member name="M:Emgu.CV.Mat.Equals(Emgu.CV.Mat)">
            <summary>
            Compares two Mats and check if they are equal
            </summary>
            <param name="other">The other mat to compare with</param>
            <returns>True if the two Mats are equal</returns>
        </member>
        <member name="M:Emgu.CV.Mat.Dot(Emgu.CV.IInputArray)">
            <summary>
            Computes a dot-product of two vectors.
            </summary>
            <param name="m">Another dot-product operand</param>
            <returns>The dot-product of two vectors.</returns>
        </member>
        <member name="M:Emgu.CV.Mat.Cross(Emgu.CV.IInputArray)">
            <summary>
            Computes a cross-product of two 3-element vectors.
            </summary>
            <param name="m">Another cross-product operand.</param>
            <returns>Cross-product of two 3-element vectors.</returns>
        </member>
        <member name="M:Emgu.CV.Mat.PopBack(System.Int32)">
            <summary>
            The method removes one or more rows from the bottom of the matrix
            </summary>
        </member>
        <member name="M:Emgu.CV.Mat.PushBack(Emgu.CV.Mat)">
            <summary>
            Adds elements to the bottom of the matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.Bytes">
            <summary>
            Gets or sets the data as byte array.
            </summary>
            <value>
            The bytes.
            </value>
        </member>
        <member name="P:Emgu.CV.Mat.Size">
            <summary>
            The size of this matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.Rows">
            <summary>
            The number of rows
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.Cols">
            <summary>
            The number of columns
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.DataPointer">
            <summary>
            Pointer to the beginning of the raw data
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.Step">
            <summary>
            Step
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.ElementSize">
            <summary>
            The size of the elements in this matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.Width">
            <summary>
            Get the width of the mat
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.Height">
            <summary>
            Get the height of the mat.
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.Bitmap">
            <summary>
            The Get property provide a more efficient way to convert Image&lt;Gray, Byte&gt;, Image&lt;Bgr, Byte&gt; and Image&lt;Bgra, Byte&gt; into Bitmap
            such that the image data is <b>shared</b> with Bitmap. 
            If you change the pixel value on the Bitmap, you change the pixel values on the Image object as well!
            For other types of image this property has the same effect as ToBitmap()
            <b>Take extra caution not to use the Bitmap after the Mat object is disposed</b>
            The Set property convert the bitmap to this Image type.
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.SizeOfDimemsion">
            <summary>
            Get an array of the size of the dimensions. e.g. if the mat is 9x10x11, the array of {9, 10, 11} will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.IsContinuous">
            <summary>
            True if the data is continues
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.IsSubmatrix">
            <summary>
            True if the matrix is a submatrix of another matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.Depth">
            <summary>
            Depth type
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.IsEmpty">
            <summary>
            True if the Mat is empty
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.NumberOfChannels">
            <summary>
            Number of channels
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.Total">
            <summary>
            The method returns the number of array elements (a number of pixels if the array represents an image)
            </summary>
        </member>
        <member name="P:Emgu.CV.Mat.Dims">
            <summary>
            The matrix dimensionality
            </summary>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D.#ctor">
            <summary>
            Create an empty (2x3) 2D rotation matrix
            </summary>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D.#ctor(System.Drawing.PointF,System.Double,System.Double)">
            <summary>
            Create a (2x3) 2D rotation matrix
            </summary>
            <param name="center">Center of the rotation in the source image</param>
            <param name="angle">The rotation angle in degrees. Positive values mean couter-clockwise rotation (the coordiate origin is assumed at top-left corner). </param>
            <param name="scale">Isotropic scale factor.</param>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D.SetRotation(System.Drawing.PointF,System.Double,System.Double)">
            <summary>
            Set the values of the rotation matrix
            </summary>
            <param name="center">Center of the rotation in the source image</param>
            <param name="angle">The rotation angle in degrees. Positive values mean couter-clockwise rotation (the coordiate origin is assumed at top-left corner). </param>
            <param name="scale">Isotropic scale factor.</param>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D.RotatePoints(Emgu.CV.Structure.MCvPoint2D64f[])">
            <summary>
            Rotate the <paramref name="points"/>, the value of the input <paramref name="points"/> will be changed.
            </summary>
            <param name="points">The points to be rotated, its value will be modified</param>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D.RotatePoints(System.Drawing.PointF[])">
            <summary>
            Rotate the <paramref name="points"/>, the value of the input <paramref name="points"/> will be changed.
            </summary>
            <param name="points">The points to be rotated, its value will be modified</param>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D.RotateLines(Emgu.CV.Structure.LineSegment2DF[])">
            <summary>
            Rotate the <paramref name="lineSegments"/>, the value of the input <paramref name="lineSegments"/> will be changed.
            </summary>
            <param name="lineSegments">The line segments to be rotated</param>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D.RotatePoints``1(Emgu.CV.Matrix{``0})">
            <summary>
            Rotate the single channel Nx2 matrix where N is the number of 2D points. The value of the matrix is changed after rotation.
            </summary>
            <typeparam name="TDepth">The depth of the points, must be double or float</typeparam>
            <param name="points">The N 2D-points to be rotated</param>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D.Clone">
            <summary>
            Return a clone of the Matrix
            </summary>
            <returns>A clone of the Matrix</returns>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D.CreateRotationMatrix(System.Drawing.PointF,System.Double,System.Drawing.Size,System.Drawing.Size@)">
            <summary>
            Create a rotation matrix for rotating an image
            </summary>
            <param name="angle">The rotation angle in degrees. Positive values mean couter-clockwise rotation (the coordiate origin is assumed at image centre). </param>
            <param name="center">The rotation center</param>
            <param name="srcImageSize">The source image size</param>
            <param name="dstImageSize">The minimun size of the destination image</param>
            <returns>The rotation matrix that rotate the source image to the destination image.</returns>
        </member>
        <member name="T:Emgu.CV.RotationVector3D">
            <summary>
            A (3x1) Rodrigues rotation vector. Rotation vector is a compact representation of rotation matrix. Direction of the rotation vector is the rotation axis and the length of the vector is the rotation angle around the axis. 
            </summary>
        </member>
        <member name="T:Emgu.CV.Matrix`1">
            <summary> 
            A Matrix is a wrapper to cvMat of OpenCV. 
            </summary>
            <typeparam name="TDepth">Depth of this matrix (either Byte, SByte, Single, double, UInt16, Int16 or Int32)</typeparam>
        </member>
        <member name="T:Emgu.CV.CvArray`1">
            <summary>
            Wrapped CvArr 
            </summary>
            <typeparam name="TDepth">The type of elements in this CvArray</typeparam> 
        </member>
        <member name="F:Emgu.CV.CvArray`1._sizeOfElement">
            <summary>
            The size of the elements in the CvArray, it is the cached value of Marshal.SizeOf(typeof(TDepth)).
            </summary>
        </member>
        <member name="F:Emgu.CV.CvArray`1._dataHandle">
            <summary>
            The pinned GCHandle to _array;
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1.AllocateData(System.Int32,System.Int32,System.Int32)">
            <summary>
            Allocate data for the array
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of columns</param>
            <param name="numberOfChannels">The number of channels of this cvArray</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.DotProduct(Emgu.CV.CvArray{`0})">
            <summary>
            Calculates and returns the Euclidean dot product of two arrays.
            src1 dot src2 = sumI(src1(I)*src2(I))
            </summary>
            <remarks>In case of multiple channel arrays the results for all channels are accumulated. In particular, cvDotProduct(a,a), where a is a complex vector, will return ||a||^2. The function can process multi-dimensional arrays, row by row, layer by layer and so on.</remarks>
            <param name="otherArray">The other Array to apply dot product with</param>
            <returns>src1 dot src2</returns>
        </member>
        <member name="M:Emgu.CV.CvArray`1.CheckRange(System.Double,System.Double,System.Drawing.Point@)">
            <summary>
            Check that every array element is neither NaN nor +- inf. The functions also check that each value
            is between <paramref name="min"/> and <paramref name="max"/>. in the case of multi-channel arrays each channel is processed
            independently. If some values are out of range, position of the first outlier is stored in pos, 
            and then the functions return false.
            </summary>
            <param name="min">The inclusive lower boundary of valid values range</param>
            <param name="max">The exclusive upper boundary of valid values range</param>
            <param name="position">This will be filled with the position of the first outlier</param>
            <returns>True if all values are in range</returns>
        </member>
        <member name="M:Emgu.CV.CvArray`1.Reduce``1(Emgu.CV.CvArray{``0},Emgu.CV.CvEnum.ReduceDimension,Emgu.CV.CvEnum.ReduceType)">
            <summary>
            Reduces matrix to a vector by treating the matrix rows/columns as a set of 1D vectors and performing the specified operation on the vectors until a single row/column is obtained. 
            </summary>
            <remarks>
            The function can be used to compute horizontal and vertical projections of an raster image. 
            In case of CV_REDUCE_SUM and CV_REDUCE_AVG the output may have a larger element bit-depth to preserve accuracy. 
            And multi-channel arrays are also supported in these two reduction modes
            </remarks>
            <param name="array1D">The destination single-row/single-column vector that accumulates somehow all the matrix rows/columns</param>
            <param name="dim">The dimension index along which the matrix is reduce.</param>
            <param name="type">The reduction operation type</param>
            <typeparam name="TOtherDepth">The type of depth of the reduced array</typeparam>
        </member>
        <member name="M:Emgu.CV.CvArray`1.CopyTo(Emgu.CV.CvArray{`0})">
            <summary>
             Copy the current array to <paramref name="destination"/>
             </summary>
             <param name="destination"> The destination Array</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetValue(Emgu.CV.Structure.MCvScalar,Emgu.CV.CvArray{System.Byte})">
            <summary>
            Set the element of the Array to <paramref name="value"/>, using the specific <paramref name="mask"/>
            </summary>
            <param name="value">The value to be set</param>
            <param name="mask">The mask for the operation</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetValue(System.Double,Emgu.CV.CvArray{System.Byte})">
            <summary>
            Set the element of the Array to <paramref name="value"/>, using the specific <paramref name="mask"/>
            </summary>
            <param name="value">The value to be set</param>
            <param name="mask">The mask for the operation</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetRandUniform(Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Inplace fills Array with uniformly distributed random numbers
            </summary>
            <param name="floorValue">the inclusive lower boundary of random numbers range</param>
            <param name="ceilingValue">the exclusive upper boundary of random numbers range</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetRandNormal(Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Inplace fills Array with normally distributed random numbers
            </summary>
            <param name="mean">the mean value of random numbers</param>
            <param name="std"> the standard deviation of random numbers</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetIdentity(Emgu.CV.Structure.MCvScalar)">
            <summary>
            Initializes scaled identity matrix
            </summary>
            <param name="value">The value on the diagonal</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetZero">
            <summary>
            Set the values to zero
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetIdentity">
            <summary>
            Initialize the identity matrix
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Mul(System.Double)">
            <summary>
            Inplace multiply elements of the Array by <paramref name="scale"/>
            </summary>
            <param name="scale">The scale to be multiplyed</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Mul(Emgu.CV.CvArray{`0})">
            <summary>
            Inplace elementwise multiply the current Array with <paramref name="src2"/>
            </summary>
            <param name="src2">The other array to be elementwise multiplied with</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.DisposeObject">
            <summary>
            Free the _dataHandle if it is set
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Min(System.Double)">
            <summary>
            Inplace compute the elementwise minimum value 
            </summary>
            <param name="value">The value to compare with</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Min(Emgu.CV.CvArray{`0})">
            <summary>
            Inplace elementwise minimize the current Array with <paramref name="other"/>
            </summary>
            <param name="other">The other array to be elementwise minimized with this array</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Max(System.Double)">
            <summary>
            Inplace compute the elementwise maximum value with <paramref name="value"/>
            </summary>
            <param name="value">The value to be compare with</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Max(Emgu.CV.CvArray{`0})">
            <summary>
            Inplace elementwise maximize the current Array with <paramref name="other"/>
            </summary>
            <param name="other">The other array to be elementwise maximized with this array</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._And(Emgu.CV.CvArray{`0})">
            <summary>
            Inplace And operation with <paramref name="otherArray"/>
            </summary>
            <param name="otherArray">The other array to perform AND operation</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Or(Emgu.CV.CvArray{`0})">
            <summary>
            Inplace Or operation with <paramref name="otherArray"/>
            </summary>
            <param name="otherArray">The other array to perform OR operation</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Not">
            <summary> 
            Inplace compute the complement for all array elements
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1.Save(System.String)">
            <summary>
            Save the CvArray as image
            </summary>
            <param name="fileName">The name of the image to save</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.GetSchema">
            <summary>
            Get the xml schema
            </summary>
            <returns>the xml schema</returns>
        </member>
        <member name="M:Emgu.CV.CvArray`1.ReadXml(System.Xml.XmlReader)">
            <summary>
            Function to call when deserializing this object from XML
            </summary>
            <param name="reader">The xml reader</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Function to call when serializing this object to XML 
            </summary>
            <param name="writer">The xml writer</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.DeserializeObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime deserailization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="F:Emgu.CV.CvArray`1._cvMat">
            <summary>
            The Mat header that represent this CvArr
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1.GetInputArray">
            <summary>
            The unmanaged pointer to the input array.
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1.GetOutputArray">
            <summary>
            The unmanaged pointer to the output array.
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1.GetInputOutputArray">
            <summary>
            The unmanaged pointer to the input output array.
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1.ToUMat">
            <summary>
            Get the umat representation of this mat
            </summary>
            <returns>The UMat</returns>
        </member>
        <member name="P:Emgu.CV.CvArray`1.SerializationCompressionRatio">
            <summary>
            Get or set the Compression Ratio for serialization. A number between 0 - 9. 
            0 means no compression at all, while 9 means best compression
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.SizeOfElement">
            <summary>
            Get the size of element in bytes
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Ptr">
            <summary> The pointer to the internal structure </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Size">
            <summary> 
             Get the size of the array
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Width">
            <summary> 
            Get the width (#Cols) of the cvArray.
            If ROI is set, the width of the ROI 
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Height">
            <summary> 
            Get the height (#Rows) of the cvArray.
            If ROI is set, the height of the ROI 
            </summary> 
        </member>
        <member name="P:Emgu.CV.CvArray`1.NumberOfChannels">
            <summary>
            Get the number of channels of the array
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Rows">
            <summary>
            The number of rows for this array
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Cols">
            <summary>
            The number of cols for this array
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Bytes">
            <summary>
            Get or Set an Array of bytes that represent the data in this array
            </summary>
            <remarks> Should only be used for serialization &amp; deserialization</remarks>
        </member>
        <member name="P:Emgu.CV.CvArray`1.ManagedArray">
            <summary>
            Get the underneath managed array
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Trace">
            <summary>
            Sum of diagonal elements of the matrix 
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Norm">
            <summary> 
            The norm of this Array 
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Mat">
            <summary>
            Get the Mat header that represent this CvArr
            </summary>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor">
            <summary>
            The default constructor which allows Data to be set later on
            </summary>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Int32,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Create a Matrix (only header is allocated) using the Pinned/Unmanaged <paramref name="data"/>. The <paramref name="data"/> is not freed by the disposed function of this class 
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of cols</param>
            <param name="data">The Pinned/Unmanaged data, the data must not be release before the Matrix is Disposed</param>
            <param name="step">The step (row stride in bytes)</param>
            <remarks>The caller is responsible for allocating and freeing the block of memory specified by the data parameter, however, the memory should not be released until the related Matrix is released. </remarks>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Int32,System.Int32,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Create a Matrix (only header is allocated) using the Pinned/Unmanaged <paramref name="data"/>. The <paramref name="data"/> is not freed by the disposed function of this class 
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of cols</param>
            <param name="channels">The number of channels</param>
            <param name="data">The Pinned/Unmanaged data, the data must not be release before the Matrix is Disposed</param>
            <param name="step">The step (row stride in bytes)</param>
            <remarks>The caller is responsible for allocating and freeing the block of memory specified by the data parameter, however, the memory should not be released until the related Matrix is released. </remarks>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Int32,System.Int32,System.IntPtr)">
            <summary>
            Create a Matrix (only header is allocated) using the Pinned/Unmanaged <paramref name="data"/>. The <paramref name="data"/> is not freed by the disposed function of this class 
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of cols</param>
            <param name="data">The Pinned/Unmanaged data, the data must not be release before the Matrix is Disposed</param>
            <remarks>The caller is responsible for allocating and freeing the block of memory specified by the data parameter, however, the memory should not be released until the related Matrix is released. </remarks>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a matrix of the specific size
            </summary>
            <param name="rows">The number of rows (<b>height</b>)</param>
            <param name="cols">The number of cols (<b>width</b>)</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Drawing.Size)">
            <summary>
            Create a matrix of the specific size
            </summary>
            <param name="size">The size of the matrix</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a matrix of the specific size and channels
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of cols</param>
            <param name="channels">The number of channels</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(`0[0:,0:])">
            <summary> 
            Create a matrix using the specific data. 
            </summary>
            <remarks>The data will be used as the Matrix data storage. You need to make sure that the data object live as long as this Matrix object</remarks>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(`0[])">
            <summary>
            Create a matrix using the specific <paramref name="data"/>
            </summary>
            <param name="data">the data for this matrix</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.CopyBlank">
            <summary>
            Return a matrix of the same size with all elements equals 0
            </summary>
            <returns>A matrix of the same size with all elements equals 0</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Clone">
            <summary>
            Make a copy of this matrix
            </summary>
            <returns>A copy if this matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Reshape(System.Int32,System.Int32)">
            <summary>
            Get reshaped matrix which also share the same data with the current matrix
            </summary>
            <param name="newChannels">the new number of channles</param>
            <param name="newRows">The new number of rows</param>
            <returns>A reshaped matrix which also share the same data with the current matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Convert``1(System.Double,System.Double)">
            <summary>
            Convert this matrix to different depth
            </summary>
            <typeparam name="TOtherDepth">The depth type to convert to</typeparam>
            <param name="scale">the scaling factor to apply during conversion (defaults to 1.0 -- no scaling)</param>
            <param name="shift">the shift factor to apply during conversion (defaults to 0.0 -- no shifting)</param>
            <returns>Matrix of different depth</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Transpose">
            <summary> Returns the transpose of this matrix</summary>
            <returns>The transpose of this matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.AllocateData(System.Int32,System.Int32,System.Int32)">
            <summary>
            Allocate data for the array
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of columns</param>
            <param name="numberOfChannels">The number of channels for this matrix</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetSubRect(System.Drawing.Rectangle)">
            <summary>
            Get a submatrix corresponding to a specified rectangle
            </summary>
            <param name="rect">the rectangle area of the sub-matrix</param>
            <returns>A submatrix corresponding to a specified rectangle</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetRow(System.Int32)">
            <summary>
            Get the specific row of the matrix
            </summary>
            <param name="row">the index of the row to be reterived</param>
            <returns>the specific row of the matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetRows(System.Int32,System.Int32,System.Int32)">
            <summary>
            Return the matrix corresponding to a specified row span of the input array
            </summary>
            <param name="startRow">Zero-based index of the starting row (inclusive) of the span</param>
            <param name="endRow">Zero-based index of the ending row (exclusive) of the span</param>
            <param name="deltaRow">Index step in the row span. That is, the function extracts every delta_row-th row from start_row and up to (but not including) end_row</param>
            <returns>A matrix corresponding to a specified row span of the input array</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetCol(System.Int32)">
            <summary>
            Get the specific column of the matrix
            </summary>
            <param name="col">the index of the column to be reterived</param>
            <returns>the specific column of the matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetCols(System.Int32,System.Int32)">
            <summary>
            Get the Matrix, corresponding to a specified column span of the input array
            </summary>
            <param name="endCol">Zero-based index of the ending column (exclusive) of the span</param>
            <param name="startCol">Zero-based index of the selected column</param>
            <returns>the specific column span of the matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetDiag(System.Int32)">
            <summary>
            Return the specific diagonal elements of this matrix
            </summary>
            <param name="diag">Array diagonal. Zero corresponds to the main diagonal, -1 corresponds to the diagonal above the main etc., 1 corresponds to the diagonal below the main etc</param>
            <returns>The specific diagonal elements of this matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetDiag">
            <summary>
            Return the main diagonal element of this matrix
            </summary>
            <returns>The main diagonal element of this matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.RemoveRows(System.Int32,System.Int32)">
            <summary>
            Return the matrix without a specified row span of the input array
            </summary>
            <param name="startRow">Zero-based index of the starting row (inclusive) of the span</param>
            <param name="endRow">Zero-based index of the ending row (exclusive) of the span</param>
            <returns>The matrix without a specified row span of the input array</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.RemoveCols(System.Int32,System.Int32)">
            <summary>
            Return the matrix without a specified column span of the input array
            </summary>
            <param name="startCol">Zero-based index of the starting column (inclusive) of the span</param>
            <param name="endCol">Zero-based index of the ending column (exclusive) of the span</param>
            <returns>The matrix without a specified column span of the input array</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.ConcateVertical(Emgu.CV.Matrix{`0})">
            <summary>
            Concate the current matrix with another matrix vertically. If this matrix is n1 x m and <paramref name="otherMatrix"/> is n2 x m, the resulting matrix is (n1+n2) x m.
            </summary>
            <param name="otherMatrix">The other matrix to concate</param>
            <returns>A new matrix that is the vertical concatening of this matrix and <paramref name="otherMatrix"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.ConcateHorizontal(Emgu.CV.Matrix{`0})">
            <summary>
            Concate the current matrix with another matrix horizontally. If this matrix is n x m1 and <paramref name="otherMatrix"/> is n x m2, the resulting matrix is n x (m1 + m2).
            </summary>
            <param name="otherMatrix">The other matrix to concate</param>
            <returns>A matrix that is the horizontal concatening of this matrix and <paramref name="otherMatrix"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.MinMax(System.Double@,System.Double@,System.Drawing.Point@,System.Drawing.Point@,Emgu.CV.IInputArray)">
            <summary>
            Returns the min / max locations and values for the matrix
            </summary>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Add(Emgu.CV.Matrix{`0})">
            <summary> Elementwise add another matrix with the current matrix </summary>
            <param name="mat2">The matrix to be added to the current matrix</param>
            <returns> The result of elementwise adding mat2 to the current matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Add(`0)">
            <summary> Elementwise add a color <paramref name="val"/> to the current matrix</summary>
            <param name="val">The value to be added to the current matrix</param>
            <returns> The result of elementwise adding <paramref name="val"/> from the current matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Sub(Emgu.CV.Matrix{`0})">
            <summary> Elementwise subtract another matrix from the current matrix </summary>
            <param name="mat2"> The matrix to be subtracted to the current matrix</param>
            <returns> The result of elementwise subtracting mat2 from the current matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Sub(`0)">
            <summary> Elementwise subtract a color <paramref name="val"/> to the current matrix</summary>
            <param name="val"> The value to be subtracted from the current matrix</param>
            <returns> The result of elementwise subtracting <paramref name="val"/> from the current matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.SubR(`0)">
            <summary>
            result = val - this
            </summary>
            <param name="val">The value which subtract this matrix</param>
            <returns>val - this</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Mul(System.Double)">
            <summary> Multiply the current matrix with <paramref name="scale"/></summary>
            <param name="scale">The scale to be multiplied</param>
            <returns> The scaled matrix </returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Mul(Emgu.CV.Matrix{`0})">
            <summary> Multiply the current matrix with <paramref name="mat2"/></summary>
            <param name="mat2">The matrix to be multiplied</param>
            <returns> Result matrix of the multiplication </returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Addition(Emgu.CV.Matrix{`0},Emgu.CV.Matrix{`0})">
            <summary>
            Elementwise add <paramref name="mat1"/> with <paramref name="mat2"/>
            </summary>
            <param name="mat1">The Matrix to be added</param>
            <param name="mat2">The Matrix to be added</param>
            <returns>The elementwise sum of the two matrices</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Addition(Emgu.CV.Matrix{`0},System.Double)">
            <summary>
            Elementwise add <paramref name="mat1"/> with <paramref name="val"/>
            </summary>
            <param name="mat1">The Matrix to be added</param>
            <param name="val">The value to be added</param>
            <returns>The matrix plus the value</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Addition(System.Double,Emgu.CV.Matrix{`0})">
            <summary>
            <paramref name="val"/> + <paramref name="mat1"/>
            </summary>
            <param name="mat1">The Matrix to be added</param>
            <param name="val">The value to be added</param>
            <returns>The matrix plus the value</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Subtraction(System.Double,Emgu.CV.Matrix{`0})">
            <summary>
            <paramref name="val"/> - <paramref name="mat1"/> 
            </summary>
            <param name="mat1">The Matrix to be subtracted</param>
            <param name="val">The value to be subtracted</param>
            <returns><paramref name="val"/> - <paramref name="mat1"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Subtraction(Emgu.CV.Matrix{`0},Emgu.CV.Matrix{`0})">
            <summary>
            <paramref name="mat1"/> - <paramref name="mat2"/> 
            </summary>
            <param name="mat1">The Matrix to be subtracted</param>
            <param name="mat2">The matrix to subtract</param>
            <returns><paramref name="mat1"/> - <paramref name="mat2"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Subtraction(Emgu.CV.Matrix{`0},System.Double)">
            <summary>
            <paramref name="mat1"/> - <paramref name="val"/> 
            </summary>
            <param name="mat1">The Matrix to be subtracted</param>
            <param name="val">The value to be subtracted</param>
            <returns><paramref name="mat1"/> - <paramref name="val"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Multiply(Emgu.CV.Matrix{`0},System.Double)">
            <summary>
            <paramref name="mat1"/> * <paramref name="val"/> 
            </summary>
            <param name="mat1">The Matrix to be multiplied</param>
            <param name="val">The value to be multiplied</param>
            <returns><paramref name="mat1"/> * <paramref name="val"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Multiply(System.Double,Emgu.CV.Matrix{`0})">
            <summary>
             <paramref name="val"/> * <paramref name="mat1"/> 
            </summary>
            <param name="mat1">The matrix to be multiplied</param>
            <param name="val">The value to be multiplied</param>
            <returns> <paramref name="val"/> * <paramref name="mat1"/> </returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Division(Emgu.CV.Matrix{`0},System.Double)">
            <summary>
            <paramref name="mat1"/> / <paramref name="val"/> 
            </summary>
            <param name="mat1">The Matrix to be divided</param>
            <param name="val">The value to be divided</param>
            <returns><paramref name="mat1"/> / <paramref name="val"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Multiply(Emgu.CV.Matrix{`0},Emgu.CV.Matrix{`0})">
            <summary>
            <paramref name="mat1"/> * <paramref name="mat2"/> 
            </summary>
            <param name="mat1">The Matrix to be multiplied</param>
            <param name="mat2">The Matrix to be multiplied</param>
            <returns><paramref name="mat1"/> * <paramref name="mat2"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.DisposeObject">
            <summary>
            Release the matrix and all the memory associate with it
            </summary>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Cmp(Emgu.CV.Matrix{`0},Emgu.CV.CvEnum.CmpType)">
            <summary>
            This function compare the current matrix with <paramref name="mat2"/> and returns the comparison mask
            </summary>
            <param name="mat2">The other matrix to compare with</param>
            <param name="type">Comparison type</param>
            <returns>The comparison mask</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Split">
            <summary>
            Get all channels for the multi channel matrix
            </summary>
            <returns>Each individual channel of this matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Equals(Emgu.CV.Matrix{`0})">
            <summary>
            Return true if every element of this matrix equals elements in <paramref name="mat2"/>
            </summary>
            <param name="mat2">The other matrix to compare with</param>
            <returns>true if every element of this matrix equals elements in <paramref name="mat2"/></returns>
        </member>
        <member name="P:Emgu.CV.Matrix`1.ManagedArray">
            <summary>
            Get the underneath managed array
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.Data">
            <summary>
            Get or Set the data for this matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.NumberOfChannels">
            <summary>
            Get the number of channels for this matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.MCvMat">
            <summary>
            The MCvMat structure format  
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.Det">
            <summary>
            Returns determinant of the square matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.Sum">
            <summary>
            Return the sum of the elements in this matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.Item(System.Int32,System.Int32)">
            <summary>
            Get or Set the value in the specific <paramref name="row"/> and <paramref name="col"/>
            </summary>
            <param name="row">the row of the element</param>
            <param name="col">the col of the element</param>
            <returns>The element on the specific <paramref name="row"/> and <paramref name="col"/></returns>
        </member>
        <member name="P:Emgu.CV.Matrix`1.Size">
            <summary> 
             Get the size of the array
            </summary>
        </member>
        <member name="M:Emgu.CV.RotationVector3D.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize 3D rotation vector
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.RotationVector3D.#ctor">
            <summary>
            Create a 3D rotation vector (3x1 Matrix).
            </summary>
        </member>
        <member name="M:Emgu.CV.RotationVector3D.#ctor(System.Double[])">
            <summary>
            Create a rotation vector using the specific values
            </summary>
            <param name="value">The values of the (3 x 1) Rodrigues rotation vector</param>
        </member>
        <member name="P:Emgu.CV.RotationVector3D.RotationMatrix">
            <summary>
            Get or Set the (3x3) rotation matrix represented by this rotation vector.
            </summary>
        </member>
        <member name="T:Emgu.CV.ICapture">
            <summary> The interface that is used for WCF to provide a image capture service</summary>
        </member>
        <member name="M:Emgu.CV.ICapture.QueryFrame">
            <summary> Capture a Bgr image frame </summary>
            <returns> A Bgr image frame</returns>
        </member>
        <member name="M:Emgu.CV.ICapture.QuerySmallFrame">
            <summary> Capture a Bgr image frame that is half width and half heigh</summary>
            <returns> A Bgr image frame that is half width and half height</returns>
        </member>
        <member name="T:Emgu.CV.IDuplexCapture">
            <summary>
            The interface to request a duplex image capture
            </summary>
        </member>
        <member name="M:Emgu.CV.IDuplexCapture.DuplexQueryFrame">
            <summary>
            Request a frame from server
            </summary>
        </member>
        <member name="M:Emgu.CV.IDuplexCapture.DuplexQuerySmallFrame">
            <summary>
            Request a frame from server which is half width and half height
            </summary>
        </member>
        <member name="T:Emgu.CV.IDuplexCaptureCallback">
            <summary>
            The interface for DuplexCaptureCallback
            </summary>
        </member>
        <member name="M:Emgu.CV.IDuplexCaptureCallback.ReceiveFrame(Emgu.CV.Mat)">
            <summary>
            Function to call when an image is received
            </summary>
            <param name="img">The image received</param>
        </member>
        <member name="T:Emgu.CV.VideoCapture">
            <summary> 
            Capture images from either camera or video file. 
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture._flipType">
            <summary>
            the type of flipping
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoCapture.#ctor(Emgu.CV.CvEnum.CaptureType)">
            <summary>
            Create a capture using the specific camera
            </summary>
            <param name="captureType">The capture type</param>
        </member>
        <member name="M:Emgu.CV.VideoCapture.#ctor">
            <summary> Create a capture using the default camera </summary>
        </member>
        <member name="M:Emgu.CV.VideoCapture.#ctor(System.Int32)">
            <summary> Create a capture using the specific camera</summary>
            <param name="camIndex"> The index of the camera to create capture from, starting from 0</param>
        </member>
        <member name="M:Emgu.CV.VideoCapture.#ctor(System.String)">
            <summary>
            Create a capture from file or a video stream
            </summary>
            <param name="fileName">The name of a file, or an url pointed to a stream.</param>
        </member>
        <member name="M:Emgu.CV.VideoCapture.DisposeObject">
            <summary>
            Release the resource for this capture
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoCapture.GetCaptureProperty(Emgu.CV.CvEnum.CapProp)">
            <summary>
            Obtain the capture property
            </summary>
            <param name="index">The index for the property</param>
            <returns>The value of the specific property</returns>
        </member>
        <member name="M:Emgu.CV.VideoCapture.SetCaptureProperty(Emgu.CV.CvEnum.CapProp,System.Double)">
            <summary>
            Sets the specified property of video capturing
            </summary>
            <param name="property">Property identifier</param>
            <param name="value">Value of the property</param>
            <returns>True if success</returns>
        </member>
        <member name="M:Emgu.CV.VideoCapture.Grab">
            <summary>
            Grab a frame
            </summary>
            <returns>True on success</returns>
        </member>
        <member name="M:Emgu.CV.VideoCapture.Start(System.ServiceModel.Dispatcher.ExceptionHandler)">
            <summary>
            Start the grab process in a separate thread. Once started, use the ImageGrabbed event handler and RetrieveGrayFrame/RetrieveBgrFrame to obtain the images.
            </summary>
            <param name="eh">An exception handler. If provided, it will be used to handle exception in the capture thread.</param>
        </member>
        <member name="M:Emgu.CV.VideoCapture.Pause">
            <summary>
            Pause the grab process if it is running.
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoCapture.Stop">
            <summary>
            Stop the grabbing thread
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoCapture.Retrieve(Emgu.CV.IOutputArray,System.Int32)">
            <summary> 
            Retrieve a Gray image frame after Grab()
            </summary>
            <param name="image">The output image</param>
            <param name="channel">The channel to retrieve image</param>
            <returns>True if the frame can be retrieved</returns>
        </member>
        <member name="M:Emgu.CV.VideoCapture.Read(Emgu.CV.Mat)">
            <summary>
            Similar to the C++ implementation of cv::Capture >> Mat
            </summary>
            <param name="m">The matrix the image will be read into.</param>
        </member>
        <member name="M:Emgu.CV.VideoCapture.QueryFrame">
            <summary> 
            Capture a Bgr image frame
            </summary>
            <returns> A Bgr image frame. If no more frames are available, null will be returned.</returns>
        </member>
        <member name="M:Emgu.CV.VideoCapture.QuerySmallFrame">
            <summary> 
             Capture a Bgr image frame that is half width and half height. 
             Mainly used by WCF when sending image to remote locations in a bandwidth conservative scenario 
            </summary>
            <remarks>Internally, this is a cvQueryFrame operation follow by a cvPyrDown</remarks>
            <returns> A Bgr image frame that is half width and half height</returns>
        </member>
        <member name="M:Emgu.CV.VideoCapture.DuplexQueryFrame">
            <summary>
            Query a frame duplexly over WCF
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoCapture.DuplexQuerySmallFrame">
            <summary>
            Query a small frame duplexly over WCF
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoCapture.CaptureSource">
            <summary>
            Get the type of the capture module
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoCapture.FlipType">
            <summary>
            Get and set the flip type
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoCapture.FlipHorizontal">
            <summary>
            Get or Set if the captured image should be flipped horizontally
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoCapture.FlipVertical">
            <summary>
            Get or Set if the captured image should be flipped vertically
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoCapture.Width">
            <summary> The width of this capture</summary>
        </member>
        <member name="P:Emgu.CV.VideoCapture.Height">
            <summary> The height of this capture </summary>
        </member>
        <member name="E:Emgu.CV.VideoCapture.ImageGrabbed">
            <summary>
            The event to be called when an image is grabbed
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoCapture.IsOpened">
            <summary>
            True if the camera is opened
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoCapture.CaptureModuleType">
            <summary>
            The type of capture source
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.CaptureModuleType.Camera">
            <summary>
            Capture from camera
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoCapture.CaptureModuleType.Highgui">
            <summary>
            Capture from file using HighGUI
            </summary>
        </member>
        <member name="T:Emgu.CV.CascadeClassifier">
            <summary>
            The Cascade Classifier
            </summary>
        </member>
        <member name="M:Emgu.CV.CascadeClassifier.#ctor">
            <summary>
            Create a cascade classifier
            </summary>
        </member>
        <member name="M:Emgu.CV.CascadeClassifier.#ctor(System.String)">
            <summary>Create a CascadeClassifier from the specific file</summary>
            <param name="fileName">The name of the file that contains the CascadeClassifier</param>
        </member>
        <member name="M:Emgu.CV.CascadeClassifier.Read(Emgu.CV.FileNode)">
            <summary>
            Load the cascade classifier from a file node
            </summary>
            <param name="node">The file node, The file may contain a new cascade classifier only.</param>
            <returns>True if the classifier can be imported.</returns>
        </member>
        <member name="M:Emgu.CV.CascadeClassifier.DetectMultiScale(Emgu.CV.IInputArray,System.Double,System.Int32,System.Drawing.Size,System.Drawing.Size)">
            <summary>
            Finds rectangular regions in the given image that are likely to contain objects the cascade has been trained for and returns those regions as a sequence of rectangles. 
            The function scans the image several times at different scales. Each time it considers overlapping regions in the image. 
            It may also apply some heuristics to reduce number of analyzed regions, such as Canny prunning. 
            After it has proceeded and collected the candidate rectangles (regions that passed the classifier cascade), it groups them and returns a sequence of average rectangles for each large enough group. 
            </summary>
            <param name="image">The image where the objects are to be detected from</param>
            <param name="scaleFactor">The factor by which the search window is scaled between the subsequent scans, for example, 1.1 means increasing window by 10%</param>
            <param name="minNeighbors">Minimum number (minus 1) of neighbor rectangles that makes up an object. All the groups of a smaller number of rectangles than min_neighbors-1 are rejected. If min_neighbors is 0, the function does not any grouping at all and returns all the detected candidate rectangles, which may be useful if the user wants to apply a customized grouping procedure. Use 3 for default.</param>
            <param name="minSize">Minimum window size. Use Size.Empty for default, where it is set to the size of samples the classifier has been trained on (~20x20 for face detection)</param>
            <param name="maxSize">Maximum window size. Use Size.Empty for default, where the parameter will be ignored.</param>
            <returns>The objects detected, one array per channel</returns>
        </member>
        <member name="M:Emgu.CV.CascadeClassifier.DisposeObject">
            <summary>
            Release the CascadeClassifier Object and all the memory associate with it
            </summary>
        </member>
        <member name="P:Emgu.CV.CascadeClassifier.IsOldFormatCascade">
            <summary>
            Get if the cascade is old format
            </summary>
        </member>
        <member name="P:Emgu.CV.CascadeClassifier.OriginalWindowSize">
            <summary>
            Get the original window size
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Bgr">
            <summary> 
            Defines a Bgr (Blue Green Red) color
            </summary>
        </member>
        <member name="T:Emgu.CV.IColor">
            <summary>
             A color type
            </summary>
        </member>
        <member name="P:Emgu.CV.IColor.MCvScalar">
            <summary>
            The equivalent MCvScalar value
            </summary>
        </member>
        <member name="P:Emgu.CV.IColor.Dimension">
            <summary>
            Get the dimension of the color type
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Bgr._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a BGR color using the specific values</summary>
            <param name="blue"> The blue value for this color </param>
            <param name="green"> The green value for this color </param>
            <param name="red"> The red value for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr.#ctor(System.Drawing.Color)">
            <summary>
            Create a Bgr color using the System.Drawing.Color
            </summary>
            <param name="winColor">System.Drawing.Color</param>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr.Equals(Emgu.CV.Structure.Bgr)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr.Blue">
            <summary> Get or set the intensity of the blue color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr.Green">
            <summary> Get or set the intensity of the green color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr.Red">
            <summary> Get or set the intensity of the red color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Bgra">
            <summary> 
            Defines a Bgra (Blue Green Red Alpha) color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Bgra._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Bgra.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary> Create a BGRA color using the specific values</summary>
            <param name="blue"> The blue value for this color </param>
            <param name="green"> The green value for this color </param>
            <param name="red"> The red value for this color </param>
            <param name="alpha"> The alpha value for this color</param>
        </member>
        <member name="M:Emgu.CV.Structure.Bgra.Equals(Emgu.CV.Structure.Bgra)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Bgra.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Bgra.Blue">
            <summary> Get or set the intensity of the blue color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgra.Green">
            <summary> Get or set the intensity of the green color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgra.Red">
            <summary> Get or set the intensity of the red color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgra.Alpha">
            <summary> Get or set the intensity of the alpha color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgra.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgra.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.ColorInfoAttribute">
            <summary>
            Attribute used to specify color information
            </summary>
        </member>
        <member name="F:Emgu.CV.ColorInfoAttribute._conversionCodename">
            <summary>
            The code which is used for color conversion
            </summary>
        </member>
        <member name="M:Emgu.CV.ColorInfoAttribute.#ctor">
            <summary>
            The code which is used for color conversion
            </summary>
        </member>
        <member name="P:Emgu.CV.ColorInfoAttribute.ConversionCodename">
            <summary>
            The code which is used for color conversion
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Gray">
            <summary> Defines a Gray color </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Gray._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Gray.#ctor(System.Double)">
            <summary> Create a Gray color with the given intensity</summary>
            <param name="intensity"> The intensity for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Gray.GetHashCode">
            <summary>
            Returns the hash code for this color
            </summary>
            <returns>the hash code</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Gray.Equals(Emgu.CV.Structure.Gray)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Gray.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Gray.Intensity">
            <summary> The intensity of the gray color </summary>
            <value> The intensity of the gray color</value>
        </member>
        <member name="P:Emgu.CV.Structure.Gray.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Gray.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Hls">
            <summary> 
            Defines a Hls (Hue Lightness Satuation) color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Hls._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Hls.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a Hls color using the specific values</summary>
            <param name="hue"> The hue value for this color ( 0 &lt; hue &lt; 180 )  </param>
            <param name="satuation"> The satuation for this color </param>
            <param name="lightness"> The lightness for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Hls.Equals(Emgu.CV.Structure.Hls)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Hls.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Hls.Hue">
            <summary> Get or set the intensity of the hue color channel ( 0 &lt; hue &lt; 180 ) </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hls.Lightness">
            <summary> Get or set the intensity of the lightness color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hls.Satuation">
            <summary> Get or set the intensity of the satuation color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hls.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hls.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Hsv">
            <summary> 
            Defines a HSV (Hue Satuation Value) color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Hsv._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Hsv.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a HSV color using the specific values</summary>
            <param name="hue"> The hue value for this color ( 0 &lt; hue &lt; 180 )  </param>
            <param name="satuation"> The satuation value for this color </param>
            <param name="value"> The value for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Hsv.Equals(Emgu.CV.Structure.Hsv)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Hsv.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Hsv.Hue">
            <summary> Get or set the intensity of the hue color channel ( 0 &lt; hue &lt; 180 ) </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hsv.Satuation">
            <summary> Get or set the intensity of the satuation color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hsv.Value">
            <summary> Get or set the intensity of the value color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hsv.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hsv.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Lab">
            <summary> 
            Defines a CIE Lab color 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Lab._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Lab.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a CIE Lab color using the specific values</summary>
            <param name="z"> The z value for this color </param>
            <param name="y"> The y value for this color </param>
            <param name="x"> The x value for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Lab.Equals(Emgu.CV.Structure.Lab)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Lab.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Lab.X">
            <summary> Get or set the intensity of the x color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Lab.Y">
            <summary> Get or set the intensity of the y color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Lab.Z">
            <summary> Get or set the intensity of the z color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Lab.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Lab.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Luv">
            <summary> 
            Defines a CIE Luv color 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Luv._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Luv.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a CIE Lab color using the specific values</summary>
            <param name="z"> The z value for this color </param>
            <param name="y"> The y value for this color </param>
            <param name="x"> The x value for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Luv.Equals(Emgu.CV.Structure.Luv)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Luv.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Luv.X">
            <summary> The intensity of the x color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Luv.Y">
            <summary> The intensity of the y color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Luv.Z">
            <summary> The intensity of the z color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Luv.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Luv.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Rgb">
            <summary> 
            Defines a Rgb (Red Green Blue) color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Rgb._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Rgb.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a RGB color using the specific values</summary>
            <param name="blue"> The blue value for this color </param>
            <param name="green"> The green value for this color </param>
            <param name="red"> The red value for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Rgb.#ctor(System.Drawing.Color)">
            <summary>
            Create a Rgb color using the System.Drawing.Color
            </summary>
            <param name="winColor">System.Drawing.Color</param>
        </member>
        <member name="M:Emgu.CV.Structure.Rgb.Equals(Emgu.CV.Structure.Rgb)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Rgb.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Rgb.Red">
            <summary> Get or set the intensity of the red color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Rgb.Green">
            <summary> Get or set the intensity of the green color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Rgb.Blue">
            <summary> Get or set the intensity of the blue color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Rgb.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Rgb.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Bgr565">
            <summary> 
            Defines a Bgr565 (Blue Green Red) color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Bgr565._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr565.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a Bgr565 color using the specific values</summary>
            <param name="blue"> The blue value for this color </param>
            <param name="green"> The green value for this color </param>
            <param name="red"> The red value for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr565.#ctor(System.Drawing.Color)">
            <summary>
            Create a Bgr565 color using the System.Drawing.Color
            </summary>
            <param name="winColor">System.Drawing.Color</param>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr565.Equals(Emgu.CV.Structure.Bgr565)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr565.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr565.Red">
            <summary> Get or set the intensity of the red color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr565.Green">
            <summary> Get or set the intensity of the green color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr565.Blue">
            <summary> Get or set the intensity of the blue color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr565.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr565.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Rgba">
            <summary> 
            Defines a Rgba (Red Green Blue Alpha) color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Rgba._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Rgba.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary> Create a RGBA color using the specific values</summary>
            <param name="blue"> The blue value for this color </param>
            <param name="green"> The green value for this color </param>
            <param name="red"> The red value for this color </param>
            <param name="alpha"> The alpha value for this color</param>
        </member>
        <member name="M:Emgu.CV.Structure.Rgba.Equals(Emgu.CV.Structure.Rgba)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Rgba.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Rgba.Red">
            <summary> Get or set the intensity of the red color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Rgba.Green">
            <summary> Get or set the intensity of the green color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Rgba.Blue">
            <summary> Get or set the intensity of the blue color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Rgba.Alpha">
            <summary> Get or set the intensity of the alpha color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Rgba.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Rgba.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Xyz">
            <summary> 
            Defines a Xyz color (CIE XYZ.Rec 709 with D65 white point)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Xyz._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Xyz.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a Xyz color using the specific values</summary>
            <param name="z"> The z value for this color </param>
            <param name="y"> The y value for this color </param>
            <param name="x"> The x value for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Xyz.Equals(Emgu.CV.Structure.Xyz)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Xyz.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Xyz.X">
            <summary> Get or set the intensity of the z color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Xyz.Y">
            <summary> Get or set the intensity of the y color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Xyz.Z">
            <summary> Get or set the intensity of the x color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Xyz.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Xyz.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Ycc">
            <summary> 
            Defines a Ycc color (YCrCb JPEG)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Ycc._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Ycc.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a Ycc color using the specific values</summary>
            <param name="y"> The Y value for this color </param>
            <param name="cr"> The Cr value for this color </param>
            <param name="cb"> The Cb value for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Ycc.Equals(Emgu.CV.Structure.Ycc)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Ycc.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Ycc.Y">
            <summary> Get or set the intensity of the Y color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Ycc.Cr">
            <summary> Get or set the intensity of the Cr color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Ycc.Cb">
            <summary> Get or set the intensity of the Cb color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Ycc.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Ycc.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.ConvolutionKernelF">
            <summary>
            A convolution kernel 
            </summary>
        </member>
        <member name="F:Emgu.CV.ConvolutionKernelF._center">
            <summary>
            The center of the convolution kernel
            </summary>
        </member>
        <member name="M:Emgu.CV.ConvolutionKernelF.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a convolution kernel with the specific number of <paramref name="rows"/> and <paramref name="cols"/>
            </summary>
            <param name="rows">The number of raws for the convolution kernel</param>
            <param name="cols">The number of columns for the convolution kernel</param>
        </member>
        <member name="M:Emgu.CV.ConvolutionKernelF.#ctor(Emgu.CV.Matrix{System.Single},System.Drawing.Point)">
            <summary>
            Create a convolution kernel using the specific matrix and center
            </summary>
            <param name="kernel">The values for the convolution kernel</param>
            <param name="center">The center of the kernel</param>
        </member>
        <member name="M:Emgu.CV.ConvolutionKernelF.#ctor(System.Single[0:,0:])">
            <summary>
            Create a convolution kernel using the specific floating point matrix
            </summary>
            <param name="kernel">The values for the convolution kernel</param>
        </member>
        <member name="M:Emgu.CV.ConvolutionKernelF.#ctor(System.Single[0:,0:],System.Drawing.Point)">
            <summary>
            Create a convolution kernel using the specific floating point matrix and center
            </summary>
            <param name="kernel">The values for the convolution kernel</param>
            <param name="center">The center for the convolution kernel</param>
        </member>
        <member name="M:Emgu.CV.ConvolutionKernelF.Flip(Emgu.CV.CvEnum.FlipType)">
            <summary> Get a flipped copy of the convolution kernel</summary>
            <param name="flipType">The type of the flipping</param>
            <returns> The flipped copy of <i>this</i> image </returns>
        </member>
        <member name="M:Emgu.CV.ConvolutionKernelF.Transpose">
            <summary>
            Obtain the transpose of the convolution kernel
            </summary>
            <returns>A transposed convolution kernel</returns>
        </member>
        <member name="P:Emgu.CV.ConvolutionKernelF.Center">
            <summary>
            The center of the convolution kernel
            </summary>
        </member>
        <member name="T:Emgu.CV.Cvb.CvBlob">
            <summary>
            CvBlob
            </summary>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlob.GetContour">
            <summary>
            Get the contour that defines the blob
            </summary>
            <returns>The contour of the blob</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlob.op_Implicit(Emgu.CV.Cvb.CvBlob)~System.IntPtr">
            <summary>
            Implicit operator for IntPtr
            </summary>
            <param name="obj">The CvBlob</param>
            <returns>The unmanaged pointer for this object</returns>
        </member>
        <member name="P:Emgu.CV.Cvb.CvBlob.Label">
            <summary>
            Get the blob label
            </summary>
        </member>
        <member name="P:Emgu.CV.Cvb.CvBlob.BoundingBox">
            <summary>
            The minimum bounding box of the blob
            </summary>
        </member>
        <member name="P:Emgu.CV.Cvb.CvBlob.BlobMoments">
            <summary>
            Get the Blob Moments
            </summary>
        </member>
        <member name="P:Emgu.CV.Cvb.CvBlob.Centroid">
            <summary>
            The centroid of the blob
            </summary>
        </member>
        <member name="P:Emgu.CV.Cvb.CvBlob.Area">
            <summary>
            The number of pixels in this blob
            </summary>
        </member>
        <member name="P:Emgu.CV.Cvb.CvBlob.Ptr">
            <summary>
            Pointer to the blob
            </summary>
        </member>
        <member name="T:Emgu.CV.Cvb.CvBlob.Moments">
            <summary>
            Blob Moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.M00">
            <summary>
            Mement 00
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.M10">
            <summary>
            Moment 10
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.M01">
            <summary>
            Moment 01
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.M11">
            <summary>
            Moment 11
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.M20">
            <summary>
            Moment 20
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.M02">
            <summary>
             Moment 02
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.U11">
            <summary>
            Central moment 11
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.U20">
            <summary>
            Central moment 20
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.U02">
            <summary>
            Central moment 02
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.N11">
            <summary>
            Normalized central moment 11
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.N20">
            <summary>
            Normalized central moment 20
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.N02">
            <summary>
            Normalized central moment 02
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.P1">
            <summary>
            Hu moment 1
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlob.Moments.P2">
            <summary>
            Hu moment 2
            </summary>
        </member>
        <member name="T:Emgu.CV.Cvb.CvBlobDetector">
            <summary>
            Wrapper for the CvBlob detection functions.
            The Ptr property points to the label image of the cvb::cvLabel function.
            </summary>
            <remarks>Algorithm based on paper "A linear-time component-labeling algorithm using contour tracing technique" of Fu Chang, Chun-Jen Chen and Chi-Jen Lu.</remarks>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobDetector.Detect(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Cvb.CvBlobs)">
            <summary>
            Detect blobs from input image.
            </summary>
            <param name="img">The input image</param>
            <param name="blobs">The storage for the detected blobs</param>
            <returns>Number of pixels that has been labeled.</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobDetector.MeanColor(Emgu.CV.Cvb.CvBlob,Emgu.CV.Image{Emgu.CV.Structure.Bgr,System.Byte})">
            <summary>
            Calculates mean color of a blob in an image.
            </summary>
            <param name="blob">The blob.</param>
            <param name="originalImage">The original image</param>
            <returns>Average color</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobDetector.DrawBlobs(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Cvb.CvBlobs,Emgu.CV.Cvb.CvBlobDetector.BlobRenderType,System.Double)">
            <summary>
            Draw the blobs on the image
            </summary>
            <param name="image">The binary mask.</param>
            <param name="blobs">The blobs.</param>
            <param name="type">Drawing type.</param>
            <param name="alpha">The alpha value. 1.0 for solid color and 0.0 for transparent</param>
            <returns>The images with the blobs drawn</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobDetector.DrawBlobsMask(Emgu.CV.Cvb.CvBlobs)">
            <summary>
            Get the binary mask for the blobs listed in the CvBlobs
            </summary>
            <param name="blobs">The blobs</param>
            <returns>The binary mask for the specific blobs</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobDetector.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this Blob detector
            </summary>
        </member>
        <member name="T:Emgu.CV.Cvb.CvBlobDetector.BlobRenderType">
            <summary>
            Blob rendering type
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlobDetector.BlobRenderType.Color">
            <summary>
            Render each blog with a different color. 
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlobDetector.BlobRenderType.Centroid">
            <summary>
            Render centroid. 
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlobDetector.BlobRenderType.BoundingBox">
            <summary>
            Render bounding box. 
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlobDetector.BlobRenderType.Angle">
            <summary>
            Render angle. 
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlobDetector.BlobRenderType.ToLog">
            <summary>
            Print blob data to log out. 
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlobDetector.BlobRenderType.ToStd">
            <summary>
            Print blob data to std out. 
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvBlobDetector.BlobRenderType.Default">
            <summary>
            The default rendering type
            </summary>
        </member>
        <member name="T:Emgu.CV.Cvb.CvBlobs">
            <summary>
            CvBlobs
            </summary>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.#ctor">
            <summary>
            Create a new CvBlobs
            </summary>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.DisposeObject">
            <summary>
            Release all the unmanaged resources used by this CvBlobs
            </summary>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.FilterByArea(System.Int32,System.Int32)">
            <summary>
            Filter blobs by area. Those blobs whose areas are not in range will be erased from the input list of blobs.
            </summary>
            <param name="minArea">Minimun area</param>
            <param name="maxArea">Maximun area</param>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.Add(System.UInt32,Emgu.CV.Cvb.CvBlob)">
            <summary>
            Adds the specified label and blob to the dictionary.
            </summary>
            <param name="label">The label of the blob</param>
            <param name="blob">The blob</param>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.ContainsKey(System.UInt32)">
            <summary>
            Determines whether the CvBlobs contains the specified label.
            </summary>
            <param name="label">The label (key) to be located</param>
            <returns>True if the CvBlobs contains an element with the specific label</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.Remove(System.UInt32)">
            <summary>
            Removes the blob with the specific label
            </summary>
            <param name="label">The label of the blob</param>
            <returns>True if the element is successfully found and removed; otherwise, false.</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.TryGetValue(System.UInt32,Emgu.CV.Cvb.CvBlob@)">
            <summary>
            Gets the blob associated with the specified label.
            </summary>
            <param name="label">The blob label</param>
            <param name="blob">When this method returns, contains the blob associated with the specified labe, if the label is found; otherwise, null. This parameter is passed uninitialized.</param>
            <returns>True if the blobs contains a blob with the specific label; otherwise, false</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.Add(System.Collections.Generic.KeyValuePair{System.UInt32,Emgu.CV.Cvb.CvBlob})">
             <summary>
             Adds the specified label and blob to the CvBlobs.
             </summary>
            <param name="item">The structure representing the label and blob to add to the CvBlobs</param>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.Clear">
            <summary>
            Removes all keys and values
            </summary>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.Contains(System.Collections.Generic.KeyValuePair{System.UInt32,Emgu.CV.Cvb.CvBlob})">
            <summary>
            Determines whether the CvBlobs contains a specific label and CvBlob.
            </summary>
            <param name="item">The label and blob to be located</param>
            <returns>True if the specific label and blob is found in the CvBlobs; otherwise, false.</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.CopyTo(System.Collections.Generic.KeyValuePair{System.UInt32,Emgu.CV.Cvb.CvBlob}[],System.Int32)">
            <summary>
            Copies the elements to the <paramref name="array"/>, starting at the specific arrayIndex.
            </summary>
            <param name="array">The one-dimensional array that is the defination of the elements copied from the CvBlobs. The array must have zero-base indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array"/> at which copying begins.</param>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.Remove(System.Collections.Generic.KeyValuePair{System.UInt32,Emgu.CV.Cvb.CvBlob})">
            <summary>
            Removes a key and value from the dictionary.
            </summary>
            <param name="item">The structure representing the key and value to be removed</param>
            <returns>True if the key are value is sucessfully found and removed; otherwise false.</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An enumerator that can be used to iterate through the collection</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvBlobs.cvbCvBlobsCreate">
            <summary>
            Returns a pointer to CvBlobs
            </summary>
            <returns>Pointer to CvBlobs</returns>
        </member>
        <member name="P:Emgu.CV.Cvb.CvBlobs.Keys">
            <summary>
            Get a collection containing the labels in the CvBlobs
            </summary>
        </member>
        <member name="P:Emgu.CV.Cvb.CvBlobs.Values">
            <summary>
            Get a collection containing the blobs in the CvBlobs.
            </summary>
        </member>
        <member name="P:Emgu.CV.Cvb.CvBlobs.Item(System.UInt32)">
            <summary>
            Get the blob with the speicific label. Set function is not implemented
            </summary>
            <param name="label">The label for the blob</param>
        </member>
        <member name="P:Emgu.CV.Cvb.CvBlobs.Count">
            <summary>
            Gets the number of label/Blob pairs contained in the collection
            </summary>
        </member>
        <member name="P:Emgu.CV.Cvb.CvBlobs.IsReadOnly">
            <summary>
            Always false
            </summary>
        </member>
        <member name="T:Emgu.CV.Cvb.CvTrack">
            <summary>
            CvTrack
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvTrack.Id">
            <summary>
            Track identification number
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvTrack.BlobLabel">
            <summary>
            Label assigned to the blob related to this track
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvTrack.MinX">
            <summary>
            X min
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvTrack.MaxX">
            <summary>
            X max
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvTrack.MinY">
            <summary>
            Y min
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvTrack.MaxY">
            <summary>
            y max
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvTrack.Centroid">
            <summary>
             Centroid
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvTrack.Lifetime">
            <summary>
            Indicates how much frames the object has been in scene
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvTrack.Active">
            <summary>
            Indicates number of frames that has been active from last inactive period.
            </summary>
        </member>
        <member name="F:Emgu.CV.Cvb.CvTrack.Inactive">
            <summary>
            Indicates number of frames that has been missing.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTrack.Equals(Emgu.CV.Cvb.CvTrack)">
            <summary>
            Compares CvTrack for equality
            </summary>
            <param name="other">The other track to compares with</param>
            <returns>True if the two CvTrack are equal; otherwise false.</returns>
        </member>
        <member name="P:Emgu.CV.Cvb.CvTrack.BoundingBox">
            <summary>
            Get the minimun bounding rectanble for this track 
            </summary>
        </member>
        <member name="T:Emgu.CV.Cvb.CvTracks">
             <summary>
             Blobs tracking
             </summary>
             <remarks>
             Tracking based on:
             A.Senior,A.Hampapur,Y-LTian,L.Brown,S.Pankanti,R.Bolle.AppearanceModelsfor
             OcclusionHandling.SecondInternationalworkshoponPerformanceEvaluationofTrackingand
             SurveillanceSystems&amp;CVPR'01.December,2001.
             (http://www.research.ibm.com/peoplevision/PETS2001.pdf)
            </remarks>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.#ctor">
            <summary>
            Create a new CvTracks
            </summary>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.DisposeObject">
            <summary>
            Release all the unmanaged resources used by this CvBlobs
            </summary>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.Update(Emgu.CV.Cvb.CvBlobs,System.Double,System.UInt32,System.UInt32)">
            <summary>
            Updates list of tracks based on current blobs.
            </summary>
            <param name="blobs">List of blobs</param>
            <param name="thDistance">Distance Max distance to determine when a track and a blob match</param>
            <param name="thInactive">Inactive Max number of frames a track can be inactive</param>
            <param name="thActive">Active If a track becomes inactive but it has been active less than thActive frames, the track will be deleted.</param>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.Add(System.UInt32,Emgu.CV.Cvb.CvTrack)">
            <summary>
            Adds the specified id and track to the dictionary.
            </summary>
            <param name="id">The id of the track</param>
            <param name="track">The track</param>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.ContainsKey(System.UInt32)">
            <summary>
            Determines whether the CvTracks contains the specified id.
            </summary>
            <param name="id">The id (key) to be located</param>
            <returns>True if the CvTracks contains an element with the specific id</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.Remove(System.UInt32)">
            <summary>
            Removes the track with the specific id
            </summary>
            <param name="id">The id of the track</param>
            <returns>True if the element is successfully found and removed; otherwise, false.</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.TryGetValue(System.UInt32,Emgu.CV.Cvb.CvTrack@)">
            <summary>
            Gets the track associated with the specified id.
            </summary>
            <param name="id">The track id</param>
            <param name="track">When this method returns, contains the track associated with the specified id, if the id is found; otherwise, an empty track. This parameter is passed uninitialized.</param>
            <returns>True if the tracks contains a track with the specific id; otherwise, false</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.Add(System.Collections.Generic.KeyValuePair{System.UInt32,Emgu.CV.Cvb.CvTrack})">
             <summary>
             Adds the specified id and track to the CvTracks.
             </summary>
            <param name="item">The structure representing the id and track to add to the CvTracks</param>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.Clear">
            <summary>
            Removes all keys and values
            </summary>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.Contains(System.Collections.Generic.KeyValuePair{System.UInt32,Emgu.CV.Cvb.CvTrack})">
            <summary>
            Determines whether the CvTracks contains a specific id and CvTrack.
            </summary>
            <param name="item">The id and CvTrack to be located</param>
            <returns>True if the <paramref name="item"/> is found in the CvTracks; otherwise, false.</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.CopyTo(System.Collections.Generic.KeyValuePair{System.UInt32,Emgu.CV.Cvb.CvTrack}[],System.Int32)">
            <summary>
            Copies the elements to the <paramref name="array"/>, starting at the specific arrayIndex.
            </summary>
            <param name="array">The one-dimensional array that is the defination of the elements copied from the CvTracks. The array must have zero-base indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array"/> at which copying begins.</param>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.Remove(System.Collections.Generic.KeyValuePair{System.UInt32,Emgu.CV.Cvb.CvTrack})">
            <summary>
            Removes a key and value from the dictionary.
            </summary>
            <param name="item">The structure representing the key and value to be removed</param>
            <returns>True if the key are value is sucessfully found and removed; otherwise false.</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An enumerator that can be used to iterate through the collection</returns>
        </member>
        <member name="M:Emgu.CV.Cvb.CvTracks.cvbCvTracksCreate">
            <summary>
            Returns a pointer to CvBlobs
            </summary>
            <returns>Pointer to CvBlobs</returns>
        </member>
        <member name="P:Emgu.CV.Cvb.CvTracks.Keys">
            <summary>
            Get a collection containing the ids in the CvTracks.
            </summary>
        </member>
        <member name="P:Emgu.CV.Cvb.CvTracks.Values">
            <summary>
            Get a collection containing the tracks in the CvTracks.
            </summary>
        </member>
        <member name="P:Emgu.CV.Cvb.CvTracks.Item(System.UInt32)">
            <summary>
            Get or Set the Track with the specific id.
            </summary>
            <param name="id">The id of the Track</param>
        </member>
        <member name="P:Emgu.CV.Cvb.CvTracks.Count">
            <summary>
            Gets the number of id/track pairs contained in the collection.
            </summary>
        </member>
        <member name="P:Emgu.CV.Cvb.CvTracks.IsReadOnly">
            <summary>
            Always false.
            </summary>
        </member>
        <member name="T:Emgu.CV.DenseHistogram">
            <summary> 
             A Uniform Multi-dimensional Dense Histogram 
            </summary>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.#ctor(System.Int32,Emgu.CV.Structure.RangeF)">
            <summary>
            Creates a uniform 1-D histogram of the specified size
            </summary>
            <param name="binSize">The number of bins in this 1-D histogram. </param>
            <param name="range">The upper and lower boundary of the bin</param>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.#ctor(System.Int32[],Emgu.CV.Structure.RangeF[])">
            <summary>
            Creates a uniform multi-dimension histogram of the specified size
            </summary>
            <param name="binSizes">The length of this array is the dimension of the histogram. The values of the array contains the number of bins in each dimension. The total number of bins eaquals the multiplication of all numbers in the array</param>
            <param name="ranges">the upper and lower boundaries of the bins</param>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.Clear">
            <summary> 
             Clear this histogram
            </summary>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.Calculate``1(Emgu.CV.Image{Emgu.CV.Structure.Gray,``0}[],System.Boolean,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Project the images to the histogram bins 
            </summary>
            <typeparam name="TDepth">The type of depth of the image</typeparam>
            <param name="imgs">images to project</param>
            <param name="accumulate">If it is true, the histogram is not cleared in the beginning. This feature allows user to compute a single histogram from several images, or to update the histogram online. </param>
            <param name="mask">Can be null if not needed. The operation mask, determines what pixels of the source images are counted</param>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.Calculate``1(Emgu.CV.Matrix{``0}[],System.Boolean,Emgu.CV.Matrix{System.Byte})">
            <summary>
            Project the matrices to the histogram bins 
            </summary>
            <typeparam name="TDepth">The type of depth of the image</typeparam>
            <param name="matrices">Matrices to project</param>
            <param name="accumulate">If it is true, the histogram is not cleared in the beginning. This feature allows user to compute a single histogram from several images, or to update the histogram online. </param>
            <param name="mask">Can be null if not needed. The operation mask, determines what pixels of the source images are counted</param>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.BackProject``1(Emgu.CV.Image{Emgu.CV.Structure.Gray,``0}[])">
            <summary> 
             Backproject the histogram into a gray scale image
            </summary>
            <param name="srcs">Source images, all are of the same size and type</param>
            <returns>Destination back projection image of the same type as the source images</returns>
            <typeparam name="TDepth">The type of depth of the image</typeparam>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.BackProject``1(Emgu.CV.Matrix{``0}[])">
            <summary> 
             Backproject the histogram into a matrix
            </summary>
            <param name="srcs">Source matrices, all are of the same size and type</param>
            <returns>Destination back projection matrix of the sametype as the source matrices</returns>
            <typeparam name="TDepth">The type of depth of the matrix</typeparam>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.GetBinValues">
            <summary>
            Gets the bin values.
            </summary>
            <returns>The bin values</returns>
        </member>
        <member name="P:Emgu.CV.DenseHistogram.BinDimension">
            <summary>
            Get the size of the bin dimensions
            </summary>
        </member>
        <member name="P:Emgu.CV.DenseHistogram.Ranges">
            <summary>
            Get the ranges of this histogram
            </summary>
        </member>
        <member name="T:Emgu.CV.Dnn.DnnInvoke">
            <summary>
            Entry points to the Open CV bioinspired module
            </summary>
        </member>
        <member name="M:Emgu.CV.Dnn.DnnInvoke.BlobFromImage(Emgu.CV.Mat,System.Double,System.Drawing.Size,Emgu.CV.Structure.MCvScalar,System.Boolean)">
            <summary>
            Creates 4-dimensional blob from image. Optionally resizes and crops image from center, subtract mean values, scales values by scalefactor, swap Blue and Red channels.
            </summary>
            <param name="image">Input image (with 1- or 3-channels).</param>
            <param name="scaleFactor">Multiplier for image values.</param>
            <param name="size">Spatial size for output image</param>
            <param name="mean">Scalar with mean values which are subtracted from channels. Values are intended to be in (mean-R, mean-G, mean-B) order if image has BGR ordering and swapRB is true.</param>
            <param name="swapRB">Flag which indicates that swap first and last channels in 3-channel image is necessary.</param>
            <returns>4-dimansional Mat with NCHW dimensions order.</returns>
        </member>
        <member name="M:Emgu.CV.Dnn.DnnInvoke.BlobFromImages(Emgu.CV.Mat[],System.Double,System.Drawing.Size,Emgu.CV.Structure.MCvScalar,System.Boolean)">
            <summary>
            Creates 4-dimensional blob from series of images. Optionally resizes and crops images from center, subtract mean values, scales values by scalefactor, swap Blue and Red channels.
            </summary>
            <param name="images">Input images (all with 1- or 3-channels).</param>
            <param name="scaleFactor">Multiplier for images values.</param>
            <param name="size">Spatial size for output image</param>
            <param name="mean">Scalar with mean values which are subtracted from channels. Values are intended to be in (mean-R, mean-G, mean-B) order if image has BGR ordering and swapRB is true.</param>
            <param name="swapRB">	flag which indicates that swap first and last channels in 3-channel image is necessary.</param>
            <returns>Input image is resized so one side after resize is equal to corresponding dimension in size and another one is equal or larger. Then, crop from the center is performed.</returns>
        </member>
        <member name="M:Emgu.CV.Dnn.DnnInvoke.DnnInitModule">
            <summary>
            Initialize dnn module and built-in layers.
            </summary>
        </member>
        <member name="T:Emgu.CV.Dnn.Importer">
            <summary>
            Small interface class for loading trained serialized models of different dnn-frameworks.
            </summary>
        </member>
        <member name="M:Emgu.CV.Dnn.Importer.CreateCaffeImporter(System.String,System.String)">
            <summary>
            Creates the importer of Caffe framework network.
            </summary>
            <param name="prototxt">path to the .prototxt file with text description of the network architecture.</param>
            <param name="caffeModel">path to the .caffemodel file with learned network.</param>
            <returns>The created importer, NULL in failure cases.</returns>
        </member>
        <member name="M:Emgu.CV.Dnn.Importer.CreateTensorflowImporter(System.String)">
            <summary>
            Creates the importer of TensorFlow framework network.
            </summary>
            <param name="model">Path to the .pb file with binary protobuf description of the network architecture.</param>
            <returns>The created importer, NULL in failure cases.</returns>
        </member>
        <member name="M:Emgu.CV.Dnn.Importer.PopulateNet(Emgu.CV.Dnn.Net)">
            <summary>
            Adds loaded layers into the <paramref name="net"/> and sets connetions between them.
            </summary>
            <param name="net">The net model</param>
        </member>
        <member name="M:Emgu.CV.Dnn.Importer.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this Importer
            </summary>
        </member>
        <member name="T:Emgu.CV.Dnn.Net">
            <summary>
            This class allows to create and manipulate comprehensive artificial neural networks.
            </summary>
        </member>
        <member name="M:Emgu.CV.Dnn.Net.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Emgu.CV.Dnn.Net.SetInput(Emgu.CV.Mat,System.String)">
            <summary>
            Sets the new value for the layer output blob.
            </summary>
            <param name="name">Descriptor of the updating layer output blob.</param>
            <param name="blob">Input blob</param>
        </member>
        <member name="M:Emgu.CV.Dnn.Net.Forward(System.String)">
            <summary>
            Runs forward pass for the whole network.
            </summary>
            <param name="outputName">name for layer which output is needed to get</param>
            <returns>blob for first output of specified layer</returns>
        </member>
        <member name="M:Emgu.CV.Dnn.Net.DisposeObject">
            <summary>
            Release the memory associated with this network.
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.AKAZE">
            <summary>
            Wrapped AKAZE detector
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.Feature2D">
            <summary>
            The feature 2D base class
            </summary>
        </member>
        <member name="T:Emgu.CV.IAlgorithm">
            <summary>
            This is the algorithm class
            </summary>
        </member>
        <member name="P:Emgu.CV.IAlgorithm.AlgorithmPtr">
            <summary>
            Return the pointer to the algorithm object
            </summary>
            <returns>The pointer to the algorithm object</returns>
        </member>
        <member name="F:Emgu.CV.Features2D.Feature2D._feature2D">
            <summary>
            The pointer to the Feature2D object
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.Feature2D._algorithm">
            <summary>
            The pointer to the Algorithm object.
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.Feature2D.DetectAndCompute(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.IOutputArray,System.Boolean)">
            <summary>
            Detect keypoints in an image and compute the descriptors on the image from the keypoint locations.
            </summary>
            <param name="image">The image</param>
            <param name="mask">The optional mask, can be null if not needed</param>
            <param name="keyPoints">The detected keypoints will be stored in this vector</param>
            <param name="descriptors">The descriptors from the keypoints</param>
            <param name="useProvidedKeyPoints">If true, the method will skip the detection phase and will compute descriptors for the provided keypoints</param>
        </member>
        <member name="M:Emgu.CV.Features2D.Feature2D.DisposeObject">
            <summary>
            Reset the pointers
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.Feature2D.DetectRaw(Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.IInputArray)">
            <summary>
            Detect the features in the image
            </summary>
            <param name="keypoints">The result vector of keypoints</param>
            <param name="image">The image from which the features will be detected from</param>
            <param name="mask">The optional mask.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.Feature2D.Detect(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Detect the keypoints from the image
            </summary>
            <param name="image">The image to extract keypoints from</param>
            <param name="mask">The optional mask.</param>
            <returns>An array of key points</returns>
        </member>
        <member name="M:Emgu.CV.Features2D.Feature2D.Compute(Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.IOutputArray)">
            <summary>
            Compute the descriptors on the image from the given keypoint locations.
            </summary>
            <param name="image">The image to compute descriptors from</param>
            <param name="keyPoints">The keypoints where the descriptor computation is perfromed</param>
            <param name="descriptors">The descriptors from the given keypoints</param>
        </member>
        <member name="P:Emgu.CV.Features2D.Feature2D.Feature2DPtr">
            <summary>
            Get the pointer to the Feature2D object
            </summary>
            <returns>The pointer to the Feature2D object</returns>
        </member>
        <member name="P:Emgu.CV.Features2D.Feature2D.DescriptorSize">
            <summary>
            Get the number of elements in the descriptor.
            </summary>
            <returns>The number of elements in the descriptor</returns>
        </member>
        <member name="M:Emgu.CV.Features2D.AKAZE.#ctor(Emgu.CV.Features2D.AKAZE.DescriptorType,System.Int32,System.Int32,System.Single,System.Int32,System.Int32,Emgu.CV.Features2D.KAZE.Diffusivity)">
            <summary>
            Create AKAZE using the specific values
            </summary>
            <param name="descriptorType">Type of the extracted descriptor</param>
            <param name="descriptorSize">Size of the descriptor in bits. 0 -> Full size</param>
            <param name="descriptorChannels">Number of channels in the descriptor (1, 2, 3)</param>
            <param name="threshold">Detector response threshold to accept point</param>
            <param name="nOctaveLayers"> Default number of sublevels per scale level</param>
            <param name="nOctaves">Maximum octave evolution of the image</param>
            <param name="diffusivity">Diffusivity type</param>
        </member>
        <member name="M:Emgu.CV.Features2D.AKAZE.DisposeObject">
            <summary>
            Release the unmanaged resources associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.AKAZE.DescriptorType">
            <summary>
            Type of the extracted descriptor
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.AKAZE.DescriptorType.KazeUpright">
            <summary>
            The kaze upright
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.AKAZE.DescriptorType.Kaze">
            <summary>
            The kaze
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.AKAZE.DescriptorType.MldbUpright">
            <summary>
            Modified-Local Difference Binary (M-LDB), upright
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.AKAZE.DescriptorType.Mldb">
            <summary>
            Modified-Local Difference Binary (M-LDB)
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.AgastFeatureDetector">
            <summary>
            Wrapped AGAST detector
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.AgastFeatureDetector.#ctor(System.Int32,System.Boolean,Emgu.CV.Features2D.AgastFeatureDetector.Type)">
            <summary>
            Create AGAST using the specific values
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.AgastFeatureDetector.DisposeObject">
            <summary>
            Release the unmanaged resources associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.AgastFeatureDetector.Type">
            <summary>
            Agast feature type
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.AgastFeatureDetector.Type.AGAST_5_8">
            <summary>
            AGAST_5_8
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.AgastFeatureDetector.Type.AGAST_7_12d">
            <summary>
            AGAST_7_12d
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.AgastFeatureDetector.Type.AGAST_7_12s">
            <summary>
            AGAST_7_12s
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.AgastFeatureDetector.Type.OAST_9_16">
            <summary>
            OAST_9_16
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.DistanceType">
            <summary>
            The match distance type
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.DistanceType.Inf">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.DistanceType.L1">
            <summary>
            Manhattan distance (city block distance)
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.DistanceType.L2">
            <summary>
            Squared Euclidean distance
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.DistanceType.L2Sqr">
            <summary>
            Euclidean distance
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.DistanceType.Hamming">
            <summary>
            Hamming distance functor - counts the bit differences between two strings - useful for the Brief descriptor, 
            bit count of A exclusive XOR'ed with B. 
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.DistanceType.Hamming2">
            <summary>
            Hamming distance functor - counts the bit differences between two strings - useful for the Brief descriptor, 
            bit count of A exclusive XOR'ed with B. 
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.BFMatcher">
            <summary>
            Wrapped BFMatcher
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.DescriptorMatcher">
            <summary>
            Descriptor matcher
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.DescriptorMatcher._descriptorMatcherPtr">
            <summary>
            The pointer to the Descriptor matcher
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.DescriptorMatcher.KnnMatch(Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfVectorOfDMatch,System.Int32,Emgu.CV.IInputArray)">
            <summary>
            Find the k-nearest match
            </summary>
            <param name="queryDescriptor">An n x m matrix of descriptors to be query for nearest neighbours. n is the number of descriptor and m is the size of the descriptor</param>
            <param name="k">Number of nearest neighbors to search for</param>
            <param name="mask">Can be null if not needed. An n x 1 matrix. If 0, the query descriptor in the corresponding row will be ignored.</param>
            <param name="matches">Matches. Each matches[i] is k or less matches for the same query descriptor.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.DescriptorMatcher.Add(Emgu.CV.IInputArray)">
            <summary>
            Add the model descriptors
            </summary>
            <param name="modelDescriptors">The model descriptors</param>
        </member>
        <member name="M:Emgu.CV.Features2D.DescriptorMatcher.DisposeObject">
            <summary>
            Reset the native pointer upon object disposal
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.BFMatcher.#ctor(Emgu.CV.Features2D.DistanceType,System.Boolean)">
            <summary>
            Create a BFMatcher of the specific distance type
            </summary>
            <param name="distanceType">The distance type</param>
            <param name="crossCheck">Specify whether or not cross check is needed. Use false for default.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.BFMatcher.DisposeObject">
            <summary>
            Release the unmanaged resource associated with the BFMatcher
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.BOWImgDescriptorExtractor">
            <summary>
            Class to compute an image descriptor using the bag of visual words. Such a computation consists of the following
            steps:
            1. Compute descriptors for a given image and its key points set.
            2. Find the nearest visual words from the vocabulary for each key point descriptor.
            3. Compute the bag-of-words image descriptor as is a normalized histogram of vocabulary words encountered in
            the image. The i-th bin of the histogram is a frequency of i-th word of the vocabulary in the given image.
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.BOWImgDescriptorExtractor.#ctor(Emgu.CV.Features2D.Feature2D,Emgu.CV.Features2D.DescriptorMatcher)">
            <summary>
            
            </summary>
            <param name="descriptorExtractor">Descriptor extractor that is used to compute descriptors for an input image and its key points.</param>
            <param name="descriptorMatcher">Descriptor matcher that is used to find the nearest word of the trained vocabulary for each key point descriptor of the image.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.BOWImgDescriptorExtractor.SetVocabulary(Emgu.CV.Mat)">
            <summary>
            Sets a visual vocabulary.
            </summary>
            <param name="vocabulary">The vocabulary</param>
        </member>
        <member name="M:Emgu.CV.Features2D.BOWImgDescriptorExtractor.Compute(Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.Mat)">
            <summary>
            Computes an image descriptor using the set visual vocabulary.
            </summary>
            <param name="image">Image, for which the descriptor is computed</param>
            <param name="keypoints">Key points detected in the input image.</param>
            <param name="imgDescriptors">The output image descriptors.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.BOWImgDescriptorExtractor.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.BOWKMeansTrainer">
            <summary>
            Kmeans-based class to train visual vocabulary using the bag of visual words approach.
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.BOWKMeansTrainer.#ctor(System.Int32,Emgu.CV.Structure.MCvTermCriteria,System.Int32,Emgu.CV.CvEnum.KMeansInitType)">
            <summary>
            Create a new BOWKmeans trainer
            </summary>
            <param name="clusterCount">Number of clusters to split the set by.</param>
            <param name="termcrit">Specifies maximum number of iterations and/or accuracy (distance the centers move by between the subsequent iterations). Use empty termcrit for default.</param>
            <param name="attempts">The number of attemps. Use 3 for default</param>
            <param name="flags">Kmeans initialization flag. Use PPCenters for default.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.BOWKMeansTrainer.Add(Emgu.CV.Mat)">
            <summary>
            Add the descriptors to the trainer
            </summary>
            <param name="descriptors">The descriptors to be added to the trainer</param>
        </member>
        <member name="M:Emgu.CV.Features2D.BOWKMeansTrainer.Cluster(Emgu.CV.IOutputArray)">
            <summary>
            Cluster the descriptors and return the cluster centers
            </summary>
            <returns>The cluster centers</returns>
        </member>
        <member name="M:Emgu.CV.Features2D.BOWKMeansTrainer.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this object
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.BOWKMeansTrainer.DescriptorCount">
            <summary>
            Get the number of descriptors
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.Brisk">
            <summary>
            BRISK: Binary Robust Invariant Scalable Keypoints
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.Brisk.#ctor(System.Int32,System.Int32,System.Single)">
            <summary>
            Create a BRISK keypoint detector and descriptor extractor.
            </summary>
            <param name="thresh">Feature parameters.</param>
            <param name="octaves">The number of octave layers.</param>
            <param name="patternScale">Pattern scale</param>
        </member>
        <member name="M:Emgu.CV.Features2D.Brisk.DisposeObject">
            <summary>
            Release the unmanaged resources associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.FastDetector">
            <summary>
            FAST(Features from Accelerated Segment Test) keypoint detector. 
            See Detects corners using FAST algorithm by E. Rosten ("Machine learning for high-speed corner
            detection, 2006).
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.FastDetector.#ctor(System.Int32,System.Boolean,Emgu.CV.Features2D.FastDetector.DetectorType)">
            <summary>
            Create a fast detector with the specific parameters
            </summary>
            <param name="threshold">Threshold on difference between intensity of center pixel and pixels on circle around
            this pixel.</param>
            <param name="nonmaxSupression">Specify if non-maximum suppression should be used.</param>
            <param name="type">One of the three neighborhoods as defined in the paper</param>
        </member>
        <member name="M:Emgu.CV.Features2D.FastDetector.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this detector.
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.FastDetector.DetectorType">
            <summary>
            One of the three neighborhoods as defined in the paper
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.FastDetector.DetectorType.Type5_8">
            <summary>
            The type5_8
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.FastDetector.DetectorType.Type7_12">
            <summary>
            The type7_12
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.FastDetector.DetectorType.Type9_16">
            <summary>
            The type9_16
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.Features2DInvoke">
            <summary>
            Library to invoke Features2D functions
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.Features2DToolbox">
            <summary>
            Tools for features 2D
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.Features2DToolbox.DrawKeypoints(Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.IInputOutputArray,Emgu.CV.Structure.Bgr,Emgu.CV.Features2D.Features2DToolbox.KeypointDrawType)">
            <summary>
            Draw the keypoints found on the image.
            </summary>
            <param name="image">The image</param>
            <param name="keypoints">The keypoints to be drawn</param>
            <param name="color">The color used to draw the keypoints</param>
            <param name="type">The drawing type</param>
            <param name="outImage">The image with the keypoints drawn</param> 
        </member>
        <member name="M:Emgu.CV.Features2D.Features2DToolbox.DrawMatches(Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.Util.VectorOfVectorOfDMatch,Emgu.CV.IInputOutputArray,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar,Emgu.CV.IInputArray,Emgu.CV.Features2D.Features2DToolbox.KeypointDrawType)">
            <summary>
            Draw the matched keypoints between the model image and the observered image.
            </summary>
            <param name="modelImage">The model image</param>
            <param name="modelKeypoints">The keypoints in the model image</param>
            <param name="observerdImage">The observed image</param>
            <param name="observedKeyPoints">The keypoints in the observed image</param>
            <param name="matchColor">The color for the match correspondence lines</param>
            <param name="singlePointColor">The color for highlighting the keypoints</param>
            <param name="mask">The mask for the matches. Use null for all matches.</param>
            <param name="flags">The drawing type</param>
            <param name="result">The image where model and observed image is displayed side by side. Matches are drawn as indicated by the flag</param>
            <param name="matches">Matches. Each matches[i] is k or less matches for the same query descriptor.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.Features2DToolbox.VoteForSizeAndOrientation(Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.Util.VectorOfVectorOfDMatch,Emgu.CV.Mat,System.Double,System.Int32)">
            <summary>
            Eliminate the matched features whose scale and rotation do not aggree with the majority's scale and rotation.
            </summary>
            <param name="rotationBins">The numbers of bins for rotation, a good value might be 20 (which means each bin covers 18 degree)</param>
            <param name="scaleIncrement">This determines the different in scale for neighbor hood bins, a good value might be 1.5 (which means matched features in bin i+1 is scaled 1.5 times larger than matched features in bin i</param>
            <param name="modelKeyPoints">The keypoints from the model image</param>
            <param name="observedKeyPoints">The keypoints from the observed image</param>
            <param name="mask">This is both input and output. This matrix indicates which row is valid for the matches.</param>
            <param name="matches">Matches. Each matches[i] is k or less matches for the same query descriptor.</param>
            <returns> The number of non-zero elements in the resulting mask</returns>
        </member>
        <member name="M:Emgu.CV.Features2D.Features2DToolbox.GetHomographyMatrixFromMatchedFeatures(Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.Util.VectorOfVectorOfDMatch,Emgu.CV.Mat,System.Double)">
            <summary>
            Recover the homography matrix using RANDSAC. If the matrix cannot be recovered, null is returned.
            </summary>
            <param name="model">The model keypoints</param>
            <param name="observed">The observed keypoints</param>
            <param name="ransacReprojThreshold">
            The maximum allowed reprojection error to treat a point pair as an inlier. 
            If srcPoints and dstPoints are measured in pixels, it usually makes sense to set this parameter somewhere in the range 1 to 10.
            </param>
            <param name="mask">
            The mask matrix of which the value might be modified by the function. 
            As input, if the value is 0, the corresponding match will be ignored when computing the homography matrix. 
            If the value is 1 and RANSAC determine the match is an outlier, the value will be set to 0.
            </param>
            <returns>The homography matrix, if it cannot be found, null is returned</returns>
            <param name="matches">Matches. Each matches[i] is k or less matches for the same query descriptor.</param>
        </member>
        <member name="M:Emgu.CV.Features2D.Features2DToolbox.VoteForUniqueness(Emgu.CV.Util.VectorOfVectorOfDMatch,System.Double,Emgu.CV.Mat)">
            <summary>
            Filter the matched Features, such that if a match is not unique, it is rejected.
            </summary>
            <param name="uniquenessThreshold">The distance different ratio which a match is consider unique, a good number will be 0.8</param>
            <param name="mask">This is both input and output. This matrix indicates which row is valid for the matches.</param>
            <param name="matches">Matches. Each matches[i] is k or less matches for the same query descriptor.</param> 
        </member>
        <member name="T:Emgu.CV.Features2D.Features2DToolbox.KeypointDrawType">
            <summary>
            Define the Keypoint draw type
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.Features2DToolbox.KeypointDrawType.Default">
            <summary>
            Two source image, matches and single keypoints will be drawn.
            For each keypoint only the center point will be drawn (without
            the circle around keypoint with keypoint size and orientation).
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.Features2DToolbox.KeypointDrawType.NotDrawSinglePoints">
            <summary>
            Single keypoints will not be drawn.
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.Features2DToolbox.KeypointDrawType.DrawRichKeypoints">
            <summary>
            For each keypoint the circle around keypoint with keypoint size and
            orientation will be drawn.
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.FlannBasedMatcher">
            <summary>
            This matcher trains flann::Index_ on a train descriptor collection and calls its nearest search methods to find the best matches. So, this matcher may be faster when matching a large train collection than the brute force matcher. 
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.FlannBasedMatcher.#ctor(Emgu.CV.Flann.IIndexParams,Emgu.CV.Flann.SearchParams)">
            <summary>
            Create a Flann based matcher.
            </summary>
            <param name="indexParams">The type of index parameters</param>
            <param name="search">The search parameters</param>
        </member>
        <member name="M:Emgu.CV.Features2D.FlannBasedMatcher.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this Flann based matcher.
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.GFTTDetector">
            <summary>
             Wrapping class for feature detection using the goodFeaturesToTrack() function.
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.GFTTDetector.#ctor(System.Int32,System.Double,System.Double,System.Int32,System.Boolean,System.Double)">
            <summary>
            Create a Good Feature to Track detector
            </summary>
            <remarks>The function first calculates the minimal eigenvalue for every source image pixel using cvCornerMinEigenVal function and stores them in eig_image. Then it performs non-maxima suppression (only local maxima in 3x3 neighborhood remain). The next step is rejecting the corners with the minimal eigenvalue less than quality_level?max(eig_image(x,y)). Finally, the function ensures that all the corners found are distanced enough one from another by considering the corners (the most strongest corners are considered first) and checking that the distance between the newly considered feature and the features considered earlier is larger than min_distance. So, the function removes the features than are too close to the stronger features</remarks>
            <param name="maxCorners">The maximum number of features to be detected.</param>
            <param name="qualityLevel">Multiplier for the maxmin eigenvalue; specifies minimal accepted quality of image corners.</param>
            <param name="minDistance">Limit, specifying minimum possible distance between returned corners; Euclidian distance is used.</param>
            <param name="blockSize">Size of the averaging block, passed to underlying cvCornerMinEigenVal or cvCornerHarris used by the function.</param>
            <param name="useHarrisDetector">If true, will use Harris corner detector.</param>
            <param name="k">K</param>
        </member>
        <member name="M:Emgu.CV.Features2D.GFTTDetector.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this detector.
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.KAZE">
            <summary>
            Wrapped KAZE detector
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.KAZE.#ctor(System.Boolean,System.Boolean,System.Single,System.Int32,System.Int32,Emgu.CV.Features2D.KAZE.Diffusivity)">
            <summary>
            Create KAZE using the specific values
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.KAZE.DisposeObject">
            <summary>
            Release the unmanaged resources associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.KAZE.Diffusivity">
            <summary>
            The diffusivity
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.KAZE.Diffusivity.PmG1">
            <summary>
            PM G1
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.KAZE.Diffusivity.PmG2">
            <summary>
            PM G2
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.KAZE.Diffusivity.Weickert">
            <summary>
            Weickert
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.KAZE.Diffusivity.Charbonnier">
            <summary>
            Charbonnier
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.MSERDetector">
            <summary>
            MSER detector
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.MSERDetector.#ctor(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Int32,System.Double,System.Double,System.Int32)">
            <summary>
            Create a MSER detector using the specific parameters
            </summary>
            <param name="delta">In the code, it compares (size_{i}-size_{i-delta})/size_{i-delta}</param>
            <param name="maxArea">Prune the area which bigger than max_area</param>
            <param name="minArea">Prune the area which smaller than min_area</param>
            <param name="maxVariation">Prune the area have similar size to its children</param>
            <param name="minDiversity">Trace back to cut off mser with diversity &lt; min_diversity</param>
            <param name="maxEvolution">For color image, the evolution steps</param>
            <param name="areaThreshold">The area threshold to cause re-initialize</param>
            <param name="minMargin">Ignore too small margin</param>
            <param name="edgeBlurSize">The aperture size for edge blur</param>
        </member>
        <member name="M:Emgu.CV.Features2D.MSERDetector.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this detector.
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.MSERDetector.DetectRegions(Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfVectorOfPoint,Emgu.CV.Util.VectorOfRect)">
            <summary>
            Detect MSER regions
            </summary>
            <param name="image">input image (8UC1, 8UC3 or 8UC4, must be greater or equal than 3x3)</param>
            <param name="msers">resulting list of point sets</param>
            <param name="bboxes">resulting bounding boxes</param>
        </member>
        <member name="T:Emgu.CV.Features2D.ORBDetector">
            <summary>
            Wrapped ORB detector
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.ORBDetector.#ctor(System.Int32,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,Emgu.CV.Features2D.ORBDetector.ScoreType,System.Int32,System.Int32)">
            <summary>
            Create a ORBDetector using the specific values
            </summary>
            <param name="numberOfFeatures">The number of desired features. </param>
            <param name="scaleFactor">Coefficient by which we divide the dimensions from one scale pyramid level to the next.</param>
            <param name="nLevels">The number of levels in the scale pyramid. </param>
            <param name="firstLevel">The level at which the image is given. If 1, that means we will also look at the image.<paramref name="scaleFactor"/> times bigger</param>
            <param name="edgeThreshold">How far from the boundary the points should be.</param>
            <param name="WTK_A">How many random points are used to produce each cell of the descriptor (2, 3, 4 ...).</param>
            <param name="scoreType">Type of the score to use.</param>
            <param name="patchSize">Patch size.</param>
            <param name="fastThreshold">FAST threshold</param>
        </member>
        <member name="M:Emgu.CV.Features2D.ORBDetector.DisposeObject">
            <summary>
            Release the unmanaged resources associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.ORBDetector.ScoreType">
            <summary>
            The score type
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.ORBDetector.ScoreType.Harris">
            <summary>
            Harris
            </summary>
        </member>
        <member name="F:Emgu.CV.Features2D.ORBDetector.ScoreType.Fast">
            <summary>
            Fast
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.SimpleBlobDetector">
            <summary>
            Simple Blob detector
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.SimpleBlobDetector.#ctor(Emgu.CV.Features2D.SimpleBlobDetectorParams)">
            <summary>
            Create a simple blob detector
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.SimpleBlobDetector.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this detector.
            </summary>
        </member>
        <member name="T:Emgu.CV.Features2D.SimpleBlobDetectorParams">
            <summary>
            Parameters for the simple blob detector
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.SimpleBlobDetectorParams.#ctor">
            <summary>
            Create parameters for simple blob detector and use default values.
            </summary>
        </member>
        <member name="M:Emgu.CV.Features2D.SimpleBlobDetectorParams.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this simple blob detector parameter.
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.ThresholdStep">
            <summary>
            Threshold step
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.MinThreshold">
            <summary>
            Min threshold
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.MaxThreshold">
            <summary>
            Max threshold
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.MinDistBetweenBlobs">
            <summary>
            Min dist between blobs
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.FilterByColor">
            <summary>
            Filter by color
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.blobColor">
            <summary>
            Blob color
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.FilterByArea">
            <summary>
            Filter by area
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.MinArea">
            <summary>
            Min area
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.MaxArea">
            <summary>
            Max area
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.FilterByCircularity">
            <summary>
            Filter by circularity
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.MinCircularity">
            <summary>
            Min circularity
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.MaxCircularity">
            <summary>
            Max circularity
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.FilterByInertia">
            <summary>
            Filter by inertia
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.MinInertiaRatio">
            <summary>
            Min inertia ratio
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.MaxInertiaRatio">
            <summary>
            Max inertia ratio
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.FilterByConvexity">
            <summary>
            Filter by convexity
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.MinConvexity">
            <summary>
            Min Convexity
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.MaxConvexity">
            <summary>
            Max Convexity
            </summary>
        </member>
        <member name="P:Emgu.CV.Features2D.SimpleBlobDetectorParams.MinRepeatability">
            <summary>
            Min Repeatability
            </summary>
        </member>
        <member name="T:Emgu.CV.FileNode">
            <summary>
            File Storage Node class.
            The node is used to store each and every element of the file storage opened for reading. When
            XML/YAML file is read, it is first parsed and stored in the memory as a hierarchical collection of
            nodes. Each node can be a leaf that is contain a single number or a string, or be a collection of
            other nodes. There can be named collections (mappings) where each element has a name and it is
            accessed by a name, and ordered collections (sequences) where elements do not have names but rather
            accessed by index. Type of the file node can be determined using FileNode::type method.
            Note that file nodes are only used for navigating file storages opened for reading. When a file
            storage is opened for writing, no data is stored in memory after it is written.
            </summary>
        </member>
        <member name="M:Emgu.CV.FileNode.ReadMat(Emgu.CV.Mat,Emgu.CV.Mat)">
            <summary>
            Reads a Mat from the node
            </summary>
            <param name="mat">The Mat where the result is read into</param>
            <param name="defaultMat">The default mat.</param>
        </member>
        <member name="M:Emgu.CV.FileNode.DisposeObject">
            <summary>
            Release the unmanaged resources
            </summary>
        </member>
        <member name="M:Emgu.CV.FileNode.ReadString(System.String)">
            <summary>
            Reads the string from the node
            </summary>
            <returns>The string from the node</returns>
        </member>
        <member name="M:Emgu.CV.FileNode.ReadInt(System.Int32)">
            <summary>
            Reads the int from the node.
            </summary>
            <returns>The int from the node.</returns>
        </member>
        <member name="M:Emgu.CV.FileNode.ReadFloat(System.Single)">
            <summary>
            Reads the float from the node.
            </summary>
            <returns>The float from the node.</returns>
        </member>
        <member name="M:Emgu.CV.FileNode.ReadDouble(System.Double)">
            <summary>
            Reads the double from the node.
            </summary>
            <returns>The double from the node.</returns>
        </member>
        <member name="P:Emgu.CV.FileNode.IsEmpty">
            <summary>
            Gets a value indicating whether this instance is empty.
            </summary>
            <value>
              <c>true</c> if this instance is empty; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Emgu.CV.FileNode.NodeType">
            <summary>
            Gets the type of the node.
            </summary>
            <value>
            The type of the node.
            </value>
        </member>
        <member name="T:Emgu.CV.FileNode.Type">
            <summary>
            Type of the file storage node
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.None">
            <summary>
            Empty node
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.Int">
            <summary>
              an integer
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.Real">
            <summary>
            Floating-point number
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.Float">
            <summary>
            Synonym or Real
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.Str">
            <summary>
            Text string in UTF-8 encoding
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.String">
            <summary>
            Synonym for Str
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.Ref">
            <summary>
            Integer of size size_t. Typically used for storing complex dynamic structures where some elements reference the others
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.Seq">
            <summary>
            The sequence
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.Map">
            <summary>
            Mapping
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.TypeMask">
            <summary>
            The type mask
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.Flow">
            <summary>
            Compact representation of a sequence or mapping. Used only by YAML writer
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.User">
            <summary>
            A registered object (e.g. a matrix)
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.Empty">
            <summary>
            Empty structure (sequence or mapping)
            </summary>
        </member>
        <member name="F:Emgu.CV.FileNode.Type.Named">
            <summary>
            The node has a name (i.e. it is element of a mapping)
            </summary>
        </member>
        <member name="T:Emgu.CV.FileStorage">
            <summary>
            XML/YAML file storage class that encapsulates all the information necessary for writing or reading data to/from a file.
            </summary>
        </member>
        <member name="M:Emgu.CV.FileStorage.#ctor(System.String,Emgu.CV.FileStorage.Mode,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Emgu.CV.FileStorage"/> class.
            </summary>
            <param name="source">Name of the file to open or the text string to read the data from. Extension of the
            file (.xml or .yml/.yaml) determines its format (XML or YAML respectively). Also you can append .gz
            to work with compressed files, for example myHugeMatrix.xml.gz. If both FileStorage::WRITE and
            FileStorage::MEMORY flags are specified, source is used just to specify the output file format (e.g.
            mydata.xml, .yml etc.).</param>
            <param name="flags">Mode of operation.</param>
            <param name="encoding">Encoding of the file. Note that UTF-16 XML encoding is not supported currently and
            you should use 8-bit encoding instead of it.</param>
        </member>
        <member name="M:Emgu.CV.FileStorage.Write(Emgu.CV.Mat,System.String)">
            <summary>
            Writes the specified Mat to the node with the specific <param Name="nodeName"></param>
            </summary>
            <param name="m">The Mat to be written to the file storage</param>
            <param name="nodeName">The name of the node.</param>
        </member>
        <member name="M:Emgu.CV.FileStorage.Write(System.Int32,System.String)">
            <summary>
            Writes the specified Mat to the node with the specific <param Name="nodeName"></param>
            </summary>
            <param name="value">The value to be written to the file storage</param>
            <param name="nodeName">The name of the node.</param>
        </member>
        <member name="M:Emgu.CV.FileStorage.Write(System.Single,System.String)">
            <summary>
            Writes the specified Mat to the node with the specific <param Name="nodeName"></param>
            </summary>
            <param name="value">The value to be written to the file storage</param>
            <param name="nodeName">The name of the node.</param>
        </member>
        <member name="M:Emgu.CV.FileStorage.Write(System.Double,System.String)">
            <summary>
            Writes the specified Mat to the node with the specific <param Name="nodeName"></param>
            </summary>
            <param name="value">The value to be written to the file storage</param>
            <param name="nodeName">The name of the node.</param>
        </member>
        <member name="M:Emgu.CV.FileStorage.Write(System.String,System.String)">
            <summary>
            Writes the specified Mat to the node with the specific <param Name="nodeName"></param>
            </summary>
            <param name="value">The value to be written to the file storage</param>
            <param name="nodeName">The name of the node.</param>
        </member>
        <member name="M:Emgu.CV.FileStorage.ReleaseAndGetString">
            <summary>
            Closes the file and releases all the memory buffers
            Call this method after all I/O operations with the storage are finished. If the storage was
            opened for writing data and FileStorage.Mode.Write was specified
            </summary>
            <returns>The string that represent the text in the FileStorage</returns>
        </member>
        <member name="M:Emgu.CV.FileStorage.GetRoot(System.Int32)">
            <summary>
            Gets the top-level mapping.
            </summary>
            <param name="streamIdx">Zero-based index of the stream. In most cases there is only one stream in the file.
            However, YAML supports multiple streams and so there can be several.</param>
            <returns> The top-level mapping</returns>
        </member>
        <member name="M:Emgu.CV.FileStorage.GetFirstTopLevelNode">
            <summary>
            Gets the first element of the top-level mapping.
            </summary>
            <returns>The first element of the top-level mapping.</returns>
        </member>
        <member name="M:Emgu.CV.FileStorage.GetNode(System.String)">
            <summary>
            Gets the specified element of the top-level mapping.
            </summary>
            <param name="nodeName">Name of the node.</param>
            <returns>The specified element of the top-level mapping.</returns>
        </member>
        <member name="M:Emgu.CV.FileStorage.DisposeObject">
            <summary>
            Release the unmanaged resources
            </summary>
        </member>
        <member name="P:Emgu.CV.FileStorage.IsOpened">
            <summary>
            Gets a value indicating whether this instance is opened.
            </summary>
            <value>
              <c>true</c> if the object is associated with the current file; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Emgu.CV.FileStorage.Item(System.String)">
            <summary>
            Gets the <see cref="T:Emgu.CV.FileNode"/> with the specified node name.
            </summary>
            <value>
            The <see cref="T:Emgu.CV.FileNode"/>.
            </value>
            <param name="nodeName">Name of the node.</param>
            <returns></returns>
        </member>
        <member name="T:Emgu.CV.FileStorage.Mode">
            <summary>
            File storage mode
            </summary>
        </member>
        <member name="F:Emgu.CV.FileStorage.Mode.Read">
            <summary>
            Open the file for reading
            </summary>
        </member>
        <member name="F:Emgu.CV.FileStorage.Mode.Write">
            <summary>
            Open the file for writing
            </summary>
        </member>
        <member name="F:Emgu.CV.FileStorage.Mode.Append">
            <summary>
            Open the file for appending
            </summary>
        </member>
        <member name="F:Emgu.CV.FileStorage.Mode.Memory">
            <summary>
            ReadMat data from source or write data to the internal buffer
            </summary>
        </member>
        <member name="F:Emgu.CV.FileStorage.Mode.FormatMask">
            <summary>
            Mask for format flags
            </summary>
        </member>
        <member name="F:Emgu.CV.FileStorage.Mode.FormatAuto">
            <summary>
            Auto format
            </summary>
        </member>
        <member name="F:Emgu.CV.FileStorage.Mode.FormatXml">
            <summary>
            XML format
            </summary>
        </member>
        <member name="F:Emgu.CV.FileStorage.Mode.FormatYaml">
            <summary>
            YAML format
            </summary>
        </member>
        <member name="F:Emgu.CV.FileStorage.Mode.FormatJson">
            <summary>
            JSON format
            </summary>
        </member>
        <member name="F:Emgu.CV.FileStorage.Mode.Base64">
            <summary>
            Write rawdata in Base64 by default. (consider using WriteBase64)
            </summary>
        </member>
        <member name="F:Emgu.CV.FileStorage.Mode.WriteBase64">
            <summary>
            enable both Write and Base64
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.CenterInitType">
            <summary>
            The Kmeans center initiation types
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.CenterInitType.Random">
            <summary>
            Random
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.CenterInitType.Gonzales">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.CenterInitType.Kmeanspp">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.IIndexParams">
            <summary>
            The index parameters interface
            </summary>
        </member>
        <member name="P:Emgu.CV.Flann.IIndexParams.IndexParamPtr">
            <summary>
            Gets the pointer to the index parameter.
            </summary>
            <value>
            The index parameter pointer.
            </value>
        </member>
        <member name="T:Emgu.CV.Flann.Index">
            <summary>
            Flann index
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.Index.#ctor(Emgu.CV.IInputArray,Emgu.CV.Flann.IIndexParams)">
            <summary>
            Create a flann index
            </summary>
            <param name="values">A row by row matrix of descriptors</param>
            <param name="ip">The index parameter</param>
        </member>
        <member name="M:Emgu.CV.Flann.Index.KnnSearch(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Int32,System.Int32)">
            <summary>
            Perform k-nearest-neighbours (KNN) search
            </summary>
            <param name="queries">A row by row matrix of descriptors to be query for nearest neighbours</param>
            <param name="indices">The result of the indices of the k-nearest neighbours</param>
            <param name="squareDistances">The square of the Eculidean distance between the neighbours</param>
            <param name="knn">Number of nearest neighbors to search for</param>
            <param name="checks">The number of times the tree(s) in the index should be recursively traversed. A
            higher value for this parameter would give better search precision, but also take more
            time. If automatic configuration was used when the index was created, the number of
            checks required to achieve the specified precision was also computed, in which case
            this parameter is ignored </param>
        </member>
        <member name="M:Emgu.CV.Flann.Index.RadiusSearch(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Single,System.Int32,System.Int32)">
            <summary>
            Performs a radius nearest neighbor search for multiple query points
            </summary>
            <param name="queries">The query points, one per row</param>
            <param name="indices">Indices of the nearest neighbors found</param>
            <param name="squareDistances">The square of the Eculidean distance between the neighbours</param>
            <param name="radius">The search radius</param>
            <param name="maxResults">The maximum number of results</param>
            <param name="checks">The number of times the tree(s) in the index should be recursively traversed. A
            higher value for this parameter would give better search precision, but also take more
            time. If automatic configuration was used when the index was created, the number of
            checks required to achieve the specified precision was also computed, in which case
            this parameter is ignored </param>
            <returns>The number of points in the search radius</returns>
        </member>
        <member name="M:Emgu.CV.Flann.Index.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this Flann Index
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.Index3D">
            <summary>
            Create index for 3D points
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.Index3D.#ctor(Emgu.CV.Structure.MCvPoint3D32f[],Emgu.CV.Flann.IIndexParams)">
            <summary>
            Create a flann index for 3D points
            </summary>
            <param name="points">The IPosition3D array</param>
            <param name="ip">The index parameters</param>
        </member>
        <member name="M:Emgu.CV.Flann.Index3D.ApproximateNearestNeighbour(Emgu.CV.Structure.MCvPoint3D32f,System.Double@)">
            <summary>
            Find the approximate nearest position in 3D
            </summary>
            <param name="position">The position to start the search from</param>
            <param name="squareDist">The square distance of the nearest neighbour</param>
            <returns>The index with the nearest 3D position</returns>
        </member>
        <member name="M:Emgu.CV.Flann.Index3D.DisposeObject">
            <summary>
            Release the resource used by this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.LinearIndexParams">
            <summary>
            When passing an object of this type, the index will perform a linear, brute-force search.
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.LinearIndexParams.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Emgu.CV.Flann.LinearIndexParams"/> class.
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.LinearIndexParams.DisposeObject">
            <summary>
            Release all the memory associated with this IndexParam
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.KdTreeIndexParams">
            <summary>
            When passing an object of this type the index constructed will consist of a set of randomized kd-trees which will be searched in parallel.
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.KdTreeIndexParams.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Emgu.CV.Flann.KdTreeIndexParams"/> class.
            </summary>
            <param name="trees">The number of parallel kd-trees to use. Good values are in the range [1..16]</param>
        </member>
        <member name="M:Emgu.CV.Flann.KdTreeIndexParams.DisposeObject">
            <summary>
            Release all the memory associated with this IndexParam
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.LshIndexParams">
            <summary>
            When using a parameters object of this type the index created uses multi-probe LSH (by Multi-Probe LSH: Efficient Indexing for High-Dimensional Similarity Search by Qin Lv, William Josephson, Zhe Wang, Moses Charikar, Kai Li., Proceedings of the 33rd International Conference on Very Large Data Bases (VLDB). Vienna, Austria. September 2007)
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.LshIndexParams.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Emgu.CV.Flann.LshIndexParams"/> class.
            </summary>
            <param name="tableNumber">The number of hash tables to use (between 10 and 30 usually).</param>
            <param name="keySize">The size of the hash key in bits (between 10 and 20 usually).</param>
            <param name="multiProbeLevel">The number of bits to shift to check for neighboring buckets (0 is regular LSH, 2 is recommended).</param>
        </member>
        <member name="M:Emgu.CV.Flann.LshIndexParams.DisposeObject">
            <summary>
            Release all the memory associated with this IndexParam
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.KMeansIndexParams">
            <summary>
            When passing an object of this type the index constructed will be a hierarchical k-means tree.
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.KMeansIndexParams.#ctor(System.Int32,System.Int32,Emgu.CV.Flann.CenterInitType,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Emgu.CV.Flann.KMeansIndexParams"/> class.
            </summary>
            <param name="branching">The branching factor to use for the hierarchical k-means tree</param>
            <param name="iterations"> The maximum number of iterations to use in the k-means clustering stage when building the k-means tree. A value of -1 used here means that the k-means clustering should be iterated until convergence</param>
            <param name="centersInit">The algorithm to use for selecting the initial centers when performing a k-means clustering step. The possible values are CENTERS_RANDOM (picks the initial cluster centers randomly), CENTERS_GONZALES (picks the initial centers using Gonzales algorithm) and CENTERS_KMEANSPP (picks the initial centers using the algorithm suggested in arthur_kmeanspp_2007 )</param>
            <param name="cbIndex">This parameter (cluster boundary index) influences the way exploration is performed in the hierarchical kmeans tree. When cb_index is zero the next kmeans domain to be explored is chosen to be the one with the closest center. A value greater then zero also takes into account the size of the domain.</param>
        </member>
        <member name="M:Emgu.CV.Flann.KMeansIndexParams.DisposeObject">
            <summary>
            Release all the memory associated with this IndexParam
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.CompositeIndexParams">
            <summary>
            When using a parameters object of this type the index created combines the randomized kd-trees and the hierarchical k-means tree.
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.CompositeIndexParams.#ctor(System.Int32,System.Int32,System.Int32,Emgu.CV.Flann.CenterInitType,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Emgu.CV.Flann.CompositeIndexParams"/> class.
            </summary>
            <param name="trees">The number of parallel kd-trees to use. Good values are in the range [1..16]</param>
            <param name="branching">The branching factor to use for the hierarchical k-means tree</param>
            <param name="iterations"> The maximum number of iterations to use in the k-means clustering stage when building the k-means tree. A value of -1 used here means that the k-means clustering should be iterated until convergence</param>
            <param name="centersInit">The algorithm to use for selecting the initial centers when performing a k-means clustering step. The possible values are CENTERS_RANDOM (picks the initial cluster centers randomly), CENTERS_GONZALES (picks the initial centers using Gonzales algorithm) and CENTERS_KMEANSPP (picks the initial centers using the algorithm suggested in arthur_kmeanspp_2007 )</param>
            <param name="cbIndex">This parameter (cluster boundary index) influences the way exploration is performed in the hierarchical kmeans tree. When cb_index is zero the next kmeans domain to be explored is chosen to be the one with the closest center. A value greater then zero also takes into account the size of the domain.</param>
        </member>
        <member name="M:Emgu.CV.Flann.CompositeIndexParams.DisposeObject">
            <summary>
            Release all the memory associated with this IndexParam
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.AutotunedIndexParams">
            <summary>
            When passing an object of this type the index created is automatically tuned to offer the best performance, by choosing the optimal index type (randomized kd-trees, hierarchical kmeans, linear) and parameters for the dataset provided.
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.AutotunedIndexParams.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Emgu.CV.Flann.AutotunedIndexParams"/> class.
            </summary>
            <param name="targetPrecision"> Is a number between 0 and 1 specifying the percentage of the approximate nearest-neighbor searches that return the exact nearest-neighbor. Using a higher value for this parameter gives more accurate results, but the search takes longer. The optimum value usually depends on the application.</param>
            <param name="buildWeight">Specifies the importance of the index build time reported to the nearest-neighbor search time. In some applications its acceptable for the index build step to take a long time if the subsequent searches in the index can be performed very fast. In other applications its required that the index be build as fast as possible even if that leads to slightly longer search times.</param>
            <param name="memoryWeight">Is used to specify the trade off between time (index build time and search time) and memory used by the index. A value less than 1 gives more importance to the time spent and a value greater than 1 gives more importance to the memory usage.</param>
            <param name="sampleFraction">Is a number between 0 and 1 indicating what fraction of the dataset to use in the automatic parameter configuration algorithm. Running the algorithm on the full dataset gives the most accurate results, but for very large datasets can take longer than desired. In such case using just a fraction of the data helps speeding up this algorithm while still giving good approximations of the optimum parameters.</param>
        </member>
        <member name="M:Emgu.CV.Flann.AutotunedIndexParams.DisposeObject">
            <summary>
            Release all the memory associated with this IndexParam
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.HierarchicalClusteringIndexParams">
            <summary>
            Hierarchical Clustering Index Parameters
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.HierarchicalClusteringIndexParams.#ctor(System.Int32,Emgu.CV.Flann.CenterInitType,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Emgu.CV.Flann.HierarchicalClusteringIndexParams"/>.
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.HierarchicalClusteringIndexParams.DisposeObject">
            <summary>
            Release all the memory associated with this IndexParam
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.SearchParams">
            <summary>
            Search parameters
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.SearchParams.#ctor(System.Int32,System.Single,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Emgu.CV.Flann.SearchParams"/> class.
            </summary>
            <param name="checks">how many leafs to visit when searching for neighbors (-1 for unlimited)</param>
            <param name="eps">Search for eps-approximate neighbors </param>
            <param name="sorted">Only for radius search, require neighbors sorted by distance </param>
        </member>
        <member name="M:Emgu.CV.Flann.SearchParams.DisposeObject">
            <summary>
            Release all the memory associated with this IndexParam
            </summary>
        </member>
        <member name="T:Emgu.CV.Geodetic.GeodeticCoordinate">
            <summary>
            A geodetic coordinate that is defined by its latitude, longitude and altitude
            </summary>
        </member>
        <member name="F:Emgu.CV.Geodetic.GeodeticCoordinate.Empty">
            <summary>
            Indicates the origin of the Geodetic Coordinate
            </summary>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Create a geodetic coordinate using the specific values
            </summary>
            <param name="latitude">Latitude in radian</param>
            <param name="longitude">Longitude in radian</param>
            <param name="altitude">Altitude in meters</param>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.op_Addition(Emgu.CV.Geodetic.GeodeticCoordinate,Emgu.CV.Geodetic.GeodeticCoordinate)">
            <summary>
            Compute the sum of two GeodeticCoordinates
            </summary>
            <param name="coor1">The first coordinate to be added</param>
            <param name="coor2">The second coordinate to be added</param>
            <returns>The sum of two GeodeticCoordinates</returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.op_Subtraction(Emgu.CV.Geodetic.GeodeticCoordinate,Emgu.CV.Geodetic.GeodeticCoordinate)">
            <summary>
            Compute <paramref name="coor1"/> - <paramref name="coor2"/>
            </summary>
            <param name="coor1">The first coordinate</param>
            <param name="coor2">The coordinate to be subtracted</param>
            <returns><paramref name="coor1"/> - <paramref name="coor2"/></returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.op_Multiply(Emgu.CV.Geodetic.GeodeticCoordinate,System.Double)">
            <summary>
            Compute <paramref name="coor"/> * <paramref name="scale"/>
            </summary>
            <param name="coor">The coordinate</param>
            <param name="scale">The scale to be multiplied</param>
            <returns><paramref name="coor"/> * <paramref name="scale"/></returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.Equals(Emgu.CV.Geodetic.GeodeticCoordinate)">
            <summary>
            Check if this Geodetic coordinate equals <paramref name="other"/>
            </summary>
            <param name="other">The other coordinate to be compared with</param>
            <returns>True if two coordinates equals</returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.RadianToDegree(System.Double)">
            <summary>
            Convert radian to degree
            </summary>
            <param name="radian">radian</param>
            <returns>degree</returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.DegreeToRadian(System.Double)">
            <summary>
            Convert degree to radian
            </summary>
            <param name="degree">degree</param>
            <returns>radian</returns>
        </member>
        <member name="P:Emgu.CV.Geodetic.GeodeticCoordinate.Latitude">
            <summary>
            Latitude (phi) in radian
            </summary>
        </member>
        <member name="P:Emgu.CV.Geodetic.GeodeticCoordinate.Longitude">
            <summary>
            Longitude (lambda) in radian
            </summary>
        </member>
        <member name="P:Emgu.CV.Geodetic.GeodeticCoordinate.Altitude">
            <summary>
            Altitude (height) in meters
            </summary>
        </member>
        <member name="T:Emgu.CV.HOGDescriptor">
            <summary>
            A HOG descriptor
            </summary>
        </member>
        <member name="M:Emgu.CV.HOGDescriptor.#ctor">
            <summary>
            Create a new HOGDescriptor
            </summary>
        </member>
        <member name="M:Emgu.CV.HOGDescriptor.#ctor(System.Drawing.Size,System.Drawing.Size,System.Drawing.Size,System.Drawing.Size,System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Create a new HOGDescriptor using the specific parameters.
            </summary>
            <param name="blockSize">Block size in cells. Use (16, 16) for default.</param>
            <param name="cellSize">Cell size. Use (8, 8) for default.</param>
            <param name="blockStride">Block stride. Must be a multiple of cell size. Use (8,8) for default.</param>
            <param name="gammaCorrection">Do gamma correction preprocessing or not. Use true for default.</param>
            <param name="L2HysThreshold">L2-Hys normalization method shrinkage.</param>
            <param name="nbins">Number of bins.</param>
            <param name="winSigma">Gaussian smoothing window parameter.</param>
            <param name="winSize">Detection window size. Must be aligned to block size and block stride. Must match the size of the training image. Use (64, 128) for default.</param>
            <param name="derivAperture"></param>
        </member>
        <member name="M:Emgu.CV.HOGDescriptor.GetDefaultPeopleDetector">
            <summary>
            Return the default people detector
            </summary>
            <returns>The default people detector</returns>
        </member>
        <member name="M:Emgu.CV.HOGDescriptor.SetSVMDetector(System.Single[])">
            <summary>
            Set the SVM detector 
            </summary>
            <param name="detector">The SVM detector</param>
        </member>
        <member name="M:Emgu.CV.HOGDescriptor.DetectMultiScale(Emgu.CV.IInputArray,System.Double,System.Drawing.Size,System.Drawing.Size,System.Double,System.Double,System.Boolean)">
             <summary>
             Performs object detection with increasing detection window.
             </summary>
             <param name="image">The image to search in</param>
             <param name="hitThreshold">
             Threshold for the distance between features and SVM classifying plane.
             Usually it is 0 and should be specified in the detector coefficients (as the last free coefficient).
             But if the free coefficient is omitted (which is allowed), you can specify it manually here.
            </param>
             <param name="winStride">Window stride. Must be a multiple of block stride.</param>
             <param name="padding"></param>
             <param name="scale">Coefficient of the detection window increase.</param>
             <param name="finalThreshold">After detection some objects could be covered by many rectangles. This coefficient regulates similarity threshold. 0 means don't perform grouping. Should be an integer if not using meanshift grouping. Use 2.0 for default</param>
             <param name="useMeanshiftGrouping">If true, it will use meanshift grouping.</param>
             <returns>The regions where positives are found</returns>
        </member>
        <member name="M:Emgu.CV.HOGDescriptor.Compute(Emgu.CV.IInputArray,System.Drawing.Size,System.Drawing.Size,System.Drawing.Point[])">
            <summary>
            
            </summary>
            <param name="image">The image</param>
            <param name="winStride">Window stride. Must be a multiple of block stride. Use Size.Empty for default</param>
            <param name="padding">Padding. Use Size.Empty for default</param>
            <param name="locations">Locations for the computation. Can be null if not needed</param>
            <returns>The descriptor vector</returns>
        </member>
        <member name="M:Emgu.CV.HOGDescriptor.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this HOGDescriptor
            </summary>
        </member>
        <member name="P:Emgu.CV.HOGDescriptor.DescriptorSize">
            <summary>
            Get the size of the descriptor
            </summary>
        </member>
        <member name="M:Emgu.CV.ImageExtensions.ForEachDuplicateChannel``1(Emgu.CV.IImage,System.Func{Emgu.CV.IImage,System.Int32,``0})">
            <summary>
            Apply converter and compute result for each channel of the image, for single channel image, apply converter directly, for multiple channel image, make a copy of each channel to a temperary image and apply the convertor
            </summary>
            <typeparam name="TReturn">The return type</typeparam>
            <param name="image">The source image</param>
            <param name="conv">The converter such that accept the IntPtr of a single channel IplImage, and image channel index which returning result of type R</param>
            <returns>An array which contains result for each channel</returns>
        </member>
        <member name="M:Emgu.CV.ImageExtensions.ForEachDuplicateChannel(Emgu.CV.IImage,System.Action{Emgu.CV.IImage,System.Int32})">
            <summary>
            Apply converter and compute result for each channel of the image, for single channel image, apply converter directly, for multiple channel image, make a copy of each channel to a temperary image and apply the convertor
            </summary>
            <param name="image">The source image</param>
            <param name="action">The converter such that accept the IntPtr of a single channel IplImage, and image channel index which returning result of type R</param>
            <returns>An array which contains result for each channel</returns>
        </member>
        <member name="T:Emgu.CV.IStereoMatcher">
            <summary>
            The stereo matcher interface
            </summary>
        </member>
        <member name="P:Emgu.CV.IStereoMatcher.StereoMatcherPtr">
            <summary>
            Pointer to the stereo matcher
            </summary>
        </member>
        <member name="T:Emgu.CV.Image`2">
            <summary>
            An Image is a wrapper to IplImage of OpenCV. 
            </summary>
            <typeparam name="TColor">Color type of this image (either Gray, Bgr, Bgra, Hsv, Hls, Lab, Luv, Xyz, Ycc, Rgb or Rbga)</typeparam>
            <typeparam name="TDepth">Depth of this image (either Byte, SByte, Single, double, UInt16, Int16 or Int32)</typeparam>
        </member>
        <member name="F:Emgu.CV.Image`2._numberOfChannels">
            <summary>
            The dimension of color
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor">
            <summary>
            Create an empty Image
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(`1[0:,0:,0:])">
            <summary>
            Create image from the specific multi-dimensional data, where the 1st dimesion is # of rows (height), the 2nd dimension is # cols (width) and the 3rd dimension is the channel
            </summary>
            <param name="data">The multi-dimensional data where the 1st dimension is # of rows (height), the 2nd dimension is # cols (width) and the 3rd dimension is the channel </param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Int32,System.Int32,System.Int32,System.IntPtr)">
            <summary>
            Create an Image from unmanaged data. 
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
            <param name="stride">Size of aligned image row in bytes</param>
            <param name="scan0">Pointer to aligned image data, <b>where each row should be 4-align</b> </param>
            <remarks>The caller is responsible for allocating and freeing the block of memory specified by the scan0 parameter, however, the memory should not be released until the related Image is released. </remarks>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.IntPtr)">
            <summary>
            Allocate the image from the image header. 
            </summary>
            <param name="ptr">This should be only a header to the image. When the image is disposed, the cvReleaseImageHeader will be called on the pointer.</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.String)">
            <summary>
            Read image from a file
            </summary>
            <param name="fileName">the name of the file that contains the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.LoadFileUsingBitmap(System.IO.FileInfo)">
            <summary>
            Load the specific file using Bitmap
            </summary>
            <param name="file"></param>
        </member>
        <member name="M:Emgu.CV.Image`2.LoadImageUsingOpenCV(System.IO.FileInfo)">
            <summary>
            Load the specific file using OpenCV
            </summary>
            <param name="file"></param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Drawing.Bitmap)">
            <summary>
            Obtain the image from the specific Bitmap
            </summary>
            <param name="bmp">The bitmap which will be converted to the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Int32,System.Int32,`0)">
            <summary>
            Create a blank Image of the specified width, height and color.
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
            <param name="value">The initial color of the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a blank Image of the specified width and height. 
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Drawing.Size)">
            <summary>
            Create a blank Image of the specific size
            </summary>
            <param name="size">The size of the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.AllocateData(System.Int32,System.Int32,System.Int32)">
            <summary>
            Allocate data for the array
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of columns</param>
            <param name="numberOfChannels">The number of channels of this image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(Emgu.CV.Image{Emgu.CV.Structure.Gray,`1}[])">
            <summary>
            Create a multi-channel image from multiple gray scale images
            </summary>
            <param name="channels">The image channels to be merged into a single image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Image`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">streaming context</param>
        </member>
        <member name="M:Emgu.CV.Image`2.GetAverage">
            <summary>
            Get the average value on this image
            </summary>
            <returns>The average color of the image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GetAverage(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Get the average value on this image, using the specific mask
            </summary>
            <param name="mask">The mask for find the average value</param>
            <returns>The average color of the masked area</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GetSum">
            <summary>Get the sum for each color channel </summary>
            <returns>The sum for each color channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SetValue(`0)">
            <summary>
            Set every pixel of the image to the specific color 
            </summary>
            <param name="color">The color to be set</param>
        </member>
        <member name="M:Emgu.CV.Image`2.SetValue(`0,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Set every pixel of the image to the specific color, using a mask
            </summary>
            <param name="color">The color to be set</param>
            <param name="mask">The mask for setting color</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Copy(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Copy the masked area of this image to destination
            </summary>
            <param name="dest">the destination to copy to</param>
            <param name="mask">the mask for copy</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Copy(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> 
             Make a copy of the image using a mask, if ROI is set, only copy the ROI 
             </summary> 
             <param name="mask">the mask for coping</param>
            <returns> A copy of the image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Copy(System.Drawing.Rectangle)">
            <summary>
            Make a copy of the specific ROI (Region of Interest) from the image
            </summary>
            <param name="roi">The roi to be copied</param>
            <returns>The roi region on the image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Copy(Emgu.CV.Structure.RotatedRect)">
            <summary>
            Get a copy of the boxed region of the image
            </summary>
            <param name="box">The boxed region of the image</param>
            <returns>A copy of the boxed region of the image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Copy">
            <summary> Make a copy of the image, if ROI is set, only copy the ROI</summary>
            <returns> A copy of the image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.CopyBlank">
            <summary> 
            Create an image of the same size
            </summary>
            <remarks>The initial pixel in the image equals zero</remarks>
            <returns> The image of the same size</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Clone">
            <summary>
            Make a clone of the current image. All image data as well as the COI and ROI are cloned
            </summary>
            <returns>A clone of the current image. All image data as well as the COI and ROI are cloned</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GetSubRect(System.Drawing.Rectangle)">
            <summary>
            Get a subimage which image data is shared with the current image.
            </summary>
            <param name="rect">The rectangle area of the sub-image</param>
            <returns>A subimage which image data is shared with the current image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(System.Drawing.Rectangle,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary> Draw an Rectangle of the specific color and thickness </summary>
            <param name="rect"> The rectangle to be drawn</param>
            <param name="color"> The color of the rectangle </param>
            <param name="thickness"> If thickness is less than 1, the rectangle is filled up </param>
             <param name="lineType">Line type</param>
             <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Structure.Cross2DF,`0,System.Int32)">
            <summary> Draw a 2D Cross using the specific color and thickness </summary>
            <param name="cross"> The 2D Cross to be drawn</param>
            <param name="color"> The color of the cross </param>
            <param name="thickness"> Must be &gt; 0 </param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Structure.LineSegment2DF,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary> Draw a line segment using the specific color and thickness </summary>
            <param name="line"> The line segment to be drawn</param>
            <param name="color"> The color of the line segment </param>
            <param name="thickness"> The thickness of the line segment </param>
             <param name="lineType">Line type</param>
             <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Structure.LineSegment2D,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary> Draw a line segment using the specific color and thickness </summary>
            <param name="line"> The line segment to be drawn</param>
            <param name="color"> The color of the line segment </param>
            <param name="thickness"> The thickness of the line segment </param>
             <param name="lineType">Line type</param>
             <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.IConvexPolygonF,`0,System.Int32)">
            <summary> Draw a convex polygon using the specific color and thickness </summary>
            <param name="polygon"> The convex polygon to be drawn</param>
            <param name="color"> The color of the triangle </param>
            <param name="thickness"> If thickness is less than 1, the triangle is filled up </param>
        </member>
        <member name="M:Emgu.CV.Image`2.FillConvexPoly(System.Drawing.Point[],`0,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Fill the convex polygon with the specific color
            </summary>
            <param name="pts">The array of points that define the convex polygon</param>
            <param name="color">The color to fill the polygon with</param>
            <param name="lineType">Line type</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.DrawPolyline(System.Drawing.Point[],System.Boolean,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draw the polyline defined by the array of 2D points
            </summary>
            <param name="pts">A polyline defined by its point</param>
            <param name="isClosed">if true, the last line segment is defined by the last point of the array and the first point of the array</param>
            <param name="color">the color used for drawing</param>
            <param name="thickness">the thinkness of the line</param>
            <param name="lineType">Line type</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.DrawPolyline(System.Drawing.Point[][],System.Boolean,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draw the polylines defined by the array of array of 2D points
            </summary>
            <param name="pts">An array of polylines each represented by an array of points</param>
            <param name="isClosed">if true, the last line segment is defined by the last point of the array and the first point of the array</param>
            <param name="color">the color used for drawing</param>
            <param name="thickness">the thickness of the line</param>
            <param name="lineType">Line type</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Structure.CircleF,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary> Draw a Circle of the specific color and thickness </summary>
            <param name="circle"> The circle to be drawn</param>
            <param name="color"> The color of the circle </param>
            <param name="thickness"> If thickness is less than 1, the circle is filled up </param>
             <param name="lineType">Line type</param>
             <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Structure.Ellipse,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary> Draw a Ellipse of the specific color and thickness </summary>
            <param name="ellipse"> The ellipse to be draw</param>
            <param name="color"> The color of the ellipse </param>
            <param name="thickness"> If thickness is less than 1, the ellipse is filled up </param>
             <param name="lineType">Line type</param>
             <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(System.String,System.Drawing.Point,Emgu.CV.CvEnum.FontFace,System.Double,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Boolean)">
            <summary>
            Draw the text using the specific font on the image
            </summary>
            <param name="message">The text message to be draw</param>
            <param name="fontFace">Font type.</param>
            <param name="fontScale">Font scale factor that is multiplied by the font-specific base size.</param>
            <param name="bottomLeft">The location of the bottom left corner of the font</param>
            <param name="color">The color of the text</param>
            <param name="thickness">Thickness of the lines used to draw a text.</param>
            <param name="lineType">Line type</param>
            <param name="bottomLeftOrigin">When true, the image data origin is at the bottom-left corner. Otherwise, it is at the top-left corner.</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.IInputArrayOfArrays,System.Int32,`0,System.Int32,Emgu.CV.CvEnum.LineType,Emgu.CV.IInputArray,System.Int32,System.Drawing.Point)">
            <summary>
            Draws contour outlines in the image if thickness&gt;=0 or fills area bounded by the contours if thickness&lt;0
            </summary>
            <param name="contours">All the input contours. Each contour is stored as a point vector.</param>
            <param name="contourIdx">Parameter indicating a contour to draw. If it is negative, all the contours are drawn.</param>
            <param name="color">Color of the contours </param>
            <param name="maxLevel">Maximal level for drawn contours. If 0, only contour is drawn. If 1, the contour and all contours after it on the same level are drawn. If 2, all contours after and all contours one level below the contours are drawn, etc. If the value is negative, the function does not draw the contours following after contour but draws child contours of contour up to abs(maxLevel)-1 level. </param>
            <param name="thickness">Thickness of lines the contours are drawn with. If it is negative the contour interiors are drawn</param>
            <param name="lineType">Type of the contour segments</param>
            <param name="hierarchy">Optional information about hierarchy. It is only needed if you want to draw only some of the contours</param>
            <param name="offset">Shift all the point coordinates by the specified value. It is useful in case if the contours retrieved in some image ROI and then the ROI offset needs to be taken into account during the rendering. </param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(System.Drawing.Point[],`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Drawing.Point)">
            <summary>
            Draws contour outlines in the image if thickness&gt;=0 or fills area bounded by the contours if thickness&lt;0
            </summary>
            <param name="contours">The input contour stored as a point vector.</param>
            <param name="color">Color of the contours </param>
            <param name="thickness">Thickness of lines the contours are drawn with. If it is negative the contour interiors are drawn</param>
            <param name="lineType">Type of the contour segments</param>
            <param name="offset">Shift all the point coordinates by the specified value. It is useful in case if the contours retrieved in some image ROI and then the ROI offset needs to be taken into account during the rendering. </param>
        </member>
        <member name="M:Emgu.CV.Image`2.HoughLinesBinary(System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Apply Probabilistic Hough transform to find line segments.
            The current image must be a binary image (eg. the edges as a result of the Canny edge detector)
            </summary>
            <param name="rhoResolution">Distance resolution in pixel-related units.</param>
            <param name="thetaResolution">Angle resolution measured in radians</param>
            <param name="threshold">A line is returned by the function if the corresponding accumulator value is greater than threshold</param>
            <param name="minLineWidth">Minimum width of a line</param>
            <param name="gapBetweenLines">Minimum gap between lines</param>
            <returns>The line segments detected for each of the channels</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.HoughLines(System.Double,System.Double,System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
             Apply Canny Edge Detector follows by Probabilistic Hough transform to find line segments in the image
            </summary>
            <param name="cannyThreshold"> The threshhold to find initial segments of strong edges</param>
            <param name="cannyThresholdLinking"> The threshold used for edge Linking</param>
            <param name="rhoResolution">Distance resolution in pixel-related units.</param>
            <param name="thetaResolution">Angle resolution measured in radians</param>
            <param name="threshold">A line is returned by the function if the corresponding accumulator value is greater than threshold</param>
            <param name="minLineWidth">Minimum width of a line</param>
            <param name="gapBetweenLines">Minimum gap between lines</param>
            <returns>The line segments detected for each of the channels</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.HoughCircles(`0,`0,System.Double,System.Double,System.Int32,System.Int32)">
            <summary>
            First apply Canny Edge Detector on the current image,
            then apply Hough transform to find circles
            </summary>
            <param name="cannyThreshold">The higher threshold of the two passed to Canny edge detector (the lower one will be twice smaller).</param>
            <param name="accumulatorThreshold">Accumulator threshold at the center detection stage. The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator values, will be returned first</param>
            <param name="dp">Resolution of the accumulator used to detect centers of the circles. For example, if it is 1, the accumulator will have the same resolution as the input image, if it is 2 - accumulator will have twice smaller width and height, etc</param>
            <param name="minRadius">Minimal radius of the circles to search for</param>
            <param name="maxRadius">Maximal radius of the circles to search for</param>
            <param name="minDist">Minimum distance between centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed</param>
            <returns>The circle detected for each of the channels</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.RoiParam(System.IntPtr,System.Int64@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Return parameters based on ROI
            </summary>
            <param name="ptr">The Pointer to the IplImage</param>
            <param name="start">The address of the pointer that point to the start of the Bytes taken into consideration ROI</param>
            <param name="elementCount">ROI.Width * ColorType.Dimension</param>
            <param name="byteWidth">The number of bytes in a row taken into consideration ROI</param>
            <param name="rows">The number of rows taken into consideration ROI</param>
            <param name="widthStep">The width step required to jump to the next row</param>
        </member>
        <member name="M:Emgu.CV.Image`2.ForEachChannel``1(System.Func{System.IntPtr,System.Int32,``0})">
            <summary>
            Apply convertor and compute result for each channel of the image.
            </summary>
            <remarks>
            For single channel image, apply converter directly.
            For multiple channel image, set the COI for the specific channel before appling the convertor
            </remarks>
            <typeparam name="TResult">The return type</typeparam>
            <param name="conv">The converter such that accept the IntPtr of a single channel IplImage, and image channel index which returning result of type R</param>
            <returns>An array which contains result for each channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ForEachDuplicateChannel``1(System.Action{Emgu.CV.IImage,Emgu.CV.IImage,System.Int32},Emgu.CV.Image{`0,``0})">
            <summary>
            If the image has only one channel, apply the action directly on the IntPtr of this image and <paramref name="dest"/>,
            otherwise, make copy each channel of this image to a temperary one, apply action on it and another temperory image and copy the resulting image back to image2
            </summary>
            <typeparam name="TOtherDepth">The type of the depth of the <paramref name="dest"/> image</typeparam>
            <param name="act">The function which acepts the src IntPtr, dest IntPtr and index of the channel as input</param>
            <param name="dest">The destination image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Sobel(System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates the image derivative by convolving the image with the appropriate kernel
            The Sobel operators combine Gaussian smoothing and differentiation so the result is more or less robust to the noise. Most often, the function is called with (xorder=1, yorder=0, aperture_size=3) or (xorder=0, yorder=1, aperture_size=3) to calculate first x- or y- image derivative.
            </summary>
            <param name="xorder">Order of the derivative x</param>
            <param name="yorder">Order of the derivative y</param>
            <param name="apertureSize">Size of the extended Sobel kernel, must be 1, 3, 5 or 7. In all cases except 1, aperture_size xaperture_size separable kernel will be used to calculate the derivative.</param>
            <returns>The result of the sobel edge detector</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Laplace(System.Int32)">
             <summary>
             Calculates Laplacian of the source image by summing second x- and y- derivatives calculated using Sobel operator.
             Specifying aperture_size=1 gives the fastest variant that is equal to convolving the image with the following kernel:
            
             |0  1  0|
             |1 -4  1|
             |0  1  0|
             </summary>
             <param name="apertureSize">Aperture size </param>
             <returns>The Laplacian of the image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Canny(System.Double,System.Double)">
            <summary> Find the edges on this image and marked them in the returned image.</summary>
            <param name="thresh"> The threshhold to find initial segments of strong edges</param>
            <param name="threshLinking"> The threshold used for edge Linking</param>
            <returns> The edges found by the Canny edge detector</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Canny(System.Double,System.Double,System.Int32,System.Boolean)">
            <summary> Find the edges on this image and marked them in the returned image.</summary>
            <param name="thresh"> The threshhold to find initial segments of strong edges</param>
            <param name="threshLinking"> The threshold used for edge Linking</param>
            <param name="apertureSize">The aperture size, use 3 for default</param>
            <param name="l2Gradient">a flag, indicating whether a more accurate norm should be used to calculate the image gradient magnitude ( L2gradient=true ), or whether the default norm is enough ( L2gradient=false ).</param>
            <returns> The edges found by the Canny edge detector</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.FindCornerSubPix(System.Drawing.PointF[][],System.Drawing.Size,System.Drawing.Size,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Iterates to find the sub-pixel accurate location of corners, or radial saddle points
            </summary>
            <param name="corners">Coordinates of the input corners, the values will be modified by this function call</param>
            <param name="win">Half sizes of the search window. For example, if win=(5,5) then 5*2+1 x 5*2+1 = 11 x 11 search window is used</param>
            <param name="zeroZone">Half size of the dead region in the middle of the search zone over which the summation in formulae below is not done. It is used sometimes to avoid possible singularities of the autocorrelation matrix. The value of (-1,-1) indicates that there is no such size</param>
            <param name="criteria">Criteria for termination of the iterative process of corner refinement. That is, the process of corner position refinement stops either after certain number of iteration or when a required accuracy is achieved. The criteria may specify either of or both the maximum number of iteration and the required accuracy</param>
            <returns>Refined corner coordinates</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.MatchTemplate(Emgu.CV.Image{`0,`1},Emgu.CV.CvEnum.TemplateMatchingType)">
            <summary>
            The function slids through image, compares overlapped patches of size wxh with templ using the specified method and return the comparison results 
            </summary>
            <param name="template">Searched template; must be not greater than the source image and the same data type as the image</param>
            <param name="method">Specifies the way the template must be compared with image regions </param>
            <returns>The comparison result: width = this.Width - template.Width + 1; height = this.Height - template.Height + 1 </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.And(Emgu.CV.Image{`0,`1})">
            <summary> Perform an elementwise AND operation with another image and return the result</summary>
            <param name="img2">The second image for the AND operation</param>
            <returns> The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.And(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> 
            Perform an elementwise AND operation with another image, using a mask, and return the result
            </summary>
            <param name="img2">The second image for the AND operation</param>
            <param name="mask">The mask for the AND operation</param>
            <returns> The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.And(`0)">
            <summary> Perform an binary AND operation with some color</summary>
            <param name="val">The color for the AND operation</param>
            <returns> The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.And(`0,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> Perform an binary AND operation with some color using a mask</summary>
            <param name="val">The color for the AND operation</param>
            <param name="mask">The mask for the AND operation</param>
            <returns> The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Or(Emgu.CV.Image{`0,`1})">
            <summary> Perform an elementwise OR operation with another image and return the result</summary>
            <param name="img2">The second image for the OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Or(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> Perform an elementwise OR operation with another image, using a mask, and return the result</summary>
            <param name="img2">The second image for the OR operation</param>
            <param name="mask">The mask for the OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Or(`0)">
            <summary> Perform an elementwise OR operation with some color</summary>
            <param name="val">The value for the OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Or(`0,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> Perform an elementwise OR operation with some color using a mask</summary>
            <param name="val">The color for the OR operation</param>
            <param name="mask">The mask for the OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Xor(Emgu.CV.Image{`0,`1})">
            <summary> Perform an elementwise XOR operation with another image and return the result</summary>
            <param name="img2">The second image for the XOR operation</param>
            <returns> The result of the XOR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Xor(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Perform an elementwise XOR operation with another image, using a mask, and return the result
            </summary>
            <param name="img2">The second image for the XOR operation</param>
            <param name="mask">The mask for the XOR operation</param>
            <returns>The result of the XOR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Xor(`0)">
            <summary> 
            Perform an binary XOR operation with some color
            </summary>
            <param name="val">The value for the XOR operation</param>
            <returns> The result of the XOR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Xor(`0,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Perform an binary XOR operation with some color using a mask
            </summary>
            <param name="val">The color for the XOR operation</param>
            <param name="mask">The mask for the XOR operation</param>
            <returns> The result of the XOR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Not">
            <summary> 
            Compute the complement image
            </summary>
            <returns> The complement image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Max(Emgu.CV.Image{`0,`1})">
            <summary> Find the elementwise maximum value </summary>
            <param name="img2">The second image for the Max operation</param>
            <returns> An image where each pixel is the maximum of <i>this</i> image and the parameter image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Max(System.Double)">
            <summary> Find the elementwise maximum value </summary>
            <param name="value">The value to compare with</param>
            <returns> An image where each pixel is the maximum of <i>this</i> image and <paramref name="value"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Min(Emgu.CV.Image{`0,`1})">
            <summary> Find the elementwise minimum value </summary>
            <param name="img2">The second image for the Min operation</param>
            <returns> An image where each pixel is the minimum of <i>this</i> image and the parameter image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Min(System.Double)">
            <summary> Find the elementwise minimum value </summary>
            <param name="value">The value to compare with</param>
            <returns> An image where each pixel is the minimum of <i>this</i> image and <paramref name="value"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.InRange(`0,`0)">
            <summary>Checks that image elements lie between two scalars</summary>
            <param name="lower"> The inclusive lower limit of color value</param>
            <param name="higher"> The inclusive upper limit of color value</param>
            <returns> res[i,j] = 255 if <paramref name="lower"/> &lt;= this[i,j] &lt;= <paramref name="higher"/>, 0 otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.InRange(Emgu.CV.Image{`0,`1},Emgu.CV.Image{`0,`1})">
            <summary>Checks that image elements lie between values defined by two images of same size and type</summary>
            <param name="lower"> The inclusive lower limit of color value</param>
            <param name="higher"> The inclusive upper limit of color value</param>
            <returns> res[i,j] = 255 if <paramref name="lower"/>[i,j] &lt;= this[i,j] &lt;= <paramref name="higher"/>[i,j], 0 otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Cmp(Emgu.CV.Image{`0,`1},Emgu.CV.CvEnum.CmpType)">
            <summary>
            Compare the current image with <paramref name="img2"/> and returns the comparison mask
            </summary>
            <param name="img2">The other image to compare with</param>
            <param name="cmpType">The comparison type</param>
            <returns>The result of the comparison as a mask</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Cmp(System.Double,Emgu.CV.CvEnum.CmpType)">
            <summary>
            Compare the current image with <paramref name="value"/> and returns the comparison mask
            </summary>
            <param name="value">The value to compare with</param>
            <param name="comparisonType">The comparison type</param>
            <returns>The result of the comparison as a mask</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Equals(Emgu.CV.Image{`0,`1})">
            <summary>
            Compare two images, returns true if the each of the pixels are equal, false otherwise
            </summary>
            <param name="img2">The other image to compare with</param>
            <returns>true if the each of the pixels for the two images are equal, false otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GrabCut(System.Drawing.Rectangle,System.Int32)">
            <summary>
            Use grabcut to perform background foreground segmentation.
            </summary>
            <param name="rect">The initial rectangle region for the foreground</param>
            <param name="iteration">The number of iterations to run GrabCut</param>
            <returns>The background foreground mask where 2 indicates background and 3 indicates foreground</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Sub(Emgu.CV.Image{`0,`1})">
            <summary> Elementwise subtract another image from the current image </summary>
            <param name="img2">The second image to be subtracted from the current image</param>
            <returns> The result of elementwise subtracting img2 from the current image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Sub(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> Elementwise subtract another image from the current image, using a mask</summary>
            <param name="img2">The image to be subtracted from the current image</param>
            <param name="mask">The mask for the subtract operation</param>
            <returns> The result of elementwise subtrating img2 from the current image, using the specific mask</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Sub(`0)">
            <summary> Elementwise subtract a color from the current image</summary>
            <param name="val">The color value to be subtracted from the current image</param>
            <returns> The result of elementwise subtracting color 'val' from the current image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SubR(`0)">
            <summary>
            result = val - this
            </summary>
            <param name="val">the value which subtract this image</param>
            <returns>val - this</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SubR(`0,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            result = val - this, using a mask
            </summary>
            <param name="val">The value which subtract this image</param>
            <param name="mask">The mask for subtraction</param>
            <returns>val - this, with mask</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Add(Emgu.CV.Image{`0,`1})">
            <summary> Elementwise add another image with the current image </summary>
            <param name="img2">The image to be added to the current image</param>
            <returns> The result of elementwise adding img2 to the current image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Add(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> Elementwise add <paramref name="img2"/> with the current image, using a mask</summary>
            <param name="img2">The image to be added to the current image</param>
            <param name="mask">The mask for the add operation</param>
            <returns> The result of elementwise adding img2 to the current image, using the specific mask</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Add(`0)">
            <summary> Elementwise add a color <paramref name="val"/> to the current image</summary>
            <param name="val">The color value to be added to the current image</param>
            <returns> The result of elementwise adding color <paramref name="val"/> from the current image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Mul(Emgu.CV.Image{`0,`1},System.Double)">
            <summary> Elementwise multiply another image with the current image and the <paramref name="scale"/></summary>
            <param name="img2">The image to be elementwise multiplied to the current image</param>
            <param name="scale">The scale to be multiplied</param>
            <returns> this .* img2 * scale </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Mul(Emgu.CV.Image{`0,`1})">
            <summary> Elementwise multiply <paramref name="img2"/> with the current image</summary>
            <param name="img2">The image to be elementwise multiplied to the current image</param>
            <returns> this .* img2 </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Mul(System.Double)">
            <summary> Elementwise multiply the current image with <paramref name="scale"/></summary>
            <param name="scale">The scale to be multiplied</param>
            <returns> The scaled image </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Accumulate(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Accumulate <paramref name="img2"/> to the current image using the specific mask
            </summary>
            <param name="img2">The image to be added to the current image</param>
            <param name="mask">the mask</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Accumulate(Emgu.CV.Image{`0,`1})">
            <summary>
            Accumulate <paramref name="img2"/> to the current image using the specific mask
            </summary>
            <param name="img2">The image to be added to the current image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.AddWeighted(Emgu.CV.Image{`0,`1},System.Double,System.Double,System.Double)">
            <summary> 
            Return the weighted sum such that: res = this * alpha + img2 * beta + gamma
            </summary>
            <param name="img2">img2 in: res = this * alpha + img2 * beta + gamma </param>
            <param name="alpha">alpha in: res = this * alpha + img2 * beta + gamma</param>
            <param name="beta">beta in: res = this * alpha + img2 * beta + gamma</param>
            <param name="gamma">gamma in: res = this * alpha + img2 * beta + gamma</param>
            <returns>this * alpha + img2 * beta + gamma</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.AccumulateWeighted(Emgu.CV.Image{`0,`1},System.Double)">
            <summary> 
             Update Running Average. <i>this</i> = (1-alpha)*<i>this</i> + alpha*img
            </summary>
            <param name="img">Input image, 1- or 3-channel, Byte or Single (each channel of multi-channel image is processed independently). </param>
            <param name="alpha">the weight of <paramref name="img"/></param>
        </member>
        <member name="M:Emgu.CV.Image`2.AccumulateWeighted(Emgu.CV.Image{`0,`1},System.Double,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> 
             Update Running Average. <i>this</i> = (1-alpha)*<i>this</i> + alpha*img, using the mask
            </summary>
            <param name="img">Input image, 1- or 3-channel, Byte or Single (each channel of multi-channel image is processed independently). </param>
            <param name="alpha">The weight of <paramref name="img"/></param>
            <param name="mask">The mask for the running average</param>
        </member>
        <member name="M:Emgu.CV.Image`2.AbsDiff(Emgu.CV.Image{`0,`1})">
            <summary> 
            Computes absolute different between <i>this</i> image and the other image
            </summary>
            <param name="img2">The other image to compute absolute different with</param>
            <returns> The image that contains the absolute different value</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.AbsDiff(`0)">
            <summary> 
            Computes absolute different between <i>this</i> image and the specific color
            </summary>
            <param name="color">The color to compute absolute different with</param>
            <returns> The image that contains the absolute different value</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Pow(System.Double)">
            <summary>
            Raises every element of input array to p
            dst(I)=src(I)^p, if p is integer
            dst(I)=abs(src(I))^p, otherwise
            </summary>
            <param name="power">The exponent of power</param>
            <returns>The power image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Exp">
            <summary>
            Calculates exponent of every element of input array:
            dst(I)=exp(src(I))
            </summary>
            <remarks>Maximum relative error is ~7e-6. Currently, the function converts denormalized values to zeros on output.</remarks>
            <returns>The exponent image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Log">
            <summary>
            Calculates natural logarithm of absolute value of every element of input array
            </summary>
            <returns>Natural logarithm of absolute value of every element of input array</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Sample(Emgu.CV.Structure.LineSegment2D)">
            <summary> Sample the pixel values on the specific line segment </summary>
            <param name="line"> The line to obtain samples</param>
            <returns>The values on the (Eight-connected) line </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Sample(Emgu.CV.Structure.LineSegment2D,Emgu.CV.CvEnum.Connectivity)">
            <summary>
            Sample the pixel values on the specific line segment
            </summary>
            <param name="line">The line to obtain samples</param>
            <param name="type">The sampling type</param>
            <returns>The values on the line, the first dimension is the index of the point, the second dimension is the index of color channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Resize(System.Int32,System.Int32,Emgu.CV.CvEnum.Inter)">
            <summary>
            Scale the image to the specific size 
            </summary>
            <param name="width">The width of the returned image.</param>
            <param name="height">The height of the returned image.</param>
            <param name="interpolationType">The type of interpolation</param>
            <returns>The resized image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Resize(System.Int32,System.Int32,Emgu.CV.CvEnum.Inter,System.Boolean)">
            <summary>
            Scale the image to the specific size
            </summary>
            <param name="width">The width of the returned image.</param>
            <param name="height">The height of the returned image.</param>
            <param name="interpolationType">The type of interpolation</param>
            <param name="preserveScale">if true, the scale is preservered and the resulting image has maximum width(height) possible that is &lt;= <paramref name="width"/> (<paramref name="height"/>), if false, this function is equaivalent to Resize(int width, int height)</param>
            <returns>The resized image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Resize(System.Double,Emgu.CV.CvEnum.Inter)">
            <summary>
            Scale the image to the specific size: width *= scale; height *= scale  
            </summary>
            <param name="scale">The scale to resize</param>
            <param name="interpolationType">The type of interpolation</param>
            <returns>The scaled image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Rotate(System.Double,`0)">
            <summary>
            Rotate the image the specified angle cropping the result to the original size
            </summary>
            <param name="angle">The angle of rotation in degrees.</param>
            <param name="background">The color with wich to fill the background</param>   
            <returns>The image rotates by the specific angle</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.WarpAffine(Emgu.CV.Mat,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp,Emgu.CV.CvEnum.BorderType,`0)">
            <summary>
            Transforms source image using the specified matrix
            </summary>
            <param name="mapMatrix">2x3 transformation matrix</param>
            <param name="interpolationType">Interpolation type</param>
            <param name="warpType">Warp type</param>
            <param name="borderMode">Pixel extrapolation method</param>
            <param name="backgroundColor">A value used to fill outliers</param>
            <returns>The result of the transformation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.WarpAffine(Emgu.CV.Mat,System.Int32,System.Int32,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp,Emgu.CV.CvEnum.BorderType,`0)">
            <summary>
            Transforms source image using the specified matrix
            </summary>
            <param name="mapMatrix">2x3 transformation matrix</param>
            <param name="width">The width of the resulting image</param>
            <param name="height">the height of the resulting image</param>
            <param name="interpolationType">Interpolation type</param>
            <param name="warpType">Warp type</param>
            <param name="borderMode">Pixel extrapolation method</param>
            <param name="backgroundColor">A value used to fill outliers</param>
            <returns>The result of the transformation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.WarpPerspective``1(Emgu.CV.Matrix{``0},Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp,Emgu.CV.CvEnum.BorderType,`0)">
            <summary>
            Transforms source image using the specified matrix
            </summary>
            <param name="mapMatrix">3x3 transformation matrix</param>
            <param name="interpolationType">Interpolation type</param>
            <param name="warpType">Warp type</param>
            <param name="borderMode">Pixel extrapolation method</param>
            <param name="backgroundColor">A value used to fill outliers</param>
            <typeparam name="TMapDepth">The depth type of <paramref name="mapMatrix"/>, should be either float or double</typeparam>
            <returns>The result of the transformation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.WarpPerspective``1(Emgu.CV.Matrix{``0},System.Int32,System.Int32,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp,Emgu.CV.CvEnum.BorderType,`0)">
            <summary>
            Transforms source image using the specified matrix
            </summary>
            <param name="mapMatrix">3x3 transformation matrix</param>
            <param name="width">The width of the resulting image</param>
            <param name="height">the height of the resulting image</param>
            <param name="interpolationType">Interpolation type</param>
            <param name="warpType">Warp type</param>
            <param name="borderType">Border type</param>
            <param name="backgroundColor">A value used to fill outliers</param>
            <typeparam name="TMapDepth">The depth type of <paramref name="mapMatrix"/>, should be either float or double</typeparam>
            <returns>The result of the transformation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Rotate(System.Double,`0,System.Boolean)">
            <summary>
            Rotate this image the specified <paramref name="angle"/>
            </summary>
            <param name="angle">The angle of rotation in degrees.</param>
            <param name="background">The color with wich to fill the background</param>
            <param name="crop">If set to true the image is cropped to its original size, possibly losing corners information. If set to false the result image has different size than original and all rotation information is preserved</param>
            <returns>The rotated image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Rotate(System.Double,System.Drawing.PointF,Emgu.CV.CvEnum.Inter,`0,System.Boolean)">
            <summary>
            Rotate this image the specified <paramref name="angle"/>
            </summary>
            <param name="angle">The angle of rotation in degrees. Positive means clockwise.</param>
            <param name="background">The color with with to fill the background</param>
            <param name="crop">If set to true the image is cropped to its original size, possibly losing corners information. If set to false the result image has different size than original and all rotation information is preserved</param>
            <param name="center">The center of rotation</param>
            <param name="interpolationMethod">The interpolation method</param>
            <returns>The rotated image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.LogPolar(System.Drawing.PointF,System.Double,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.Warp)">
            <summary>
             Convert the image to log polar, simulating the human foveal vision
             </summary>
             <param name="center">The transformation center, where the output precision is maximal</param>
             <param name="magnitude">Magnitude scale parameter</param>
             <param name="interpolationType">interpolation type</param>
             <param name="warpType">Warp type</param>
             <returns>The converted image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``2">
            <summary> Convert the current image to the specific color and depth </summary>
            <typeparam name="TOtherColor"> The type of color to be converted to </typeparam>
            <typeparam name="TOtherDepth"> The type of pixel depth to be converted to </typeparam>
            <returns> Image of the specific color and depth </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ConvertFrom``2(Emgu.CV.Image{``0,``1})">
            <summary>
            Convert the source image to the current image, if the size are different, the current image will be a resized version of the srcImage. 
            </summary>
            <typeparam name="TSrcColor">The color type of the source image</typeparam>
            <typeparam name="TSrcDepth">The color depth of the source image</typeparam>
            <param name="srcImage">The sourceImage</param>
        </member>
        <member name="M:Emgu.CV.Image`2.ConvertFrom(Emgu.CV.IInputArray)">
            <summary>
            Convert the source image to the current image, if the size are different, the current image will be a resized version of the srcImage. 
            </summary>
            <param name="srcImage">The sourceImage</param>
        </member>
        <member name="M:Emgu.CV.Image`2.ConvertScale``1(System.Double,System.Double)">
            <summary> Convert the current image to the specific depth, at the same time scale and shift the values of the pixel</summary>
            <param name="scale"> The value to be multipled with the pixel </param>
            <param name="shift"> The value to be added to the pixel</param>
             <typeparam name="TOtherDepth"> The type of depth to convert to</typeparam>
            <returns> Image of the specific depth, val = val * scale + shift </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.CopyFromBitmap(System.Drawing.Bitmap)">
            <summary>
            Utility function for Bitmap Set property
            </summary>
            <param name="bmp"></param>
        </member>
        <member name="M:Emgu.CV.Image`2.ToBitmap">
            <summary> 
            Convert this image into Bitmap, the pixel values are copied over to the Bitmap
            </summary>
            <remarks> For better performance on Image&lt;Gray, Byte&gt; and Image&lt;Bgr, Byte&gt;, consider using the Bitmap property </remarks>
            <returns> This image in Bitmap format, the pixel data are copied over to the Bitmap</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ToBitmap(System.Int32,System.Int32)">
            <summary> Create a Bitmap image of certain size</summary>
            <param name="width">The width of the bitmap</param>
            <param name="height"> The height of the bitmap</param>
            <returns> This image in Bitmap format of the specific size</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.PyrDown">
            <summary>
             Performs downsampling step of Gaussian pyramid decomposition. 
             First it convolves <i>this</i> image with the specified filter and then downsamples the image 
             by rejecting even rows and columns.
            </summary>
            <returns> The downsampled image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.PyrUp">
            <summary>
             Performs up-sampling step of Gaussian pyramid decomposition. 
             First it upsamples <i>this</i> image by injecting even zero rows and columns and then convolves 
             result with the specified filter multiplied by 4 for interpolation. 
             So the resulting image is four times larger than the source image.
            </summary>
            <returns> The upsampled image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.BuildPyramid(System.Int32)">
            <summary>
            Compute the image pyramid
            </summary>
            <param name="maxLevel">The number of level's for the pyramid; Level 0 referes to the current image, level n is computed by calling the PyrDown() function on level n-1</param>
            <returns>The image pyramid</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.InPaint(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},System.Double)">
            <summary> Use inpaint to recover the intensity of the pixels which location defined by <paramref>mask</paramref> on <i>this</i> image </summary>
            <param name="mask">The inpainting mask. Non-zero pixels indicate the area that needs to be inpainted</param>
            <param name="radius">The radius of circular neighborhood of each point inpainted that is considered by the algorithm</param>
            <returns> The inpainted image </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.MorphologyEx(Emgu.CV.CvEnum.MorphOp,Emgu.CV.IInputArray,System.Drawing.Point,System.Int32,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Perform advanced morphological transformations using erosion and dilation as basic operations.
            </summary>
            <param name="kernel">Structuring element</param>
            <param name="anchor">Anchor position with the kernel. Negative values mean that the anchor is at the kernel center.</param>
            <param name="operation">Type of morphological operation</param>
            <param name="iterations">Number of times erosion and dilation are applied</param>
            <param name="borderType">Border type</param>
            <param name="borderValue">Border value</param>
            <returns>The result of the morphological operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2._MorphologyEx(Emgu.CV.CvEnum.MorphOp,Emgu.CV.IInputArray,System.Drawing.Point,System.Int32,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Perform inplace advanced morphological transformations using erosion and dilation as basic operations.
            </summary>
            <param name="kernel">Structuring element</param>
            <param name="anchor">Anchor position with the kernel. Negative values mean that the anchor is at the kernel center.</param>
            <param name="operation">Type of morphological operation</param>
            <param name="iterations">Number of times erosion and dilation are applied</param>
            <param name="borderType">Border type</param>
            <param name="borderValue">Border value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Erode(System.Int32)">
            <summary>
            Erodes <i>this</i> image using a 3x3 rectangular structuring element.
            Erosion are applied several (iterations) times
            </summary>
            <param name="iterations">The number of erode iterations</param>
            <returns> The eroded image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Dilate(System.Int32)">
            <summary>
            Dilates <i>this</i> image using a 3x3 rectangular structuring element.
            Dilation are applied several (iterations) times
            </summary>
            <param name="iterations">The number of dilate iterations</param>
            <returns> The dialated image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2._Erode(System.Int32)">
            <summary>
            Erodes <i>this</i> image inplace using a 3x3 rectangular structuring element.
            Erosion are applied several (iterations) times
            </summary>
            <param name="iterations">The number of erode iterations</param>
        </member>
        <member name="M:Emgu.CV.Image`2._Dilate(System.Int32)">
            <summary>
            Dilates <i>this</i> image inplace using a 3x3 rectangular structuring element.
            Dilation are applied several (iterations) times
            </summary>
            <param name="iterations">The number of dilate iterations</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Action(System.Action{`1})">
            <summary> 
            perform an generic action based on each element of the image
            </summary>
            <param name="action">The action to be applied to each element of the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Action``1(Emgu.CV.Image{`0,``0},System.Action{`1,``0})">
            <summary>
            Perform an generic operation based on the elements of the two images
            </summary>
            <typeparam name="TOtherDepth">The depth of the second image</typeparam>
            <param name="img2">The second image to perform action on</param>
            <param name="action">An action such that the first parameter is the a single channel of a pixel from the first image, the second parameter is the corresponding channel of the correspondind pixel from the second image </param>
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``1(System.Func{`1,System.Int32,System.Int32,``0})">
            <summary> 
            Compute the element of a new image based on the value as well as the x and y positions of each pixel on the image
            </summary> 
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``1(System.Converter{`1,``0})">
            <summary> Compute the element of the new image based on element of this image</summary> 
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``2(Emgu.CV.Image{`0,``0},System.Func{`1,``0,``1})">
            <summary> Compute the element of the new image based on the elements of the two image</summary>
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``3(Emgu.CV.Image{`0,``0},Emgu.CV.Image{`0,``1},System.Func{`1,``0,``1,``2})">
            <summary> Compute the element of the new image based on the elements of the three image</summary>
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``4(Emgu.CV.Image{`0,``0},Emgu.CV.Image{`0,``1},Emgu.CV.Image{`0,``2},System.Func{`1,``0,``1,``2,``3})">
            <summary> Compute the element of the new image based on the elements of the four image</summary>
        </member>
        <member name="M:Emgu.CV.Image`2.DisposeObject">
            <summary>
            Release all unmanaged memory associate with the image
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseAnd(Emgu.CV.Image{`0,`1},Emgu.CV.Image{`0,`1})">
            <summary>
            Perform an elementwise AND operation on the two images
            </summary>
            <param name="img1">The first image to AND</param>
            <param name="img2">The second image to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseAnd(Emgu.CV.Image{`0,`1},System.Double)">
            <summary>
            Perform an elementwise AND operation using an images and a color
            </summary>
            <param name="img1">The first image to AND</param>
            <param name="val">The color to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseAnd(System.Double,Emgu.CV.Image{`0,`1})">
            <summary>
            Perform an elementwise AND operation using an images and a color
            </summary>
            <param name="img1">The first image to AND</param>
            <param name="val">The color to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseAnd(Emgu.CV.Image{`0,`1},`0)">
            <summary>
            Perform an elementwise AND operation using an images and a color
            </summary>
            <param name="img1">The first image to AND</param>
            <param name="val">The color to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseAnd(`0,Emgu.CV.Image{`0,`1})">
            <summary>
            Perform an elementwise AND operation using an images and a color
            </summary>
            <param name="img1">The first image to AND</param>
            <param name="val">The color to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseOr(Emgu.CV.Image{`0,`1},Emgu.CV.Image{`0,`1})">
            <summary> Perform an elementwise OR operation with another image and return the result</summary>
            <param name="img1">The first image to apply bitwise OR operation</param>
            <param name="img2">The second image to apply bitwise OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseOr(Emgu.CV.Image{`0,`1},System.Double)">
            <summary> 
             Perform an binary OR operation with some color
             </summary>
            <param name="img1">The image to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseOr(System.Double,Emgu.CV.Image{`0,`1})">
            <summary> 
             Perform an binary OR operation with some color
             </summary>
            <param name="img1">The image to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseOr(Emgu.CV.Image{`0,`1},`0)">
            <summary> 
             Perform an binary OR operation with some color
             </summary>
            <param name="img1">The image to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseOr(`0,Emgu.CV.Image{`0,`1})">
            <summary> 
             Perform an binary OR operation with some color
             </summary>
            <param name="img1">The image to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_OnesComplement(Emgu.CV.Image{`0,`1})">
            <summary>Compute the complement image</summary>
            <param name="image">The image to be inverted</param>
            <returns>The complement image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Addition(Emgu.CV.Image{`0,`1},Emgu.CV.Image{`0,`1})">
            <summary>
            Elementwise add <paramref name="img1"/> with <paramref name="img2"/>
            </summary>
            <param name="img1">The first image to be added</param>
            <param name="img2">The second image to be added</param>
            <returns>The sum of the two images</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Addition(System.Double,Emgu.CV.Image{`0,`1})">
            <summary>
            Elementwise add <paramref name="img1"/> with <paramref name="val"/>
            </summary>
            <param name="img1">The image to be added</param>
            <param name="val">The value to be added</param>
            <returns>The images plus the color</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Addition(Emgu.CV.Image{`0,`1},System.Double)">
            <summary>
            Elementwise add <paramref name="image"/> with <paramref name="value"/>
            </summary>
            <param name="image">The image to be added</param>
            <param name="value">The value to be added</param>
            <returns>The images plus the color</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Addition(Emgu.CV.Image{`0,`1},`0)">
            <summary>
            Elementwise add <paramref name="image"/> with <paramref name="value"/>
            </summary>
            <param name="image">The image to be added</param>
            <param name="value">The color to be added</param>
            <returns>The images plus the color</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Addition(`0,Emgu.CV.Image{`0,`1})">
            <summary>
            Elementwise add <paramref name="image"/> with <paramref name="value"/>
            </summary>
            <param name="image">The image to be added</param>
            <param name="value">The color to be added</param>
            <returns>The images plus the color</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Subtraction(Emgu.CV.Image{`0,`1},Emgu.CV.Image{`0,`1})">
            <summary>
            Elementwise subtract another image from the current image
            </summary>
            <param name="image1">The image to be subtracted</param>
            <param name="image2">The second image to be subtracted from <paramref name="image1"/></param>
            <returns> The result of elementwise subtracting img2 from <paramref name="image1"/> </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Subtraction(Emgu.CV.Image{`0,`1},`0)">
            <summary>
            Elementwise subtract another image from the current image
            </summary>
            <param name="image">The image to be subtracted</param>
            <param name="value">The color to be subtracted</param>
            <returns> The result of elementwise subtracting <paramred name="val"/> from <paramref name="image"/> </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Subtraction(`0,Emgu.CV.Image{`0,`1})">
            <summary>
            Elementwise subtract another image from the current image
            </summary>
            <param name="image">The image to be subtracted</param>
            <param name="value">The color to be subtracted</param>
            <returns> <paramred name="val"/> - <paramref name="image"/> </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Subtraction(System.Double,Emgu.CV.Image{`0,`1})">
            <summary>
            <paramred name="val"/> - <paramref name="image"/>
            </summary>
            <param name="image">The image to be subtracted</param>
            <param name="value">The value to be subtracted</param>
            <returns> <paramred name="val"/> - <paramref name="image"/> </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Subtraction(Emgu.CV.Image{`0,`1},System.Double)">
            <summary>
            Elementwise subtract another image from the current image
            </summary>
            <param name="image">The image to be subtracted</param>
            <param name="value">The value to be subtracted</param>
            <returns> <paramref name="image"/> - <paramred name="val"/>   </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Multiply(Emgu.CV.Image{`0,`1},System.Double)">
            <summary>
             <paramref name="image"/> * <paramref name="scale"/>
            </summary>
            <param name="image">The image</param>
            <param name="scale">The multiplication scale</param>
            <returns><paramref name="image"/> * <paramref name="scale"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Multiply(System.Double,Emgu.CV.Image{`0,`1})">
            <summary>
              <paramref name="scale"/>*<paramref name="image"/>
            </summary>
            <param name="image">The image</param>
            <param name="scale">The multiplication scale</param>
            <returns><paramref name="scale"/>*<paramref name="image"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Multiply(Emgu.CV.Image{`0,`1},Emgu.CV.ConvolutionKernelF)">
            <summary>
            Perform the convolution with <paramref name="kernel"/> on <paramref name="image"/>
            </summary>
            <param name="image">The image</param>
            <param name="kernel">The kernel</param>
            <returns>Result of the convolution</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Division(Emgu.CV.Image{`0,`1},System.Double)">
            <summary>
             <paramref name="image"/> / <paramref name="scale"/>
            </summary>
            <param name="image">The image</param>
            <param name="scale">The division scale</param>
            <returns><paramref name="image"/> / <paramref name="scale"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Division(System.Double,Emgu.CV.Image{`0,`1})">
            <summary>
              <paramref name="scale"/> / <paramref name="image"/>
            </summary>
            <param name="image">The image</param>
            <param name="scale">The scale</param>
            <returns><paramref name="scale"/> / <paramref name="image"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SmoothBlur(System.Int32,System.Int32)">
            <summary>
            Summation over a pixel param1 x param2 neighborhood with subsequent scaling by 1/(param1 x param2)
            </summary>
            <param name="width">The width of the window</param>
            <param name="height">The height of the window</param>
            <returns>The result of blur</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SmoothBlur(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Summation over a pixel param1 x param2 neighborhood. If scale is true, the result is subsequent scaled by 1/(param1 x param2)
            </summary>
            <param name="width">The width of the window</param>
            <param name="height">The height of the window</param>
            <param name="scale">If true, the result is subsequent scaled by 1/(param1 x param2)</param>
            <returns>The result of blur</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SmoothMedian(System.Int32)">
            <summary>
            Finding median of <paramref name="size"/>x<paramref name="size"/> neighborhood 
            </summary>
            <param name="size">The size (width &amp; height) of the window</param>
            <returns>The result of mediam smooth</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SmoothBilatral(System.Int32,System.Int32,System.Int32)">
            <summary>
            Applying bilateral 3x3 filtering
            </summary>
            <param name="colorSigma">Color sigma</param>
            <param name="spaceSigma">Space sigma</param>
            <param name="kernelSize">The size of the bilatral kernel</param>
            <returns>The result of bilateral smooth</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SmoothGaussian(System.Int32)">
            <summary> Perform Gaussian Smoothing in the current image and return the result </summary>
            <param name="kernelSize"> The size of the Gaussian kernel (<paramref name="kernelSize"/> x <paramref name="kernelSize"/>)</param>
            <returns> The smoothed image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SmoothGaussian(System.Int32,System.Int32,System.Double,System.Double)">
            <summary> Perform Gaussian Smoothing in the current image and return the result </summary>
            <param name="kernelWidth"> The width of the Gaussian kernel</param>
            <param name="kernelHeight"> The height of the Gaussian kernel</param>
            <param name="sigma1"> The standard deviation of the Gaussian kernel in the horizontal dimwnsion</param>
            <param name="sigma2"> The standard deviation of the Gaussian kernel in the vertical dimwnsion</param>
            <returns> The smoothed image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2._SmoothGaussian(System.Int32)">
            <summary> Perform Gaussian Smoothing inplace for the current image </summary>
            <param name="kernelSize"> The size of the Gaussian kernel (<paramref name="kernelSize"/> x <paramref name="kernelSize"/>)</param>
        </member>
        <member name="M:Emgu.CV.Image`2._SmoothGaussian(System.Int32,System.Int32,System.Double,System.Double)">
            <summary> Perform Gaussian Smoothing inplace for the current image </summary>
            <param name="kernelWidth"> The width of the Gaussian kernel</param>
            <param name="kernelHeight"> The height of the Gaussian kernel</param>
            <param name="sigma1"> The standard deviation of the Gaussian kernel in the horizontal dimwnsion</param>
            <param name="sigma2"> The standard deviation of the Gaussian kernel in the vertical dimwnsion</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Convolution(Emgu.CV.ConvolutionKernelF,System.Double,Emgu.CV.CvEnum.BorderType)">
            <summary> 
            Performs a convolution using the specific <paramref name="kernel"/> 
            </summary>
            <param name="kernel">The convolution kernel</param>
             <param name="delta">The optional value added to the filtered pixels before storing them in dst</param>
             <param name="borderType">The pixel extrapolation method.</param>
            <returns>The result of the convolution</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Integral">
            <summary>
            Calculates integral images for the source image
            </summary>
            <returns>The integral image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Integral(Emgu.CV.Image{`0,System.Double}@,Emgu.CV.Image{`0,System.Double}@)">
            <summary>
            Calculates integral images for the source image
            </summary>
            <param name="sum">The integral image</param>
            <param name="squareSum">The integral image for squared pixel values</param>
            <returns>The integral image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Integral(Emgu.CV.Image{`0,System.Double}@,Emgu.CV.Image{`0,System.Double}@,Emgu.CV.Image{`0,System.Double}@)">
            <summary>
            Calculates one or more integral images for the source image
            </summary>
            <param name="sum">The integral image</param>
            <param name="squareSum">The integral image for squared pixel values</param>
            <param name="titledSum">The integral for the image rotated by 45 degrees</param>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdAdaptive(`0,Emgu.CV.CvEnum.AdaptiveThresholdType,Emgu.CV.CvEnum.ThresholdType,System.Int32,`0)">
            <summary>
            Transforms grayscale image to binary image. 
            Threshold calculated individually for each pixel. 
            For the method CV_ADAPTIVE_THRESH_MEAN_C it is a mean of <paramref name="blockSize"/> x <paramref name="blockSize"/> pixel
            neighborhood, subtracted by param1. 
            For the method CV_ADAPTIVE_THRESH_GAUSSIAN_C it is a weighted sum (gaussian) of <paramref name="blockSize"/> x <paramref name="blockSize"/> pixel neighborhood, subtracted by param1.
            </summary>
            <param name="maxValue">Maximum value to use with CV_THRESH_BINARY and CV_THRESH_BINARY_INV thresholding types</param>
            <param name="adaptiveType">Adaptive_method </param>
            <param name="thresholdType">Thresholding type. must be one of CV_THRESH_BINARY, CV_THRESH_BINARY_INV  </param>
            <param name="blockSize">The size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, ... </param>
            <param name="param1">Constant subtracted from mean or weighted mean. It may be negative. </param>
            <returns>The result of the adaptive threshold</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdBase(Emgu.CV.Image{`0,`1},`0,`0,Emgu.CV.CvEnum.ThresholdType)">
            <summary> 
            the base threshold method shared by public threshold functions 
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdToZero(`0)">
            <summary> Threshold the image such that: dst(x,y) = src(x,y), if src(x,y)>threshold;  0, otherwise </summary>
            <param name="threshold">The threshold value</param>
            <returns> dst(x,y) = src(x,y), if src(x,y)>threshold;  0, otherwise </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdToZeroInv(`0)">
            <summary> 
            Threshold the image such that: dst(x,y) = 0, if src(x,y)>threshold;  src(x,y), otherwise 
            </summary>
            <param name="threshold">The threshold value</param>
            <returns>The image such that: dst(x,y) = 0, if src(x,y)>threshold;  src(x,y), otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdTrunc(`0)">
            <summary>
            Threshold the image such that: dst(x,y) = threshold, if src(x,y)>threshold; src(x,y), otherwise 
            </summary>
            <param name="threshold">The threshold value</param>
            <returns>The image such that: dst(x,y) = threshold, if src(x,y)>threshold; src(x,y), otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdBinary(`0,`0)">
            <summary> 
            Threshold the image such that: dst(x,y) = max_value, if src(x,y)>threshold; 0, otherwise 
            </summary>
            <returns>The image such that: dst(x,y) = max_value, if src(x,y)>threshold; 0, otherwise </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdBinaryInv(`0,`0)">
            <summary> Threshold the image such that: dst(x,y) = 0, if src(x,y)>threshold;  max_value, otherwise </summary>
            <param name="threshold">The threshold value</param>
            <param name="maxValue">The maximum value of the pixel on the result</param>
            <returns>The image such that: dst(x,y) = 0, if src(x,y)>threshold;  max_value, otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2._ThresholdToZero(`0)">
            <summary> Threshold the image inplace such that: dst(x,y) = src(x,y), if src(x,y)>threshold;  0, otherwise </summary>
            <param name="threshold">The threshold value</param>
        </member>
        <member name="M:Emgu.CV.Image`2._ThresholdToZeroInv(`0)">
            <summary> Threshold the image inplace such that: dst(x,y) = 0, if src(x,y)>threshold;  src(x,y), otherwise </summary>
            <param name="threshold">The threshold value</param>
        </member>
        <member name="M:Emgu.CV.Image`2._ThresholdTrunc(`0)">
            <summary> Threshold the image inplace such that: dst(x,y) = threshold, if src(x,y)>threshold; src(x,y), otherwise </summary>
            <param name="threshold">The threshold value</param>
        </member>
        <member name="M:Emgu.CV.Image`2._ThresholdBinary(`0,`0)">
            <summary> Threshold the image inplace such that: dst(x,y) = max_value, if src(x,y)>threshold; 0, otherwise </summary>
            <param name="threshold">The threshold value</param>
            <param name="maxValue">The maximum value of the pixel on the result</param>
        </member>
        <member name="M:Emgu.CV.Image`2._ThresholdBinaryInv(`0,`0)">
            <summary> Threshold the image inplace such that: dst(x,y) = 0, if src(x,y)>threshold;  max_value, otherwise </summary>
            <param name="threshold">The threshold value</param>
            <param name="maxValue">The maximum value of the pixel on the result</param>
        </member>
        <member name="M:Emgu.CV.Image`2.AvgSdv(`0@,Emgu.CV.Structure.MCvScalar@,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Calculates the average value and standard deviation of array elements, independently for each channel
            </summary>
            <param name="average">The avg color</param>
            <param name="sdv">The standard deviation for each channel</param>
            <param name="mask">The operation mask</param>
        </member>
        <member name="M:Emgu.CV.Image`2.AvgSdv(`0@,Emgu.CV.Structure.MCvScalar@)">
            <summary>
            Calculates the average value and standard deviation of array elements, independently for each channel
            </summary>
            <param name="avg">The avg color</param>
            <param name="sdv">The standard deviation for each channel</param>
        </member>
        <member name="M:Emgu.CV.Image`2.CountNonzero">
            <summary>
            Count the non Zero elements for each channel
            </summary>
            <returns>Count the non Zero elements for each channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.MinMax(System.Double[]@,System.Double[]@,System.Drawing.Point[]@,System.Drawing.Point[]@)">
            <summary>
            Returns the min / max location and values for the image
            </summary>
            <param name="maxLocations">The maximum locations for each channel </param>
            <param name="maxValues">The maximum values for each channel</param>
            <param name="minLocations">The minimum locations for each channel</param>
            <param name="minValues">The minimum values for each channel</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Flip(Emgu.CV.CvEnum.FlipType)">
            <summary> Return a flipped copy of the current image</summary>
            <param name="flipType">The type of the flipping</param>
            <returns> The flipped copy of <i>this</i> image </returns>
        </member>
        <member name="M:Emgu.CV.Image`2._Flip(Emgu.CV.CvEnum.FlipType)">
            <summary> Inplace flip the image</summary>
            <param name="flipType">The type of the flipping</param>
            <returns> The flipped copy of <i>this</i> image </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ConcateVertical(Emgu.CV.Image{`0,`1})">
            <summary>
            Concate the current image with another image vertically.
            </summary>
            <param name="otherImage">The other image to concate</param>
            <returns>A new image that is the vertical concatening of this image and <paramref name="otherImage"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ConcateHorizontal(Emgu.CV.Image{`0,`1})">
            <summary>
            Concate the current image with another image horizontally. 
            </summary>
            <param name="otherImage">The other image to concate</param>
            <returns>A new image that is the horizontal concatening of this image and <paramref name="otherImage"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GetMoments(System.Boolean)">
            <summary>
            Calculates spatial and central moments up to the third order and writes them to moments. The moments may be used then to calculate gravity center of the shape, its area, main axises and various shape characteristics including 7 Hu invariants.
            </summary>
            <param name="binary">If the flag is true, all the zero pixel values are treated as zeroes, all the others are treated as 1's</param>
            <returns>spatial and central moments up to the third order</returns>
        </member>
        <member name="M:Emgu.CV.Image`2._GammaCorrect(System.Double)">
            <summary>
            Gamma corrects this image inplace. The image must have a depth type of Byte.
            </summary>
            <param name="gamma">The gamma value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Split">
            <summary> 
            Split current Image into an array of gray scale images where each element 
            in the array represent a single color channel of the original image
            </summary>
            <returns> 
            An array of gray scale images where each element  
            in the array represent a single color channel of the original image 
            </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Save(System.String)">
            <summary>
            Save this image to the specific file. 
            </summary>
            <param name="fileName">The name of the file to be saved to</param>
            <remarks>The image format is chosen depending on the filename extension, see cvLoadImage. Only 8-bit single-channel or 3-channel (with 'BGR' channel order) images can be saved using this function. If the format, depth or channel order is different, use cvCvtScale and cvCvtColor to convert it before saving, or use universal cvSave to save the image to XML or YAML format.</remarks>
        </member>
        <member name="M:Emgu.CV.Image`2._EqualizeHist">
            <summary>
            The algorithm inplace normalizes brightness and increases contrast of the image.
            For color images, a HSV representation of the image is first obtained and the V (value) channel is histogram normalized
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.LoadImageFromMat(Emgu.CV.Mat)">
            <summary>
            This function load the image data from Mat
            </summary>
            <param name="mat">The Mat</param>
        </member>
        <member name="M:Emgu.CV.Image`2.LoadImageFromIplImagePtr(System.IntPtr)">
            <summary>
            This function load the image data from the iplImage pointer
            </summary>
            <param name="iplImage">The pointer to the iplImage</param>
        </member>
        <member name="M:Emgu.CV.Image`2.FromIplImagePtr(System.IntPtr)">
            <summary>
            Get the managed image from an unmanaged IplImagePointer
            </summary>
            <param name="iplImage">The pointer to the iplImage</param>
            <returns>The managed image from the iplImage pointer</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ToJpegData(System.Int32)">
            <summary>
            Get the jpeg representation of the image
            </summary>
            <returns>An byte array that contains the image as jpeg data</returns>
        </member>
        <member name="P:Emgu.CV.Image`2.Data">
            <summary>
            Get or Set the data for this matrix. The Get function has O(1) complexity. The Set function make a copy of the data
            </summary>
            <remarks>
            If the image contains Byte and width is not a multiple of 4. The second dimension of the array might be larger than the Width of this image.  
            This is necessary since the length of a row need to be 4 align for OpenCV optimization. 
            The Set function always make a copy of the specific value. If the image contains Byte and width is not a multiple of 4. The second dimension of the array created might be larger than the Width of this image.  
            </remarks>
        </member>
        <member name="P:Emgu.CV.Image`2.MIplImage">
            <summary>
            The IplImage structure
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.ROI">
            <summary> 
             Get or Set the region of interest for this image. To clear the ROI, set it to System.Drawing.Rectangle.Empty
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.NumberOfChannels">
            <summary>
            Get the number of channels for this image
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.ManagedArray">
            <summary>
            Get the underneath managed array
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.CvDepth">
            <summary>
            Get the equivalent opencv depth type for this image
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.IsROISet">
            <summary> 
            Indicates if the region of interest has been set
            </summary> 
        </member>
        <member name="P:Emgu.CV.Image`2.Item(System.Int32)">
            <summary>
            Get or Set the specific channel of the current image.
            For Get operation, a copy of the specific channel is returned.
            For Set operation, the specific channel is copied to this image.
            </summary>
            <param name="channel">The channel to get from the current image, zero based index</param>
            <returns>The specific channel of the current image</returns>
        </member>
        <member name="P:Emgu.CV.Image`2.Item(System.Int32,System.Int32)">
            <summary>
            Get or Set the color in the <paramref name="row"/>th row (y direction) and <paramref name="column"/>th column (x direction)
            </summary>
            <param name="row">The zero-based row (y direction) of the pixel </param>
            <param name="column">The zero-based column (x direction) of the pixel</param>
            <returns>The color in the specific <paramref name="row"/> and <paramref name="column"/></returns>
        </member>
        <member name="P:Emgu.CV.Image`2.Item(System.Drawing.Point)">
            <summary>
            Get or Set the color in the <paramref name="location"/>
            </summary>
            <param name="location">the location of the pixel </param>
            <returns>the color in the <paramref name="location"/></returns>
        </member>
        <member name="P:Emgu.CV.Image`2.Bitmap">
            <summary>
            The Get property provide a more efficient way to convert Image&lt;Gray, Byte&gt;, Image&lt;Bgr, Byte&gt; and Image&lt;Bgra, Byte&gt; into Bitmap
            such that the image data is <b>shared</b> with Bitmap. 
            If you change the pixel value on the Bitmap, you change the pixel values on the Image object as well!
            For other types of image this property has the same effect as ToBitmap()
            <b>Take extra caution not to use the Bitmap after the Image object is disposed</b>
            The Set property convert the bitmap to this Image type.
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.Size">
            <summary> 
             Get the size of the array
            </summary>
        </member>
        <member name="T:Emgu.CV.ImageConstants">
            <summary>
            Constants used by the image class
            </summary>
        </member>
        <member name="F:Emgu.CV.ImageConstants.RoiOffset">
            <summary>
            Offset of roi
            </summary>
        </member>
        <member name="T:Emgu.CV.Map`2">
            <summary>
            A Map is similar to an Image, except that the location of the pixels is defined by 
            its area and resolution
            </summary>
            <typeparam name="TColor">The color of this map</typeparam>
            <typeparam name="TDepth">The depth of this map</typeparam>
        </member>
        <member name="M:Emgu.CV.Map`2.#ctor(System.Drawing.RectangleF,System.Drawing.PointF,`0)">
            <summary>
            Create a new Image Map defined by the Rectangle area. The center (0.0, 0.0) of this map is 
            defined by the center of the rectangle.
            </summary>
            <param name="area"></param>
            <param name="resolution">The resolution of x (y), (e.g. a value of 0.5 means each cell in the map is 0.5 unit in x (y) dimension)</param>
            <param name="color"> The initial color of the map</param>
        </member>
        <member name="M:Emgu.CV.Map`2.#ctor(System.Drawing.RectangleF,System.Drawing.PointF)">
            <summary>
            Create a new Image Map defined by the Rectangle area. The center (0.0, 0.0) of this map is 
            defined by the center of the rectangle. The initial value of the map is 0.0
            </summary>
            <param name="area"></param>
            <param name="resolution">The resolution of x (y), (e.g. a value of 0.5 means each cell in the map is 0.5 unit in x (y) dimension)</param>
        </member>
        <member name="M:Emgu.CV.Map`2.MapPointToImagePoint(Emgu.CV.Structure.MCvPoint2D64f)">
            <summary>
            Map a point to a position in the internal image
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.Map`2.MapPointToImagePoint(System.Drawing.PointF)">
            <summary>
            Map a point to a position in the internal image
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.Map`2.ImagePointToMapPoint(System.Drawing.Point)">
            <summary>
            Map an image point to a Map point
            </summary>
            <param name="pt">The point on image</param>
            <returns>The point on map</returns>
        </member>
        <member name="M:Emgu.CV.Map`2.Copy(System.Drawing.RectangleF)">
            <summary>
            Get a copy of the map in the specific area
            </summary>
            <param name="area">the area of the map to be retrieve</param>
            <returns>The area of the map</returns>
        </member>
        <member name="M:Emgu.CV.Map`2.Draw(System.Drawing.RectangleF,`0,System.Int32)">
            <summary>
            Draw a rectangle in the map
            </summary>
            <param name="rect">The rectangle to draw</param>
            <param name="color">The color for the rectangle</param>
            <param name="thickness">The thickness of the rectangle, any value less than or equal to 0 will result in a filled rectangle</param>
        </member>
        <member name="M:Emgu.CV.Map`2.Draw(Emgu.CV.Structure.LineSegment2DF,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary>
            Draw a line segment in the map
            </summary>
            <param name="line">The line to be draw</param>
            <param name="color">The color for the line</param>
            <param name="thickness">The thickness of the line</param>
            <param name="lineType">Line type</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Map`2.Draw(Emgu.CV.Structure.CircleF,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Int32)">
            <summary> Draw a Circle of the specific color and thickness </summary>
            <param name="circle"> The circle to be drawn</param>
            <param name="color"> The color of the circle </param>
            <param name="thickness"> If thickness is less than 1, the circle is filled up </param>
             <param name="lineType">Line type</param>
             <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.Map`2.Draw(Emgu.CV.IConvexPolygonF,`0,System.Int32)">
            <summary> Draw a convex polygon of the specific color and thickness </summary>
            <param name="polygon"> The convex polygon to be drawn</param>
            <param name="color"> The color of the convex polygon </param>
            <param name="thickness"> If thickness is less than 1, the triangle is filled up </param>
        </member>
        <member name="M:Emgu.CV.Map`2.Draw(System.String,System.Drawing.Point,Emgu.CV.CvEnum.FontFace,System.Double,`0,System.Int32,Emgu.CV.CvEnum.LineType,System.Boolean)">
            <summary>
            Draw the text using the specific font on the image
            </summary>
            <param name="message">The text message to be draw</param>
            <param name="fontFace">Font type.</param>
            <param name="fontScale">Font scale factor that is multiplied by the font-specific base size.</param>
            <param name="bottomLeft">The location of the bottom left corner of the font</param>
            <param name="color">The color of the text</param>
            <param name="thickness">Thickness of the lines used to draw a text.</param>
            <param name="lineType">Line type</param>
            <param name="bottomLeftOrigin">When true, the image data origin is at the bottom-left corner. Otherwise, it is at the top-left corner.</param>
        </member>
        <member name="M:Emgu.CV.Map`2.DrawPolyline(System.Drawing.PointF[],System.Boolean,`0,System.Int32)">
            <summary>
            Draw the polyline defined by the array of 2D points
            </summary>
            <param name="pts">the points that defines the poly line</param>
            <param name="isClosed">if true, the last line segment is defined by the last point of the array and the first point of the array</param>
            <param name="color">the color used for drawing</param>
            <param name="thickness">the thinkness of the line</param>
        </member>
        <member name="M:Emgu.CV.Map`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Map`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">streaming context</param>
        </member>
        <member name="P:Emgu.CV.Map`2.Area">
            <summary>
            Get the area of this map as a rectangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Map`2.Resolution">
            <summary>
            Get the resolution of this map as a 2D point
            </summary>
        </member>
        <member name="P:Emgu.CV.Map`2.ROI">
            <summary> 
             Get or Set the region of interest for this map. To clear the ROI, set it to System.Drawing.RectangleF.Empty
            </summary>
        </member>
        <member name="T:Emgu.CV.MatND`1">
            <summary>
            A MatND is a wrapper to cvMatND of OpenCV. 
            </summary>
            <typeparam name="TDepth">The type of depth</typeparam>
        </member>
        <member name="M:Emgu.CV.MatND`1.#ctor(System.Int32[])">
            <summary>
            Create a N-dimensional matrix 
            </summary>
            <param name="sizes">The size for each dimension</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.AllocateData(System.Int32,System.Int32,System.Int32)">
            <summary>
            This function is not implemented for MatND
            </summary>
            <param name="rows">Not implemented</param>
            <param name="cols">Not implemented</param>
            <param name="numberOfChannels">Not implemented</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.DisposeObject">
            <summary>
            Release the matrix and all the memory associate with it
            </summary>
        </member>
        <member name="M:Emgu.CV.MatND`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.DeserializeObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime deserailization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.ReadXml(System.Xml.XmlReader)">
            <summary>
            Not Implemented
            </summary>
            <param name="reader">The XmlReader</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Not Implemented
            </summary>
            <param name="writer">The XmlWriter</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.Convert``1">
            <summary>
            Convert this matrix to different depth
            </summary>
            <typeparam name="TOtherDepth">The depth type to convert to</typeparam>
            <returns>Matrix of different depth</returns>
        </member>
        <member name="M:Emgu.CV.MatND`1.Equals(Emgu.CV.MatND{`0})">
            <summary>
            Check if the two MatND are equal
            </summary>
            <param name="other">The other MatND to compares to</param>
            <returns>True if the two MatND equals</returns>
        </member>
        <member name="P:Emgu.CV.MatND`1.NumberOfChannels">
            <summary>
            This function is not implemented for MatND
            </summary>
        </member>
        <member name="P:Emgu.CV.MatND`1.ManagedArray">
            <summary>
            Get the underneath managed array
            </summary>
        </member>
        <member name="P:Emgu.CV.MatND`1.CvDepth">
            <summary> Get the depth representation for openCV</summary>
        </member>
        <member name="P:Emgu.CV.MatND`1.MCvMatND">
            <summary>
            The MCvMatND structure
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.ANN_MLP">
            <summary>
            Neural network
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.IStatModel">
            <summary>
            Interface for statistical models in OpenCV ML.
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.IStatModel.StatModelPtr">
            <summary>
            Return the pointer to the StatModel object
            </summary>
            <returns>The pointer to the StatModel object</returns>
        </member>
        <member name="M:Emgu.CV.ML.ANN_MLP.#ctor">
            <summary>
            Create a neural network using the specific parameters
            </summary>
        </member>
        <member name="M:Emgu.CV.ML.ANN_MLP.DisposeObject">
            <summary>
            Release the memory associated with this neural network
            </summary>
        </member>
        <member name="M:Emgu.CV.ML.ANN_MLP.SetLayerSizes(Emgu.CV.IInputArray)">
            <summary>
            Sets the layer sizes.
            </summary>
            <param name="layerSizes">Integer vector specifying the number of neurons in each layer including the input and output layers. The very first element specifies the number of elements in the input layer. The last element - number of elements in the output layer.</param>
        </member>
        <member name="M:Emgu.CV.ML.ANN_MLP.SetActivationFunction(Emgu.CV.ML.ANN_MLP.AnnMlpActivationFunction,System.Double,System.Double)">
            <summary>
            Initialize the activation function for each neuron.
            </summary>
            <param name="function">Currently the default and the only fully supported activation function is SigmoidSym </param>
            <param name="param1">The first parameter of the activation function.</param>
            <param name="param2">The second parameter of the activation function.</param>
        </member>
        <member name="M:Emgu.CV.ML.ANN_MLP.SetTrainMethod(Emgu.CV.ML.ANN_MLP.AnnMlpTrainMethod,System.Double,System.Double)">
            <summary>
            Sets training method and common parameters.
            </summary>
            <param name="method">The training method.</param>
            <param name="param1">The param1.</param>
            <param name="param2">The param2.</param>
        </member>
        <member name="P:Emgu.CV.ML.ANN_MLP.TermCriteria">
            <summary>
            Termination criteria of the training algorithm
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.ANN_MLP.BackpropWeightScale">
            <summary>
            BPROP: Strength of the weight gradient term
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.ANN_MLP.BackpropMomentumScale">
            <summary>
            BPROP: Strength of the momentum term (the difference between weights on the 2 previous iterations)
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.ANN_MLP.RpropDW0">
            <summary>
            RPROP: Initial value Delta_0 of update-values Delta_{ij}
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.ANN_MLP.RpropDWPlus">
            <summary>
            RPROP: Increase factor
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.ANN_MLP.RpropDWMinus">
            <summary>
            RPROP: Decrease factor
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.ANN_MLP.RpropDWMin">
            <summary>
            RPROP: Update-values lower limit
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.ANN_MLP.RpropDWMax">
            <summary>
            RPROP: Update-values upper limit
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.ANN_MLP.AnnMlpActivationFunction">
            <summary>
            Possible activation functions
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.ANN_MLP.AnnMlpActivationFunction.Identity">
            <summary>
            Identity
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.ANN_MLP.AnnMlpActivationFunction.SigmoidSym">
            <summary>
            sigmoid symmetric
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.ANN_MLP.AnnMlpActivationFunction.Gaussian">
            <summary>
            Gaussian
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.ANN_MLP.AnnMlpTrainMethod">
            <summary>
            Training method for ANN_MLP
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.ANN_MLP.AnnMlpTrainMethod.Backprop">
            <summary>
            Back-propagation algorithm
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.ANN_MLP.AnnMlpTrainMethod.Rprop">
            <summary>
            Batch RPROP algorithm
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.MlInvoke">
            <summary>
            This class contains functions to call into machine learning library
            </summary>
        </member>
        <member name="M:Emgu.CV.ML.MlInvoke.cveANN_MLPRelease(System.IntPtr@)">
            <summary>
            Release the ANN_MLP model
            </summary>
            <param name="model">The ANN_MLP model to be released</param>
        </member>
        <member name="M:Emgu.CV.ML.MlInvoke.StatModelSave(System.IntPtr,System.IntPtr)">
            <summary>
            Save the statistic model to the specific file
            </summary>
            <param name="statModel">The statistic model to save</param>
            <param name="fileName">The file name to save to</param>
        </member>
        <member name="M:Emgu.CV.ML.MlInvoke.StatModelClear(System.IntPtr)">
            <summary>
            Clear the statistic model
            </summary>
            <param name="statModel">The model to be cleared</param>
        </member>
        <member name="M:Emgu.CV.ML.MlInvoke.cveNormalBayesClassifierDefaultCreate(System.IntPtr@,System.IntPtr@)">
            <summary>
            Create a normal bayes classifier
            </summary>
            <returns>The normal bayes classifier</returns>
        </member>
        <member name="M:Emgu.CV.ML.MlInvoke.cveNormalBayesClassifierRelease(System.IntPtr@)">
            <summary>
            Release the memory associated with the bayes classifier
            </summary>
            <param name="classifier">The classifier to release</param>
        </member>
        <member name="M:Emgu.CV.ML.MlInvoke.cveKNearestCreate(System.IntPtr@,System.IntPtr@)">
            <summary>
            Create a KNearest classifier
            </summary>
            <returns>The KNearest classifier</returns>
        </member>
        <member name="M:Emgu.CV.ML.MlInvoke.cveKNearestRelease(System.IntPtr@)">
            <summary>
            Release the KNearest classifier
            </summary>
            <param name="knearest">The classifier to release</param>
        </member>
        <member name="M:Emgu.CV.ML.MlInvoke.cveEMDefaultCreate(System.IntPtr@,System.IntPtr@)">
            <summary>
            Create a default EM model
            </summary>
            <returns>Pointer to the EM model</returns>
        </member>
        <member name="M:Emgu.CV.ML.MlInvoke.cveEMRelease(System.IntPtr@)">
            <summary>
            Release the EM model
            </summary>
        </member>
        <member name="M:Emgu.CV.ML.MlInvoke.cveEMPredict(System.IntPtr,System.IntPtr,Emgu.CV.Structure.MCvPoint2D64f@,System.IntPtr)">
            <summary>
            Given the EM <paramref name="model"/>, predict the probability of the <paramref name="samples"/>
            </summary>
            <param name="model">The EM model</param>
            <param name="samples">The input samples</param>
            <param name="probs">The prediction results, should have the same # of rows as the <paramref name="samples"/></param>
            <param name="result">The result.</param>
        </member>
        <member name="M:Emgu.CV.ML.MlInvoke.cveSVMDefaultCreate(System.IntPtr@,System.IntPtr@)">
            <summary>
            Create a default SVM model
            </summary>
            <returns>Pointer to the SVM model</returns>
        </member>
        <member name="M:Emgu.CV.ML.MlInvoke.cveSVMRelease(System.IntPtr@)">
            <summary>
            Release the SVM model and all the memory associated to ir
            </summary>
            <param name="model">The SVM model to be released</param>
        </member>
        <member name="M:Emgu.CV.ML.MlInvoke.cveSVMGetDefaultGrid(Emgu.CV.ML.SVM.ParamType,Emgu.CV.ML.MCvParamGrid@)">
            <summary>
            Get the default parameter grid for the specific SVM type
            </summary>
            <param name="type">The SVM type</param>
            <param name="grid">The parameter grid reference, values will be filled in by the function call</param>
        </member>
        <member name="M:Emgu.CV.ML.MlInvoke.cveSVMTrainAuto(System.IntPtr,System.IntPtr,System.Int32,Emgu.CV.ML.MCvParamGrid@,Emgu.CV.ML.MCvParamGrid@,Emgu.CV.ML.MCvParamGrid@,Emgu.CV.ML.MCvParamGrid@,Emgu.CV.ML.MCvParamGrid@,Emgu.CV.ML.MCvParamGrid@,System.Boolean)">
            <summary>
            The method trains the SVM model automatically by choosing the optimal parameters C, gamma, p, nu, coef0, degree from CvSVMParams. By the optimality one mean that the cross-validation estimate of the test set error is minimal. 
            </summary>
            <param name="model">The SVM model</param>
            <param name="trainData">The training data.</param>
            <param name="kFold">Cross-validation parameter. The training set is divided into k_fold subsets, one subset being used to train the model, the others forming the test set. So, the SVM algorithm is executed k_fold times</param>
            <param name="cGrid">cGrid</param>
            <param name="gammaGrid">gammaGrid</param>
            <param name="pGrid">pGrid</param>
            <param name="nuGrid">nuGrid</param>
            <param name="coefGrid">coedGrid</param>
            <param name="degreeGrid">degreeGrid</param>
            <param name="balanced">If true and the problem is 2-class classification then the method creates more balanced cross-validation subsets that is proportions between classes in subsets are close to such proportion in the whole train dataset.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.ML.MlInvoke.cveSVMGetSupportVectors(System.IntPtr,System.IntPtr)">
            <summary>
            The method retrieves a given support vector
            </summary>
            <param name="model">The SVM model</param>
            <param name="supportVectors">The output support vectors</param>
        </member>
        <member name="M:Emgu.CV.ML.MlInvoke.cveDTreesCreate(System.IntPtr@,System.IntPtr@)">
            <summary>
            Create a default decision tree
            </summary>
            <returns>Pointer to the decision tree</returns>
        </member>
        <member name="M:Emgu.CV.ML.MlInvoke.cveDTreesRelease(System.IntPtr@)">
            <summary>
            Release the decision tree model
            </summary>
            <param name="model">The decision tree model to be released</param>
        </member>
        <member name="M:Emgu.CV.ML.MlInvoke.cveRTreesCreate(System.IntPtr@,System.IntPtr@)">
            <summary>
            Create a default random tree
            </summary>
            <returns>Pointer to the random tree</returns>
        </member>
        <member name="M:Emgu.CV.ML.MlInvoke.cveRTreesRelease(System.IntPtr@)">
            <summary>
            Release the random tree model
            </summary>
            <param name="model">The random tree model to be released</param>
        </member>
        <member name="M:Emgu.CV.ML.MlInvoke.cveBoostCreate(System.IntPtr@,System.IntPtr@)">
            <summary>
            Create a default boost classifier
            </summary>
            <returns>Pointer to the boost classifier</returns>
        </member>
        <member name="M:Emgu.CV.ML.MlInvoke.cveBoostRelease(System.IntPtr@)">
            <summary>
            Release the boost classifier
            </summary>
            <param name="model">The boost classifier to be released</param>
        </member>
        <member name="M:Emgu.CV.ML.MlInvoke.cveSVMSGDDefaultCreate(System.IntPtr@,System.IntPtr@)">
            <summary>
            Create a default SVMSGD model
            </summary>
            <returns>Pointer to the SVMSGD model</returns>
        </member>
        <member name="M:Emgu.CV.ML.MlInvoke.cveSVMSGDRelease(System.IntPtr@)">
            <summary>
            Release the SVMSGD model and all the memory associated to ir
            </summary>
            <param name="model">The SVMSGD model to be released</param>
        </member>
        <member name="T:Emgu.CV.ML.Boost">
            <summary>
            Boost Tree 
            </summary>
        </member>
        <member name="M:Emgu.CV.ML.Boost.#ctor">
            <summary>
            Create a default Boost classifier
            </summary>
        </member>
        <member name="M:Emgu.CV.ML.Boost.DisposeObject">
            <summary>
            Release the Boost classifier and all memory associate with it
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.Boost.MaxCategories">
            <summary>
            Cluster possible values of a categorical variable into K less than or equals maxCategories clusters to find a suboptimal split
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.Boost.MaxDepth">
            <summary>
            The maximum possible depth of the tree
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.Boost.MinSampleCount">
            <summary>
            If the number of samples in a node is less than this parameter then the node will not be split
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.Boost.CVFolds">
            <summary>
            If CVFolds greater than 1 then algorithms prunes the built decision tree using K-fold
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.Boost.UseSurrogates">
            <summary>
            If true then surrogate splits will be built
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.Boost.Use1SERule">
            <summary>
            If true then a pruning will be harsher
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.Boost.TruncatePrunedTree">
            <summary>
            If true then pruned branches are physically removed from the tree
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.Boost.RegressionAccuracy">
            <summary>
            Termination criteria for regression trees
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.Boost.Type">
            <summary>
            Boost Type
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.Boost.Type.Discrete">
            <summary>
            Discrete AdaBoost.
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.Boost.Type.Real">
            <summary>
            Real AdaBoost. It is a technique that utilizes confidence-rated predictions and works well with categorical data.
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.Boost.Type.Logit">
            <summary>
            LogitBoost. It can produce good regression fits.
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.Boost.Type.Gentle">
            <summary>
            Gentle AdaBoost. It puts less weight on outlier data points and for that reason is often good with regression data.
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.DTrees">
            <summary>
            Decision Trees 
            </summary>
        </member>
        <member name="M:Emgu.CV.ML.DTrees.#ctor">
            <summary>
            Create a default decision tree
            </summary>
        </member>
        <member name="M:Emgu.CV.ML.DTrees.DisposeObject">
            <summary>
            Release the decision tree and all the memory associate with it
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.DTrees.MaxCategories">
            <summary>
            Cluster possible values of a categorical variable into K less than or equals maxCategories clusters to find a suboptimal split
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.DTrees.MaxDepth">
            <summary>
            The maximum possible depth of the tree
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.DTrees.MinSampleCount">
            <summary>
            If the number of samples in a node is less than this parameter then the node will not be split
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.DTrees.CVFolds">
            <summary>
            If CVFolds greater than 1 then algorithms prunes the built decision tree using K-fold
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.DTrees.UseSurrogates">
            <summary>
            If true then surrogate splits will be built
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.DTrees.Use1SERule">
            <summary>
            If true then a pruning will be harsher
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.DTrees.TruncatePrunedTree">
            <summary>
            If true then pruned branches are physically removed from the tree
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.DTrees.RegressionAccuracy">
            <summary>
            Termination criteria for regression trees
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.EM">
            <summary>
            Expectation Maximization model
            </summary>
        </member>
        <member name="M:Emgu.CV.ML.EM.#ctor">
            <summary>
            Create an Expectation Maximization model
            </summary>
        </member>
        <member name="M:Emgu.CV.ML.EM.trainE(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray)">
            <summary>
            Estimate the Gaussian mixture parameters from a samples set. This variation starts with Expectation step. You need to provide initial means of mixture components. Optionally you can pass initial weights and covariance matrices of mixture components.
            </summary>
            <param name="samples">Samples from which the Gaussian mixture model will be estimated. It should be a one-channel matrix, each row of which is a sample. If the matrix does not have CV_64F type it will be converted to the inner matrix of such type for the further computing.</param>
            <param name="means0">Initial means of mixture components. It is a one-channel matrix of nclusters x dims size. If the matrix does not have CV_64F type it will be converted to the inner matrix of such type for the further computing.</param>
            <param name="covs0">The vector of initial covariance matrices of mixture components. Each of covariance matrices is a one-channel matrix of dims x dims size. If the matrices do not have CV_64F type they will be converted to the inner matrices of such type for the further computing.</param>
            <param name="weights0">Initial weights of mixture components. It should be a one-channel floating-point matrix with 1 x nclusters or nclusters x 1 size.</param>
            <param name="loglikelihoods">The optional output matrix that contains a likelihood logarithm value for each sample. It has nsamples x 1 size and CV_64FC1 type.</param>
            <param name="labels">The optional output "class label" (indices of the most probable mixture component for each sample). It has nsamples x 1 size and CV_32SC1 type.</param>
            <param name="probs">The optional output matrix that contains posterior probabilities of each Gaussian mixture component given the each sample. It has nsamples x nclusters size and CV_64FC1 type.</param>
        </member>
        <member name="M:Emgu.CV.ML.EM.TrainM(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray)">
            <summary>
            Estimate the Gaussian mixture parameters from a samples set.
            This variation starts with Expectation step. Initial values of the model parameters will be estimated by the k-means algorithm.
            Unlike many of the ML models, EM is an unsupervised learning algorithm and it does not take responses (class labels or function values) as input. Instead, it computes the Maximum Likelihood Estimate of the Gaussian mixture parameters from an input sample set, stores all the parameters inside the structure, and optionally computes the output "class label" for each sample.
            The trained model can be used further for prediction, just like any other classifier.
            </summary>
            <param name="samples">Samples from which the Gaussian mixture model will be estimated. It should be a one-channel matrix, each row of which is a sample. If the matrix does not have CV_64F type it will be converted to the inner matrix of such type for the further computing.</param>
            <param name="probs0">The probs0.</param>
            <param name="logLikelihoods">The optional output matrix that contains a likelihood logarithm value for each sample. It has nsamples x 1 size and CV_64FC1 type.</param>
            <param name="labels">The optional output "class label" for each sample(indices of the most probable mixture component for each sample). It has nsamples x 1 size and CV_32SC1 type.</param>
            <param name="probs">The optional output matrix that contains posterior probabilities of each Gaussian mixture component given the each sample. It has nsamples x nclusters size and CV_64FC1 type.</param>
        </member>
        <member name="M:Emgu.CV.ML.EM.Predict(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Predict the probability of the <paramref name="samples"/>
            </summary>
            <param name="samples">The input samples</param>
            <param name="probs">The prediction results, should have the same # of rows as the <paramref name="samples"/></param>
        </member>
        <member name="M:Emgu.CV.ML.EM.DisposeObject">
            <summary>
            Release the memory associated with this EM model
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.EM.ClustersNumber">
            <summary>
            The number of mixtures
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.EM.CovarianceMatrixType">
            <summary>
            The type of the mixture covariation matrices
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.EM.TermCriteria">
            <summary>
            Termination criteria of the procedure. EM algorithm stops either after a certain number of iterations (term_crit.num_iter), or when the parameters change too little (no more than term_crit.epsilon) from iteration to iteration
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.EM.CovarianMatrixType">
            <summary>
            The type of the mixture covariation matrices
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.EM.CovarianMatrixType.Spherical">
            <summary>
            A covariation matrix of each mixture is a scaled identity matrix, ?k*I, so the only parameter to be estimated is ?k. The option may be used in special cases, when the constraint is relevant, or as a first step in the optimization (e.g. in case when the data is preprocessed with PCA). The results of such preliminary estimation may be passed again to the optimization procedure, this time with cov_mat_type=COV_MAT_DIAGONAL
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.EM.CovarianMatrixType.Diagonal">
            <summary>
            A covariation matrix of each mixture may be arbitrary diagonal matrix with positive diagonal elements, that is, non-diagonal elements are forced to be 0's, so the number of free parameters is d  for each matrix. This is most commonly used option yielding good estimation results
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.EM.CovarianMatrixType.Generic">
            <summary>
            A covariation matrix of each mixture may be arbitrary symmetrical positively defined matrix, so the number of free parameters in each matrix is about d2/2. It is not recommended to use this option, unless there is pretty accurate initial estimation of the parameters and/or a huge number of training samples
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.EM.CovarianMatrixType.Default">
            <summary>
            The default
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.KNearest">
            <summary>
            The KNearest classifier
            </summary>
        </member>
        <member name="M:Emgu.CV.ML.KNearest.#ctor">
            <summary>
            Create a default KNearest classifier
            </summary>
        </member>
        <member name="M:Emgu.CV.ML.KNearest.DisposeObject">
            <summary>
            Release the classifier and all the memory associated with it
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.KNearest.DefaultK">
            <summary>
            Default number of neighbors to use in predict method
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.KNearest.IsClassifier">
            <summary>
            Whether classification or regression model should be trained
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.KNearest.Emax">
            <summary>
            Parameter for KDTree implementation
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.KNearest.AlgorithmType">
            <summary>
            Algorithm type
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.LogisticRegression">
            <summary>
            ML implements logistic regression, which is a probabilistic classification technique. 
            </summary>
        </member>
        <member name="M:Emgu.CV.ML.LogisticRegression.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Emgu.CV.ML.LogisticRegression"/> class.
            </summary>
        </member>
        <member name="M:Emgu.CV.ML.LogisticRegression.DisposeObject">
            <summary>
            Release the unmanaged resources
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.LogisticRegression.StatModelPtr">
            <summary>
            Return the pointer to the StatModel object
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.LogisticRegression.AlgorithmPtr">
            <summary>
            Return the pointer to the algorithm object
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.LogisticRegression.LearningRate">
            <summary>
            Learning rate
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.LogisticRegression.Iterations">
            <summary>
            Number of iterations
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.LogisticRegression.Regularization">
            <summary>
            Kind of regularization to be applied
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.LogisticRegression.TrainMethod">
            <summary>
            Kind of training method to be applied
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.LogisticRegression.MiniBatchSize">
            <summary>
            Specifies the number of training samples taken in each step of Mini-Batch Gradient Descent
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.LogisticRegression.TermCriteria">
            <summary>
            Termination criteria of the algorithm
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.LogisticRegression.TrainType">
            <summary>
            Specifies the kind of training method used.
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.LogisticRegression.TrainType.Batch">
            <summary>
            Batch method
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.LogisticRegression.TrainType.MiniBatch">
            <summary>
            Set MiniBatchSize to a positive integer when using this method.
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.LogisticRegression.RegularizationMethod">
            <summary>
            Specifies the kind of regularization to be applied. 
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.LogisticRegression.RegularizationMethod.Disable">
            <summary>
            Regularization disabled.
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.LogisticRegression.RegularizationMethod.L1">
            <summary>
            L1 norm
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.LogisticRegression.RegularizationMethod.L2">
            <summary>
            L2 norm
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.MlEnum.AnnMlpTrainingFlag">
            <summary>
            The flags for the neural network training function
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.MlEnum.AnnMlpTrainingFlag.Default">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.MlEnum.AnnMlpTrainingFlag.UpdateWeights">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.MlEnum.AnnMlpTrainingFlag.NoInputScale">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.MlEnum.AnnMlpTrainingFlag.NoOutputScale">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.MlEnum.DataLayoutType">
            <summary>
            The data layout type
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.MlEnum.DataLayoutType.ColSample">
            <summary>
            Feature vectors are stored as cols
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.MlEnum.DataLayoutType.RowSample">
            <summary>
            Feature vectors are stored as rows
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.MlEnum.BoostType">
            <summary>
            Boosting type
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.MlEnum.BoostType.Discrete">
            <summary>
            Discrete AdaBoost
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.MlEnum.BoostType.Real">
            <summary>
            Real AdaBoost
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.MlEnum.BoostType.Logit">
            <summary>
            LogitBoost
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.MlEnum.BoostType.Gentle">
            <summary>
            Gentle AdaBoost
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.MlEnum.BoostSplitCreiteria">
            <summary>
            Splitting criteria, used to choose optimal splits during a weak tree construction
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.MlEnum.BoostSplitCreiteria.Default">
            <summary>
            Use the default criteria for the particular boosting method, see below
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.MlEnum.BoostSplitCreiteria.Gini">
            <summary>
            Use Gini index. This is default option for Real AdaBoost; may be also used for Discrete AdaBoost
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.MlEnum.BoostSplitCreiteria.Misclass">
            <summary>
            Use misclassification rate. This is default option for Discrete AdaBoost; may be also used for Real AdaBoost
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.MlEnum.BoostSplitCreiteria.Sqerr">
            <summary>
            Use least squares criteria. This is default and the only option for LogitBoost and Gentle AdaBoost
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.MlEnum.VarType">
            <summary>
            Variable type
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.MlEnum.VarType.Numerical">
            <summary>
            Numerical or Ordered
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.MlEnum.VarType.Categorical">
            <summary>
            Catagorical
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.NormalBayesClassifier">
            <summary>
            A Normal Bayes Classifier
            </summary>
        </member>
        <member name="M:Emgu.CV.ML.NormalBayesClassifier.#ctor">
            <summary>
            Create a normal Bayes classifier
            </summary>
        </member>
        <member name="M:Emgu.CV.ML.NormalBayesClassifier.DisposeObject">
            <summary>
            Release the memory associated with this classifier
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.RTrees">
            <summary>
            Random trees
            </summary>
        </member>
        <member name="M:Emgu.CV.ML.RTrees.#ctor">
            <summary>
            Create a random tree
            </summary>
        </member>
        <member name="M:Emgu.CV.ML.RTrees.DisposeObject">
            <summary>
            Release the random tree and all memory associate with it
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.RTrees.MaxCategories">
            <summary>
            Cluster possible values of a categorical variable into K less than or equals maxCategories clusters to find a suboptimal split
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.RTrees.MaxDepth">
            <summary>
            The maximum possible depth of the tree
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.RTrees.MinSampleCount">
            <summary>
            If the number of samples in a node is less than this parameter then the node will not be split
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.RTrees.CVFolds">
            <summary>
            If CVFolds greater than 1 then algorithms prunes the built decision tree using K-fold
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.RTrees.UseSurrogates">
            <summary>
            If true then surrogate splits will be built
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.RTrees.Use1SERule">
            <summary>
            If true then a pruning will be harsher
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.RTrees.TruncatePrunedTree">
            <summary>
            If true then pruned branches are physically removed from the tree
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.RTrees.RegressionAccuracy">
            <summary>
            Termination criteria for regression trees
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.RTrees.CalculateVarImportance">
            <summary>
            If true then variable importance will be calculated
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.RTrees.ActiveVarCount">
            <summary>
            The size of the randomly selected subset of features at each tree node and that are used to find the best split(s)
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.RTrees.TermCriteria">
            <summary>
            The termination criteria that specifies when the training algorithm stops
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.MCvParamGrid">
            <summary>
            Wrapped CvParamGrid structure used by SVM
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.MCvParamGrid.MinVal">
            <summary>
            Minimum value
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.MCvParamGrid.MaxVal">
            <summary>
            Maximum value
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.MCvParamGrid.Step">
            <summary>
            step
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.SVM">
            <summary>
            Support Vector Machine 
            </summary>
        </member>
        <member name="M:Emgu.CV.ML.SVM.#ctor">
            <summary>
            Create a support Vector Machine
            </summary>
        </member>
        <member name="M:Emgu.CV.ML.SVM.DisposeObject">
            <summary>
            Release all the memory associated with the SVM
            </summary>
        </member>
        <member name="M:Emgu.CV.ML.SVM.GetDefaultGrid(Emgu.CV.ML.SVM.ParamType)">
            <summary>
            Get the default parameter grid for the specific SVM type
            </summary>
            <param name="type">The SVM type</param>
            <returns>The default parameter grid for the specific SVM type </returns>
        </member>
        <member name="M:Emgu.CV.ML.SVM.TrainAuto(Emgu.CV.ML.TrainData,System.Int32)">
            <summary>
            The method trains the SVM model automatically by choosing the optimal parameters C, gamma, p, nu, coef0, degree from CvSVMParams. By the optimality one mean that the cross-validation estimate of the test set error is minimal. 
            </summary>
            <param name="trainData">The training data.</param>
            <param name="kFold">Cross-validation parameter. The training set is divided into k_fold subsets, one subset being used to train the model, the others forming the test set. So, the SVM algorithm is executed k_fold times</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.ML.SVM.TrainAuto(Emgu.CV.ML.TrainData,System.Int32,Emgu.CV.ML.MCvParamGrid,Emgu.CV.ML.MCvParamGrid,Emgu.CV.ML.MCvParamGrid,Emgu.CV.ML.MCvParamGrid,Emgu.CV.ML.MCvParamGrid,Emgu.CV.ML.MCvParamGrid,System.Boolean)">
            <summary>
            The method trains the SVM model automatically by choosing the optimal parameters C, gamma, p, nu, coef0, degree from CvSVMParams. By the optimality one mean that the cross-validation estimate of the test set error is minimal. 
            </summary>
            <param name="trainData">The training data.</param>
            <param name="kFold">Cross-validation parameter. The training set is divided into k_fold subsets, one subset being used to train the model, the others forming the test set. So, the SVM algorithm is executed k_fold times</param>
            <param name="cGrid">cGrid</param>
            <param name="gammaGrid">grid for gamma</param>
            <param name="pGrid">grid for p</param>
            <param name="nuGrid">grid for nu</param>
            <param name="coefGrid">grid for coeff</param>
            <param name="degreeGrid">grid for degree</param>
            <param name="balanced">If true and the problem is 2-class classification then the method creates more balanced cross-validation subsets that is proportions between classes in subsets are close to such proportion in the whole train dataset.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.ML.SVM.GetSupportVectors">
            <summary>
            Retrieves all the support vectors.
            </summary>
            <returns>All the support vector as floating-point matrix, where support vectors are stored as matrix rows.</returns>
        </member>
        <member name="M:Emgu.CV.ML.SVM.SetKernel(Emgu.CV.ML.SVM.SvmKernelType)">
            <summary>
            Initialize with one of predefined kernels
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.SVM.Type">
            <summary>
            Type of a SVM formulation
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.SVM.Gamma">
            <summary>
            Parameter gamma of a kernel function
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.SVM.Coef0">
            <summary>
            Parameter coef0 of a kernel function
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.SVM.Degree">
            <summary>
            Parameter degree of a kernel function
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.SVM.C">
            <summary>
            Parameter C of a SVM optimization problem
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.SVM.Nu">
            <summary>
            Parameter nu of a SVM optimization problem
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.SVM.P">
            <summary>
            Parameter epsilon of a SVM optimization problem
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.SVM.TermCriteria">
            <summary>
            Termination criteria of the iterative SVM training procedure which solves a partial case of constrained quadratic optimization problem
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.SVM.KernelType">
            <summary>
            Type of a SVM kernel
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.SVM.SvmType">
            <summary>
            Type of SVM
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.SVM.SvmType.CSvc">
            <summary>
            n-class classification (n>=2), allows imperfect separation of classes with penalty multiplier C for outliers
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.SVM.SvmType.NuSvc">
            <summary>
            n-class classification with possible imperfect separation. Parameter nu (in the range 0..1, the larger the value, the smoother the decision boundary) is used instead of C
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.SVM.SvmType.OneClass">
            <summary>
            one-class SVM. All the training data are from the same class, SVM builds a boundary that separates the class from the rest of the feature space
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.SVM.SvmType.EpsSvr">
            <summary>
            Regression. The distance between feature vectors from the training set and the fitting hyper-plane must be less than p. For outliers the penalty multiplier C is used
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.SVM.SvmType.NuSvr">
            <summary>
            Regression; nu is used instead of p.
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.SVM.SvmKernelType">
            <summary>
            SVM kernel type
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.SVM.SvmKernelType.Custom">
            <summary>
            Custom svm kernel type
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.SVM.SvmKernelType.Linear">
            <summary>
            No mapping is done, linear discrimination (or regression) is done in the original feature space. It is the fastest option. d(x,y) = x y == (x,y)
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.SVM.SvmKernelType.Poly">
            <summary>
            polynomial kernel: d(x,y) = (gamma*(xy)+coef0)^degree
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.SVM.SvmKernelType.Rbf">
            <summary>
            Radial-basis-function kernel; a good choice in most cases: d(x,y) = exp(-gamma*|x-y|^2)
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.SVM.SvmKernelType.Sigmoid">
            <summary>
            sigmoid function is used as a kernel: d(x,y) = tanh(gamma*(xy)+coef0)
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.SVM.SvmKernelType.Chi2">
            <summary>
            Exponential Chi2 kernel, similar to the RBF kernel
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.SVM.SvmKernelType.Inter">
            <summary>
            Histogram intersection kernel. A fast kernel. K(xi,xj)=min(xi,xj).
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.SVM.ParamType">
            <summary>
            The type of SVM parameters
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.SVM.ParamType.C">
            <summary>
            C
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.SVM.ParamType.Gamma">
            <summary>
            Gamma
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.SVM.ParamType.P">
            <summary>
            P
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.SVM.ParamType.Nu">
            <summary>
            NU
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.SVM.ParamType.Coef">
            <summary>
            COEF
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.SVM.ParamType.Degree">
            <summary>
            DEGREE
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.SVMSGD">
            <summary>
            Support Vector Machine 
            </summary>
        </member>
        <member name="M:Emgu.CV.ML.SVMSGD.#ctor">
            <summary>
            Create a support Vector Machine
            </summary>
        </member>
        <member name="M:Emgu.CV.ML.SVMSGD.SetOptimalParameters(Emgu.CV.ML.SVMSGD.SvmsgdType,Emgu.CV.ML.SVMSGD.MarginType)">
            <summary>
            Set the optimal parameters for the given model type
            </summary>
            <param name="svmsgdType">SVMSGD type</param>
            <param name="marginType">Margin type</param>
        </member>
        <member name="M:Emgu.CV.ML.SVMSGD.DisposeObject">
            <summary>
            Release all the memory associated with the SVMSGD model
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.SVMSGD.Type">
            <summary>
            Algorithm type
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.SVMSGD.Margin">
            <summary>
            Margin type
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.SVMSGD.MarginRegularization">
            <summary>
            marginRegularization of a SVMSGD optimization problem
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.SVMSGD.InitialStepSize">
            <summary>
            initialStepSize of a SVMSGD optimization problem
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.SVMSGD.StepDecreasingPower">
            <summary>
            stepDecreasingPower of a SVMSGD optimization problem
            </summary>
        </member>
        <member name="P:Emgu.CV.ML.SVMSGD.TermCriteria">
            <summary>
            Termination criteria of the training algorithm.
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.SVMSGD.SvmsgdType">
            <summary>
            SVMSGD type.
            ASGD is often the preferable choice.
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.SVMSGD.SvmsgdType.Sgd">
            <summary>
            Stochastic Gradient Descent
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.SVMSGD.SvmsgdType.Asgd">
            <summary>
            Average Stochastic Gradient Descent
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.SVMSGD.MarginType">
            <summary>
            Margin type
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.SVMSGD.MarginType.SoftMargin">
            <summary>
            General case, suits to the case of non-linearly separable sets, allows outliers.
            </summary>
        </member>
        <member name="F:Emgu.CV.ML.SVMSGD.MarginType.HardMargin">
            <summary>
            More accurate for the case of linearly separable sets.
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.StatModelExtensions">
            <summary>
            A statistic model
            </summary>
        </member>
        <member name="M:Emgu.CV.ML.StatModelExtensions.Save(Emgu.CV.ML.IStatModel,System.String)">
            <summary>
            Save the statistic model to file
            </summary>
            <param name="model">The StatModel</param>
            <param name="fileName">The file name where this StatModel will be saved</param>
        </member>
        <member name="M:Emgu.CV.ML.StatModelExtensions.Train(Emgu.CV.ML.IStatModel,Emgu.CV.IInputArray,Emgu.CV.ML.MlEnum.DataLayoutType,Emgu.CV.IInputArray)">
            <summary>
            Trains the statistical model.
            </summary>
            <param name="model">The stat model.</param>
            <param name="samples">The training samples.</param>
            <param name="layoutType">Type of the layout.</param>
            <param name="responses">Vector of responses associated with the training samples.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.ML.StatModelExtensions.Train(Emgu.CV.ML.IStatModel,Emgu.CV.ML.TrainData,System.Int32)">
            <summary>
            Trains the statistical model.
            </summary>
            <param name="model">The model.</param>
            <param name="trainData">The train data.</param>
            <param name="flags">The flags.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.ML.StatModelExtensions.Predict(Emgu.CV.ML.IStatModel,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32)">
            <summary>
            Predicts response(s) for the provided sample(s)
            </summary>
            <param name="model">The model.</param>
            <param name="samples">The input samples, floating-point matrix.</param>
            <param name="results">The optional output matrix of results.</param>
            <param name="flags">The optional flags, model-dependent.</param>
            <returns>Response for the provided sample</returns>
        </member>
        <member name="M:Emgu.CV.ML.StatModelExtensions.Clear(Emgu.CV.ML.IStatModel)">
            <summary>
            Clear the statistic model
            </summary>
        </member>
        <member name="T:Emgu.CV.ML.TrainData">
            <summary>
            Train data
            </summary>
        </member>
        <member name="M:Emgu.CV.ML.TrainData.#ctor(Emgu.CV.IInputArray,Emgu.CV.ML.MlEnum.DataLayoutType,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Creates training data from in-memory arrays.
            </summary>
            <param name="samples">Matrix of samples. It should have CV_32F type.</param>
            <param name="layoutType">Type of the layout.</param>
            <param name="response">Matrix of responses. If the responses are scalar, they should be stored as a single row or as a single column. The matrix should have type CV_32F or CV_32S (in the former case the responses are considered as ordered by default; in the latter case - as categorical)</param>
            <param name="varIdx">Vector specifying which variables to use for training. It can be an integer vector (CV_32S) containing 0-based variable indices or byte vector (CV_8U) containing a mask of active variables.</param>
            <param name="sampleIdx">Vector specifying which samples to use for training. It can be an integer vector (CV_32S) containing 0-based sample indices or byte vector (CV_8U) containing a mask of training samples.</param>
            <param name="sampleWeight">Optional vector with weights for each sample. It should have CV_32F type.</param>
            <param name="varType">Optional vector of type CV_8U and size &lt;number_of_variables_in_samples&gt; + &lt;number_of_variables_in_responses&gt;, containing types of each input and output variable.</param>
        </member>
        <member name="M:Emgu.CV.ML.TrainData.DisposeObject">
            <summary>
            Release the unmanaged resources
            </summary>
        </member>
        <member name="T:Emgu.CV.Ocl.Device">
            <summary>
            This class contains ocl runtime information
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.Device.#ctor">
            <summary>
            Create a empty OclDevice object
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.Device.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this OclInfo
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.Device.Set(System.IntPtr)">
            <summary>
            Set the native device pointer
            </summary>
            <param name="nativeDevicePointer"></param>
        </member>
        <member name="M:Emgu.CV.Ocl.Device.ToString">
            <summary>
            Get the string representation of this oclDevice
            </summary>
            <returns>A string representation of this oclDevice</returns>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.Default">
            <summary>
            Get the default OclDevice. Do not dispose this device.
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.NativeDevicePointer">
            <summary>
            Get the native device pointer
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.IsNVidia">
            <summary>
            Indicates if this is an NVidia device
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.IsIntel">
            <summary>
            Indicates if this is an Intel device
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.IsAMD">
            <summary>
            Indicates if this is an AMD device
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.AddressBits">
            <summary>
            The AddressBits
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.LinkerAvailable">
            <summary>
            Indicates if the linker is available
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.CompilerAvailable">
            <summary>
            Indicates if the compiler is available
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.Available">
            <summary>
            Indicates if the device is available
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.MaxWorkGroupSize">
            <summary>
            The maximum work group size
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.MaxComputeUnits">
            <summary>
            The max compute unit
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.LocalMemSize">
            <summary>
            The local memory size
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.MaxMemAllocSize">
            <summary>
            The maximum memory allocation size
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.DeviceVersionMajor">
            <summary>
            The device major version number
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.DeviceVersionMinor">
            <summary>
            The device minor version number
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.HalfFPConfig">
            <summary>
            The device half floating point configuration
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.SingleFPConfig">
            <summary>
            The device single floating point configuration
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.DoubleFPConfig">
            <summary>
            The device double floating point configuration
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.HostUnifiedMemory">
            <summary>
            True if the device use unified memory
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.GlobalMemSize">
            <summary>
            The global memory size
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.Image2DMaxWidth">
            <summary>
            The image 2d max width
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.Image2DMaxHeight">
            <summary>
            The image2d max height
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.Type">
            <summary>
            The ocl device type
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.Name">
            <summary>
            The device name
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.Version">
            <summary>
            The device version
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.VendorName">
            <summary>
            The device vendor name
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.DriverVersion">
            <summary>
            The device driver version
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.Extensions">
            <summary>
            The device extensions
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.OpenCLVersion">
            <summary>
            The device OpenCL version
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Device.OpenCLCVersion">
            <summary>
            The device OpenCL C version
            </summary>
        </member>
        <member name="T:Emgu.CV.Ocl.DeviceType">
            <summary>
            Ocl Device Type
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.DeviceType.Default">
            <summary>
            Default
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.DeviceType.Cpu">
            <summary>
            Cpu
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.DeviceType.Gpu">
            <summary>
            Gpu
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.DeviceType.Accelerator">
            <summary>
            Accerlerator
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.DeviceType.DGpu">
            <summary>
            DGpu
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.DeviceType.IGpu">
            <summary>
            IGpu
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.DeviceType.All">
            <summary>
            All
            </summary>
        </member>
        <member name="T:Emgu.CV.Ocl.FpConfig">
            <summary>
            Floating point configuration
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.FpConfig.Denorm">
            <summary>
            Denorm
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.FpConfig.InfNan">
            <summary>
            inf, nan
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.FpConfig.RoundToNearest">
            <summary>
            round to nearest
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.FpConfig.RoundToZero">
            <summary>
            round to zero
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.FpConfig.RoundToInf">
            <summary>
            round to infinite
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.FpConfig.Fma">
            <summary>
            FMA
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.FpConfig.SoftFloat">
            <summary>
            soft float
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.FpConfig.CorrectlyRoundedDivideSqrt">
            <summary>
            Correctly rounded divide sqrt
            </summary>
        </member>
        <member name="T:Emgu.CV.Ocl.OclInvoke">
            <summary>
            Class that contains ocl functions
            </summary>
            <summary>
            Class that contains ocl functions.
            </summary>
            <summary>
            Class that contains ocl functions.
            </summary>
            <summary>
            Class that contains ocl functions.
            </summary>
            <summary>
            Class that contains ocl functions.
            </summary>
            <summary>
            Class that contains ocl functions.
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.OclInvoke.TypeToString(Emgu.CV.CvEnum.DepthType,System.Int32)">
            <summary>
            Convert the DepthType to a string that represent the OpenCL value type.
            </summary>
            <param name="depthType">The depth type</param>
            <param name="channels">The number of channels</param>
            <returns>A string the repsent the OpenCL value type</returns>
        </member>
        <member name="M:Emgu.CV.Ocl.OclInvoke.GetPlatformsInfo">
            <summary>
            Get all the platform info as a vector
            </summary>
            <returns>The vector of Platfom info</returns>
        </member>
        <member name="T:Emgu.CV.Ocl.Image2D">
            <summary>
            cv::ocl::Image2D
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.Image2D.#ctor(Emgu.CV.UMat,System.Boolean,System.Boolean)">
            <summary>
            Create an OclImage2D object from UMat
            </summary>
            <param name="src">The UMat from which to get image properties and data</param>
            <param name="norm">Flag to enable the use of normalized channel data types</param>
            <param name="alias">Flag indicating that the image should alias the src UMat. If true, changes to the image or src will be reflected in both objects.</param>
        </member>
        <member name="M:Emgu.CV.Ocl.Image2D.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this OclImage2D
            </summary>
        </member>
        <member name="T:Emgu.CV.Ocl.Kernel">
            <summary>
            An opencl kernel
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.Kernel.#ctor">
            <summary>
            Create an opencl kernel
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.Kernel.Create(System.String,Emgu.CV.Ocl.ProgramSource,System.String,Emgu.CV.CvString)">
            <summary>
            Create an opencl kernel
            </summary>
            <param name="kernelName">The name of the kernel</param>
            <param name="programSource">The program source code</param>
            <param name="buildOps">The build options</param>
            <param name="errMsg">Option error message container that can be passed to this function</param>
            <returns>True if the kernel can be created</returns>
        </member>
        <member name="M:Emgu.CV.Ocl.Kernel.DisposeObject">
            <summary>
            Release the opencl kernel
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.Kernel.Set(System.Int32,Emgu.CV.Ocl.Image2D)">
            <summary>
            Set the parameters for the kernel
            </summary>
            <param name="i">The index of the parameter</param>
            <param name="image2d">The ocl image</param>
            <returns>The next index value to be set</returns>
        </member>
        <member name="M:Emgu.CV.Ocl.Kernel.Set(System.Int32,Emgu.CV.UMat)">
            <summary>
            Set the parameters for the kernel
            </summary>
            <param name="i">The index of the parameter</param>
            <param name="umat">The umat</param>
            <returns>The next index value to be set</returns>
        </member>
        <member name="M:Emgu.CV.Ocl.Kernel.Set(System.Int32,System.Int32@)">
            <summary>
            Set the parameters for the kernel
            </summary>
            <param name="i">The index of the parameter</param>
            <param name="value">The value</param>
            <returns>The next index value to be set</returns>
        </member>
        <member name="M:Emgu.CV.Ocl.Kernel.Set(System.Int32,System.Single@)">
            <summary>
            Set the parameters for the kernel
            </summary>
            <param name="i">The index of the parameter</param>
            <param name="value">The value</param>
            <returns>The next index value to be set</returns>
        </member>
        <member name="M:Emgu.CV.Ocl.Kernel.Set(System.Int32,System.Double@)">
            <summary>
            Set the parameters for the kernel
            </summary>
            <param name="i">The index of the parameter</param>
            <param name="value">The value</param>
            <returns>The next index value to be set</returns>
        </member>
        <member name="M:Emgu.CV.Ocl.Kernel.Set(System.Int32,Emgu.CV.Ocl.KernelArg)">
            <summary>
            Set the parameters for the kernel
            </summary>
            <param name="i">The index of the parameter</param>
            <param name="kernelArg">The kernel arg</param>
            <returns>The next index value to be set</returns>
        </member>
        <member name="M:Emgu.CV.Ocl.Kernel.Set(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Set the parameters for the kernel
            </summary>
            <param name="i">The index of the parameter</param>
            <param name="data">The data</param>
            <param name="size">The size of the data in number of bytes</param>
            <returns>The next index value to be set</returns>
        </member>
        <member name="M:Emgu.CV.Ocl.Kernel.Run(System.IntPtr[],System.IntPtr[],System.Boolean,Emgu.CV.Ocl.Queue)">
            <summary>
            Execute the kernel
            </summary>
            <param name="globalsize">The global size</param>
            <param name="localsize">The local size</param>
            <param name="sync">If true, the code is run synchronously (blocking)</param>
            <param name="q">Optional Opencl queue</param>
            <returns>True if the execution is sucessful</returns>
        </member>
        <member name="P:Emgu.CV.Ocl.Kernel.Empty">
            <summary>
            Indicates if the kernel is empty
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.Kernel.NativeKernelPtr">
            <summary>
            The pointer to the native kernel
            </summary>
        </member>
        <member name="T:Emgu.CV.Ocl.KernelArg">
            <summary>
            OpenCL kernel arg
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.KernelArg.#ctor(Emgu.CV.Ocl.KernelArg.Flags,Emgu.CV.UMat,System.Int32,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            Create the OCL kernel arg
            </summary>
            <param name="flags">The flags</param>
            <param name="m">The UMat</param>
            <param name="wscale">wscale</param>
            <param name="iwscale">iwscale</param>
            <param name="obj">obj</param>
            <param name="sz">sz</param>
        </member>
        <member name="M:Emgu.CV.Ocl.KernelArg.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Ocl.KernelArg.Flags">
            <summary>
            KernelArg flags
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.KernelArg.Flags.Local">
            <summary>
            Local
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.KernelArg.Flags.ReadOnly">
            <summary>
            Read only
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.KernelArg.Flags.WriteOnly">
            <summary>
            Write only
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.KernelArg.Flags.ReadWrite">
            <summary>
            Read write
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.KernelArg.Flags.Constant">
            <summary>
            Constant
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.KernelArg.Flags.PtrOnly">
            <summary>
            Ptr only
            </summary>
        </member>
        <member name="F:Emgu.CV.Ocl.KernelArg.Flags.NoSize">
            <summary>
            No size
            </summary>
        </member>
        <member name="T:Emgu.CV.Ocl.PlatformInfo">
            <summary>
            This class contains ocl platform information
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.PlatformInfo.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this OclInfo
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.PlatformInfo.GetDevice(System.Int32)">
            <summary>
            Get the OclDevice with the specific index
            </summary>
            <param name="d">The index of the ocl device</param>
            <returns>The ocl device with the specific index</returns>
        </member>
        <member name="M:Emgu.CV.Ocl.PlatformInfo.ToString">
            <summary>
            Get the string that represent this oclPlatformInfo object
            </summary>
            <returns>A string that represent this oclPlatformInfo object</returns>
        </member>
        <member name="P:Emgu.CV.Ocl.PlatformInfo.Name">
            <summary>
            The platform name
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.PlatformInfo.Version">
            <summary>
            The platform version
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.PlatformInfo.Vendor">
            <summary>
            The platform vendor
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.PlatformInfo.DeviceNumber">
            <summary>
            The number of devices
            </summary>
        </member>
        <member name="T:Emgu.CV.Ocl.ProgramSource">
            <summary>
            Open CL kernel program source code
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.ProgramSource.#ctor(System.String)">
            <summary>
            Create OpenCL program source code
            </summary>
            <param name="source">The source code</param>
        </member>
        <member name="M:Emgu.CV.Ocl.ProgramSource.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this object
            </summary>
        </member>
        <member name="P:Emgu.CV.Ocl.ProgramSource.Source">
            <summary>
            Get the source code as String
            </summary>
        </member>
        <member name="T:Emgu.CV.Ocl.Queue">
            <summary>
            An OpenCL Queue
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.Queue.#ctor">
            <summary>
            OpenCL queue
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.Queue.Finish">
            <summary>
            Wait for the queue to finish
            </summary>
        </member>
        <member name="M:Emgu.CV.Ocl.Queue.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this object.
            </summary>
        </member>
        <member name="T:Emgu.CV.DISOpticalFlow">
            <summary>
            DIS optical flow algorithm.
            This class implements the Dense Inverse Search(DIS) optical flow algorithm.Includes three presets with preselected parameters to provide reasonable trade-off between speed and quality.However, even the slowest preset is still relatively fast, use DeepFlow if you need better quality and don't care about speed.
            More details about the algorithm can be found at:
            Till Kroeger, Radu Timofte, Dengxin Dai, and Luc Van Gool. Fast optical flow using dense inverse search. In Proceedings of the European Conference on Computer Vision (ECCV), 2016.
            </summary>
        </member>
        <member name="T:Emgu.CV.IDenseOpticalFlow">
            <summary>
            Dense Optical flow
            </summary>
        </member>
        <member name="P:Emgu.CV.IDenseOpticalFlow.DenseOpticalFlowPtr">
            <summary>
            Gets the dense optical flow pointer.
            </summary>
            <value>
            The dense optical flow .
            </value>
        </member>
        <member name="M:Emgu.CV.DISOpticalFlow.#ctor(Emgu.CV.DISOpticalFlow.Preset)">
            <summary>
            Create an instance of DIS optical flow algorithm.
            </summary>
            <param name="preset">Algorithm preset</param>
        </member>
        <member name="M:Emgu.CV.DISOpticalFlow.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this Optical flow algorithm.
            </summary>
        </member>
        <member name="P:Emgu.CV.DISOpticalFlow.AlgorithmPtr">
            <summary>
            Pointer to cv::Algorithm
            </summary>
        </member>
        <member name="P:Emgu.CV.DISOpticalFlow.DenseOpticalFlowPtr">
            <summary>
            Pointer to native cv::DenseOpticalFlow
            </summary>
        </member>
        <member name="P:Emgu.CV.DISOpticalFlow.FinestScale">
            <summary>
            Finest level of the Gaussian pyramid on which the flow is computed (zero level corresponds to the original image resolution). The final flow is obtained by bilinear upscaling.
            </summary>
        </member>
        <member name="P:Emgu.CV.DISOpticalFlow.PatchSize">
            <summary>
            Size of an image patch for matching (in pixels). Normally, default 8x8 patches work well enough in most cases.
            </summary>
        </member>
        <member name="P:Emgu.CV.DISOpticalFlow.PatchStride">
            <summary>
            Stride between neighbor patches. Must be less than patch size. Lower values correspond to higher flow quality.
            </summary>
        </member>
        <member name="P:Emgu.CV.DISOpticalFlow.GradientDescentIterations">
            <summary>
            Maximum number of gradient descent iterations in the patch inverse search stage. Higher values may improve quality in some cases.
            </summary>
        </member>
        <member name="P:Emgu.CV.DISOpticalFlow.VariationalRefinementIterations">
            <summary>
            Number of fixed point iterations of variational refinement per scale. Set to zero to disable variational refinement completely. Higher values will typically result in more smooth and high-quality flow.
            </summary>
        </member>
        <member name="P:Emgu.CV.DISOpticalFlow.VariationalRefinementAlpha">
            <summary>
            Weight of the smoothness term
            </summary>
        </member>
        <member name="P:Emgu.CV.DISOpticalFlow.VariationalRefinementDelta">
            <summary>
            Weight of the color constancy term
            </summary>
        </member>
        <member name="P:Emgu.CV.DISOpticalFlow.VariationalRefinementGamma">
            <summary>
            Weight of the gradient constancy term
            </summary>
        </member>
        <member name="P:Emgu.CV.DISOpticalFlow.UseMeanNormalization">
            <summary>
            Whether to use mean-normalization of patches when computing patch distance. It is turned on by default as it typically provides a noticeable quality boost because of increased robustness to illumination variations. Turn it off if you are certain that your sequence doesn't contain any changes in illumination.
            </summary>
        </member>
        <member name="P:Emgu.CV.DISOpticalFlow.UseSpatialPropagation">
            <summary>
            Whether to use spatial propagation of good optical flow vectors. This option is turned on by default, as it tends to work better on average and can sometimes help recover from major errors introduced by the coarse-to-fine scheme employed by the DIS optical flow algorithm. Turning this option off can make the output flow field a bit smoother, however.
            </summary>
        </member>
        <member name="T:Emgu.CV.DISOpticalFlow.Preset">
            <summary>
            Preset
            </summary>
        </member>
        <member name="F:Emgu.CV.DISOpticalFlow.Preset.UltraFast">
            <summary>
            Ultra fast
            </summary>
        </member>
        <member name="F:Emgu.CV.DISOpticalFlow.Preset.Fast">
            <summary>
            Fast
            </summary>
        </member>
        <member name="F:Emgu.CV.DISOpticalFlow.Preset.Medium">
            <summary>
            Medium
            </summary>
        </member>
        <member name="T:Emgu.CV.MotionHistory">
            <summary>
            The motion history class
            </summary>
            <remarks>
            For help on using this class, take a look at the Motion Detection example
            </remarks>
        </member>
        <member name="M:Emgu.CV.MotionHistory.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Create a motion history object
            </summary>
            <param name="mhiDuration">In second, the duration of motion history you wants to keep</param>
            <param name="maxTimeDelta">In second. Any change happens between a time interval greater than this will not be considered</param>
            <param name="minTimeDelta">In second. Any change happens between a time interval smaller than this will not be considered.</param>
        </member>
        <member name="M:Emgu.CV.MotionHistory.#ctor(System.Double,System.Double,System.Double,System.DateTime)">
            <summary>
            Create a motion history object
            </summary>
            <param name="mhiDuration">In second, the duration of motion history you wants to keep</param>
            <param name="maxTimeDelta">In second. Any change happens between a time interval larger than this will not be considered</param>
            <param name="minTimeDelta">In second. Any change happens between a time interval smaller than this will not be considered.</param>
            <param name="startTime">The start time of the motion history</param>
        </member>
        <member name="M:Emgu.CV.MotionHistory.Update(Emgu.CV.Mat)">
            <summary>
            Update the motion history with the specific image and current timestamp
            </summary>
            <param name="image">The image to be added to history</param>
        </member>
        <member name="M:Emgu.CV.MotionHistory.Update(Emgu.CV.Mat,System.DateTime)">
            <summary>
            Update the motion history with the specific image and the specific timestamp
            </summary>
            <param name="foregroundMask">The foreground of the image to be added to history</param>
            <param name="timestamp">The time when the image is captured</param>
        </member>
        <member name="M:Emgu.CV.MotionHistory.GetMotionComponents(Emgu.CV.IOutputArray,Emgu.CV.Util.VectorOfRect)">
            <summary>
            Get a sequence of motion component
            </summary>
            <returns>A sequence of motion components</returns>
        </member>
        <member name="M:Emgu.CV.MotionHistory.MotionInfo(Emgu.CV.Mat,System.Drawing.Rectangle,System.Double@,System.Double@)">
            <summary>
            Given a rectangle area of the motion, output the angle of the motion and the number of pixels that are considered to be motion pixel 
            </summary>
            <param name="motionRectangle">The rectangle area of the motion</param>
            <param name="angle">The orientation of the motion</param>
            <param name="motionPixelCount">Number of motion pixels within silhouette ROI</param>
            <param name="forgroundMask">The foreground mask used to calculate the motion info.</param>
        </member>
        <member name="M:Emgu.CV.MotionHistory.DisposeObject">
            <summary>
            Release unmanaged resources
            </summary>
        </member>
        <member name="M:Emgu.CV.MotionHistory.ReleaseManagedResources">
            <summary>
            Release any images associated with this object
            </summary>
        </member>
        <member name="P:Emgu.CV.MotionHistory.Mask">
            <summary>
            The motion mask. 
            Do not dispose this image.
            </summary>
        </member>
        <member name="T:Emgu.CV.OptFlowDeepFlow">
            <summary>
            DeepFlow optical flow algorithm implementation.
            </summary>
        </member>
        <member name="M:Emgu.CV.OptFlowDeepFlow.#ctor">
            <summary>
            Create an instance of DeepFlow optical flow algorithm.
            </summary>
        </member>
        <member name="M:Emgu.CV.OptFlowDeepFlow.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this Object
            </summary>
        </member>
        <member name="P:Emgu.CV.OptFlowDeepFlow.AlgorithmPtr">
            <summary>
            Pointer to the unmanaged cv::Algorithm
            </summary>
        </member>
        <member name="P:Emgu.CV.OptFlowDeepFlow.DenseOpticalFlowPtr">
            <summary>
            Pointer to the unmanaged cv::DenseOpticalFlow
            </summary>
        </member>
        <member name="T:Emgu.CV.OpticalFlowPCAFlow">
            <summary>
            PCAFlow algorithm.
            </summary>
        </member>
        <member name="M:Emgu.CV.OpticalFlowPCAFlow.#ctor">
            <summary>
            Creates an instance of PCAFlow
            </summary>
        </member>
        <member name="M:Emgu.CV.OpticalFlowPCAFlow.DisposeObject">
            <summary>
            Release the memory associated with this PCA Flow algorithm
            </summary>
        </member>
        <member name="P:Emgu.CV.OpticalFlowPCAFlow.AlgorithmPtr">
            <summary>
            Pointer to cv::Algorithm
            </summary>
        </member>
        <member name="P:Emgu.CV.OpticalFlowPCAFlow.DenseOpticalFlowPtr">
            <summary>
            Pointer to native cv::DenseOpticalFlow
            </summary>
        </member>
        <member name="T:Emgu.CV.VariationalRefinement">
            <summary>
            This class implements variational refinement of the input flow field, i.e. it uses input flow to initialize the minimization of the following functional: E(U)=(EI)+(EG)+(ES), where EI,EG,ES are color constancy, gradient constancy and smoothness terms respectively. (s2)=sqrt(s^2+^2) is a robust penalizer to limit the influence of outliers.
            </summary>
            <remarks>See: Thomas Brox, Andres Bruhn, Nils Papenberg, and Joachim Weickert. High accuracy optical flow estimation based on a theory for warping. In Computer Vision-ECCV 2004, pages 2536. Springer, 2004.</remarks>
        </member>
        <member name="M:Emgu.CV.VariationalRefinement.#ctor">
            <summary>
            Create an instance of Variational Refinement.
            </summary>
        </member>
        <member name="M:Emgu.CV.VariationalRefinement.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this Optical flow algorithm.
            </summary>
        </member>
        <member name="P:Emgu.CV.VariationalRefinement.AlgorithmPtr">
            <summary>
            Pointer to the unmanaged cv::Algorithm
            </summary>
        </member>
        <member name="P:Emgu.CV.VariationalRefinement.DenseOpticalFlowPtr">
            <summary>
            Pointer to the unmanaged cv::DenseOpticalFlow
            </summary>
        </member>
        <member name="P:Emgu.CV.VariationalRefinement.FixedPointIterations">
            <summary>
            Number of outer (fixed-point) iterations in the minimization procedure.
            </summary>
        </member>
        <member name="P:Emgu.CV.VariationalRefinement.SorIterations">
            <summary>
            Number of inner successive over-relaxation (SOR) iterations in the minimization procedure to solve the respective linear system.
            </summary>
        </member>
        <member name="P:Emgu.CV.VariationalRefinement.Omega">
            <summary>
            Relaxation factor in SOR
            </summary>
        </member>
        <member name="P:Emgu.CV.VariationalRefinement.Alpha">
            <summary>
            Weight of the smoothness term
            </summary>
        </member>
        <member name="P:Emgu.CV.VariationalRefinement.Delta">
            <summary>
            Weight of the color constancy term
            </summary>
        </member>
        <member name="P:Emgu.CV.VariationalRefinement.Gamma">
            <summary>
            Weight of the gradient constancy term
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.NormType">
            <summary>
            Type for cvNorm
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.C">
            <summary>
            if arr2 is NULL, norm = ||arr1||_C = max_I abs(arr1(I));
            if arr2 is not NULL, norm = ||arr1-arr2||_C = max_I abs(arr1(I)-arr2(I))
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.L1">
            <summary>
            if arr2 is NULL, norm = ||arr1||_L1 = sum_I abs(arr1(I));
            if arr2 is not NULL, norm = ||arr1-arr2||_L1 = sum_I abs(arr1(I)-arr2(I))
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.L2">
            <summary>
            if arr2 is NULL, norm = ||arr1||_L2 = sqrt( sum_I arr1(I)^2);
            if arr2 is not NULL, norm = ||arr1-arr2||_L2 = sqrt( sum_I (arr1(I)-arr2(I))^2 )
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.NormMask">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.Relative">
            <summary>
            It is used in combination with either CV_C, CV_L1 or CV_L2
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.Diff">
            <summary>
            It is used in combination with either CV_C, CV_L1 or CV_L2
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.MinMax">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.DiffC">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.DiffL1">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.DiffL2">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.RelativeC">
            <summary>
            norm = ||arr1-arr2||_C/||arr2||_C
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.RelativeL1">
            <summary>
            norm = ||arr1-arr2||_L1/||arr2||_L1
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NormType.RelativeL2">
            <summary>
            norm = ||arr1-arr2||_L2/||arr2||_L2
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ReduceType">
            <summary>
            Type used for cvReduce function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ReduceType.ReduceSum">
            <summary>
            The output is the sum of all the matrix rows/columns
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ReduceType.ReduceAvg">
            <summary>
            The output is the mean vector of all the matrix rows/columns
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ReduceType.ReduceMax">
            <summary>
            The output is the maximum (column/row-wise) of all the matrix rows/columns
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ReduceType.ReduceMin">
            <summary>
            The output is the minimum (column/row-wise) of all the matrix rows/columns
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ReduceDimension">
            <summary>
            Type used for cvReduce function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ReduceDimension.SingleRow">
            <summary>
            The matrix is reduced to a single row
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ReduceDimension.SingleCol">
            <summary>
            The matrix is reduced to a single column
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ReduceDimension.Auto">
            <summary>
            The dimension is chosen automatically by analysing the dst size
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CmpType">
            <summary>
            Type used for cvCmp function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CmpType.Equal">
            <summary>
            src1(I) "equal to" src2(I)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CmpType.GreaterThan">
            <summary>
            src1(I) "greater than" src2(I)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CmpType.GreaterEqual">
            <summary>
            src1(I) "greater or equal" src2(I)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CmpType.LessThan">
            <summary>
            src1(I) "less than" src2(I)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CmpType.LessEqual">
            <summary>
            src1(I) "less or equal" src2(I)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CmpType.NotEqual">
            <summary>
            src1(I) "not equal to" src2(I)
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CapProp">
            <summary>
            CV Capture property identifier
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.DC1394Off">
            <summary>
            Turn the feature off (not controlled manually nor automatically)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.DC1394ModeManual">
            <summary>
            Set automatically when a value of the feature is set by the user
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.DC1394ModeAuto">
            <summary>
            DC1394 mode auto
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.DC1394ModeOnePushAuto">
            <summary>
            DC1394 mode one push auto
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.PosMsec">
            <summary>
            Film current position in milliseconds or video capture timestamp
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.PosFrames">
            <summary>
            0-based index of the frame to be decoded/captured next
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.PosAviRatio">
            <summary>
            Position in relative units (0 - start of the file, 1 - end of the file)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.FrameWidth">
            <summary>
            Width of frames in the video stream
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.FrameHeight">
            <summary>
            Height of frames in the video stream
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Fps">
            <summary>
            Frame rate 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.FourCC">
            <summary>
            4-character code of codec
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.FrameCount">
            <summary>
            Number of frames in video file
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Format">
            <summary>
            Format
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Mode">
            <summary>
            Mode
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Brightness">
            <summary>
            Brightness
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Contrast">
            <summary>
            Contrast
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Saturation">
            <summary>
            Saturation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Hue">
            <summary>
            Hue
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Gain">
            <summary>
            Gain
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Exposure">
            <summary>
            Exposure
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.ConvertRgb">
            <summary>
            Convert RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.WhiteBalanceBlueU">
            <summary>
            White balance blue u
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Rectification">
            <summary>
            Rectification
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Monochrome">
            <summary>
            Monochrome
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Sharpness">
            <summary>
            Sharpness
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.AutoExposure">
            <summary>
            Exposure control done by camera, user can adjust reference level using this feature
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Gamma">
            <summary>
            Gamma
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Temperature">
            <summary>
            Temperature
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Trigger">
            <summary>
            Trigger
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.TriggerDelay">
            <summary>
            Trigger delay
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.WhiteBalanceRedV">
            <summary>
            White balance red v
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Zoom">
            <summary>
            Zoom
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Focus">
            <summary>
            Focus
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Guid">
            <summary>
            GUID
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.IsoSpeed">
            <summary>
            ISO SPEED
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.MaxDC1394">
            <summary>
            MAX DC1394
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Backlight">
            <summary>
            Backlight
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Pan">
            <summary>
            Pan
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Tilt">
            <summary>
            Tilt
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Roll">
            <summary>
            Roll
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Iris">
            <summary>
            Iris
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Settings">
            <summary>
            Settings
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Buffersuze">
            <summary>
            Buffer size
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Autofocus">
            <summary>
            Auto focus
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.SarNum">
            <summary>
            Sar num
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.SarDen">
            <summary>
            Sar den
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Autograb">
            <summary>
            property for highgui class CvCapture_Android only
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.SupportedPreviewSizesString">
            <summary>
            readonly, tricky property, returns cpnst char* indeed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.PreviewFormat">
            <summary>
            readonly, tricky property, returns cpnst char* indeed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniDepthGenerator">
            <summary>
            OpenNI depth generator
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniImageGenerator">
            <summary>
            OpenNI image generator
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniIRGenerator">
            <summary>
            OpenNI IR generator
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniGeneratorsMask">
            <summary>
            OpenNI map generators
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniOutputMode">
            <summary>
            Properties of cameras available through OpenNI interfaces
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniFrameMaxDepth">
            <summary>
            Properties of cameras available through OpenNI interfaces, in mm.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniBaseline">
            <summary>
            Properties of cameras available through OpenNI interfaces, in mm.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniFocalLength">
            <summary>
            Properties of cameras available through OpenNI interfaces, in pixels.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniRegistration">
            <summary>
            Flag that synchronizes the remapping depth map to image map
            by changing depth generator's view point (if the flag is "on") or
            sets this view point to its normal one (if the flag is "off").
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniRegistrationOn">
            <summary>
            Flag that synchronizes the remapping depth map to image map
            by changing depth generator's view point (if the flag is "on") or
            sets this view point to its normal one (if the flag is "off").
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniApproxFrameSync">
            <summary>
            Approx frame sync
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniMaxBufferSize">
            <summary>
            Max buffer size
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniCircleBuffer">
            <summary>
            Circle buffer
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniMaxTimeDuration">
            <summary>
            Max time duration
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniGeneratorPresent">
            <summary>
            Generator present
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Openni2Sync">
            <summary>
            OpenNI2 Sync
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.Openni2Mirror">
            <summary>
            OpenNI2 Mirror
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniImageGeneratorPresent">
            <summary>
            Openni image generator present
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniImageGeneratorOutputMode">
            <summary>
            Image generator output mode
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniDepthGeneratorPresent">
            <summary>
            Depth generator present
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniDepthGeneratorBaseline">
            <summary>
            Depth generator baseline, in mm.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniDepthGeneratorFocalLength">
            <summary>
            Depth generator focal length, in pixels.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniDepthGeneratorRegistration">
            <summary>
            Openni generator registration
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniDepthGeneratorRegistrationOn">
            <summary>
            Openni generator registration on
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.OpenniIRGeneratorPresent">
            <summary>
            Openni IR generator present
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.GstreamerQueueLength">
            <summary>
            Properties of cameras available through GStreamer interface. Default is 1
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.PvapiMulticastip">
            <summary>
            Ip for enable multicast master mode. 0 for disable multicast
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.PvapiFrameStartTriggerMode">
            <summary>
            FrameStartTriggerMode: Determines how a frame is initiated
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.PvapiDecimationHorizontal">
            <summary>
            Horizontal sub-sampling of the image
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.PvapiDecimationVertical">
            <summary>
            Vertical sub-sampling of the image
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.PvapiBinningX">
            <summary>
            Horizontal binning factor
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.PvapiBinningY">
            <summary>
            Vertical binning factor
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.PvapiPixelFormat">
            <summary>
            Pixel format
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiDownsampling">
            <summary>
            Change image resolution by binning or skipping.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiDataFormat">
            <summary>
            Output data format
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiOffsetX">
            <summary>
            Horizontal offset from the origin to the area of interest (in pixels).
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiOffsetY">
            <summary>
            Vertical offset from the origin to the area of interest (in pixels).
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiTrgSource">
            <summary>
            Defines source of trigger.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiTrgSoftware">
            <summary>
            Generates an internal trigger. PRM_TRG_SOURCE must be set to TRG_SOFTWARE.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiGpiSelector">
            <summary>
            Selects general purpose input
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiGpiMode">
            <summary>
            Set general purpose input mode
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiGpiLevel">
            <summary>
            Get general purpose level
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiGpoSelector">
            <summary>
            Selects general purpose output
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiGpoMode">
            <summary>
            Set general purpose output mode
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiLedSelector">
            <summary>
            Selects camera signaling LED
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiLedMode">
            <summary>
            Define camera signaling LED functionality
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiManualWb">
            <summary>
            Calculates White Balance(must be called during acquisition)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiAutoWb">
            <summary>
            Automatic white balance
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiAeag">
            <summary>
            Automatic exposure/gain
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiExpPriority">
            <summary>
            Exposure priority (0.5 - exposure 50%, gain 50%).
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiAeMaxLimit">
            <summary>
            Maximum limit of exposure in AEAG procedure
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiAgMaxLimit">
            <summary>
            Maximum limit of gain in AEAG procedure
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiAeagLevel">
            <summary>
            Average intensity of output signal AEAG should achieve(in %)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiTimeout">
            <summary>
            Image capture timeout in milliseconds
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiExposure">
            <summary>
            Exposure time in microseconds
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiExposureBurstCount">
            <summary>
            Sets the number of times of exposure in one frame.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiGainSelector">
            <summary>
            Gain selector for parameter Gain allows to select different type of gains.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiGain">
            <summary>
            Gain in dB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiDownsamplingType">
            <summary>
            Change image downsampling type.
            </summary> 
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiBinningSelector">
            <summary>
            Binning engine selector.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiBinningVertical">
            <summary>
            Vertical Binning - number of vertical photo-sensitive cells to combine together.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiBinningHorizontal">
            <summary>
            Horizontal Binning - number of horizontal photo-sensitive cells to combine together.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiBinningPattern">
            <summary>
            Binning pattern type.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiDecimationSelector">
            <summary>
            Decimation engine selector.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiDecimationVertical">
            <summary>
            Vertical Decimation - vertical sub-sampling of the image - reduces the vertical resolution of the image by the specified vertical decimation factor.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiDecimationHorizontal">
            <summary>
            Horizontal Decimation - horizontal sub-sampling of the image - reduces the horizontal resolution of the image by the specified vertical decimation factor.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiDecimationPattern">
            <summary>
            Decimation pattern type.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiTestPatternGeneratorSelector">
            <summary>
            Selects which test pattern generator is controlled by the TestPattern feature.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiTestPattern">
            <summary>
            Selects which test pattern type is generated by the selected generator.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiImageDataFormat">
            <summary>
            Output data format.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiShutterType">
            <summary>
            Change sensor shutter type(CMOS sensor).
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiSensorTaps">
            <summary>
            Number of taps
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiAeagRoiOffsetX">
            <summary>
            Automatic exposure/gain ROI offset X
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiAeagRoiOffsetY">
            <summary>
            Automatic exposure/gain ROI offset Y
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiAeagRoiWidth">
            <summary>
            Automatic exposure/gain ROI Width
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiAeagRoiHeight">
            <summary>
            Automatic exposure/gain ROI Height
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiBpc">
            <summary>
            Correction of bad pixels
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiWbKr">
            <summary>
            White balance red coefficient
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiWbKg">
            <summary>
            White balance green coefficient
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiWbKb">
            <summary>
            White balance blue coefficient
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiWidth">
            <summary>
            Width of the Image provided by the device (in pixels).
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiHeight">
            <summary>
            Height of the Image provided by the device (in pixels).
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiRegionSelector">
            <summary>
            Selects Region in Multiple ROI which parameters are set by width, height, ... ,region mode
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiRegionMode">
            <summary>
            Activates/deactivates Region selected by Region Selector
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiLimitBandwidth">
            <summary>
            Set/get bandwidth(datarate)(in Megabits)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiSensorDataBitDepth">
            <summary>
            Sensor output data bit depth.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiOutputDataBitDepth">
            <summary>
            Device output data bit depth.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiImageDataBitDepth">
            <summary>
            bitdepth of data returned by function xiGetImage
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiOutputDataPacking">
            <summary>
            Device output data packing (or grouping) enabled. Packing could be enabled if output_data_bit_depth > 8 and packing capability is available.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiOutputDataPackingType">
            <summary>
            Data packing type. Some cameras supports only specific packing type.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiIsCooled">
            <summary>
            Returns 1 for cameras that support cooling.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiCooling">
            <summary>
            Start camera cooling.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiTargetTemp">
            <summary>
            Set sensor target temperature for cooling.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiChipTemp">
            <summary>
            Camera sensor temperature
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiHousTemp">
            <summary>
            Camera housing temperature
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiHousBackSideTemp">
            <summary>
            Camera housing back side temperature
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiSensorBoardTemp">
            <summary>
            Camera sensor board temperature
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiCms">
            <summary>
            Mode of color management system.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiApplyCms">
            <summary>
            Enable applying of CMS profiles to xiGetImage (see XI_PRM_INPUT_CMS_PROFILE, XI_PRM_OUTPUT_CMS_PROFILE).
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiImageIsColor">
            <summary>
            Returns 1 for color cameras.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiColorFilterArray">
            <summary>
            Returns color filter array type of RAW data.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiGammay">
            <summary>
            Luminosity gamma
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiGammac">
            <summary>
            Chromaticity gamma
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiSharpness">
            <summary>
            Sharpness Strength
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiCcMatrix00">
            <summary>
            Color Correction Matrix element [0][0]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiCcMatrix01">
            <summary>
            Color Correction Matrix element [0][1]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiCcMatrix02">
            <summary>
            Color Correction Matrix element [0][2]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiCcMatrix03">
            <summary>
            Color Correction Matrix element [0][3]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiCcMatrix10">
            <summary>
            Color Correction Matrix element [1][0]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiCcMatrix11">
            <summary>
            Color Correction Matrix element [1][1]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiCcMatrix12">
            <summary>
            Color Correction Matrix element [1][2]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiCcMatrix13">
            <summary>
            Color Correction Matrix element [1][3]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiCcMatrix20">
            <summary>
            Color Correction Matrix element [2][0]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiCcMatrix21">
            <summary>
            Color Correction Matrix element [2][1]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiCcMatrix22">
            <summary>
            Color Correction Matrix element [2][2]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiCcMatrix23">
            <summary>
            Color Correction Matrix element [2][3]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiCcMatrix30">
            <summary>
            Color Correction Matrix element [3][0]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiCcMatrix31">
            <summary>
            Color Correction Matrix element [3][1]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiCcMatrix32">
            <summary>
            Color Correction Matrix element [3][2]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiCcMatrix33">
            <summary>
            Color Correction Matrix element [3][3]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiDefaultCcMatrix">
            <summary>
            Set default Color Correction Matrix
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiTrgSelector">
            <summary>
            Selects the type of trigger.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiAcqFrameBurstCount">
            <summary>
            Sets number of frames acquired by burst. This burst is used only if trigger is set to FrameBurstStart
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiDebounceEn">
            <summary>
            Enable/Disable debounce to selected GPI
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiDebounceT0">
            <summary>
            Debounce time (x * 10us)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiDebounceT1">
            <summary>
            Debounce time (x * 10us)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiDebouncePol">
            <summary>
            Debounce polarity (pol = 1 t0 - falling edge, t1 - rising edge)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiLensMode">
            <summary>
            Status of lens control interface. This shall be set to XI_ON before any Lens operations.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiLensApertureValue">
            <summary>
            Current lens aperture value in stops. Examples: 2.8, 4, 5.6, 8, 11
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiLensFocusMovementValue">
            <summary>
            Lens current focus movement value to be used by XI_PRM_LENS_FOCUS_MOVE in motor steps.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiLensFocusMove">
            <summary>
            Moves lens focus motor by steps set in XI_PRM_LENS_FOCUS_MOVEMENT_VALUE.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiLensFocusDistance">
            <summary>
            Lens focus distance in cm.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiLensFocalLength">
            <summary>
            Lens focal distance in mm.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiLensFeatureSelector">
            <summary>
            Selects the current feature which is accessible by XI_PRM_LENS_FEATURE.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiLensFeature">
            <summary>
            Allows access to lens feature value currently selected by XI_PRM_LENS_FEATURE_SELECTOR.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiDeviceModelId">
            <summary>
            Return device model id
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiDeviceSn">
            <summary>
            Return device serial number
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiImageDataFormatRgb32Alpha">
            <summary>
            The alpha channel of RGB32 output image format.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiImagePayloadSize">
            <summary>
            Buffer size in bytes sufficient for output image returned by xiGetImage
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiTransportPixelFormat">
            <summary>
            Current format of pixels on transport layer.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiSensorClockFreqHz">
            <summary>
            Sensor clock frequency in Hz.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiSensorClockFreqIndex">
            <summary>
            Sensor clock frequency index. Sensor with selected frequencies have possibility to set the frequency only by this index.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiSensorOutputChannelCount">
            <summary>
            Number of output channels from sensor used for data transfer.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiFramerate">
            <summary>
            Define framerate in Hz
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiCounterSelector">
            <summary>
            Select counter
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiCounterValue">
            <summary>
            Counter status
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiAcqTimingMode">
            <summary>
            Type of sensor frames timing.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiAvailableBandwidth">
            <summary>
            Calculate and return available interface bandwidth(int Megabits)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiBufferPolicy">
            <summary>
            Data move policy
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiLutEn">
            <summary>
            Activates LUT.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiLutIndex">
            <summary>
            Control the index (offset) of the coefficient to access in the LUT.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiLutValue">
            <summary>
            Value at entry LUTIndex of the LUT
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiTrgDelay">
            <summary>
            Specifies the delay in microseconds (us) to apply after the trigger reception before activating it.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiTsRstMode">
            <summary>
            Defines how time stamp reset engine will be armed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiTsRstSource">
            <summary>
            Defines which source will be used for timestamp reset. Writing this parameter will trigger settings of engine (arming)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiIsDeviceExist">
            <summary>
            Returns 1 if camera connected and works properly.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiAcqBufferSize">
            <summary>
            Acquisition buffer size in buffer_size_unit. Default bytes.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiAcqBufferSizeUnit">
            <summary>
            Acquisition buffer size unit in bytes. Default 1. E.g. Value 1024 means that buffer_size is in KiBytes
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiAcqTransportBufferSize">
            <summary>
            Acquisition transport buffer size in bytes
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiBuffersQueueSize">
            <summary>
            Queue of field/frame buffers
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiAcqTransportBufferCommit">
            <summary>
            Number of buffers to commit to low level
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiRecentFrame">
            <summary>
            GetImage returns most recent frame
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiDeviceReset">
            <summary>
            Resets the camera to default state.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiColumnFpnCorrection">
            <summary>
            Correction of column FPN
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiRowFpnCorrection">
            <summary>
            Correction of row FPN
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiSensorMode">
            <summary>
            Current sensor mode. Allows to select sensor mode by one integer. Setting of this parameter affects: image dimensions and downsampling.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiHdr">
            <summary>
            Enable High Dynamic Range feature.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiHdrKneepointCount">
            <summary>
            The number of kneepoints in the PWLR.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiHdrT1">
            <summary>
            position of first kneepoint(in % of XI_PRM_EXPOSURE)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiHdrT2">
            <summary>
            position of second kneepoint (in % of XI_PRM_EXPOSURE)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiKneepoint1">
            <summary>
            value of first kneepoint (% of sensor saturation)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiKneepoint2">
            <summary>
            value of second kneepoint (% of sensor saturation)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiImageBlackLevel">
            <summary>
            Last image black level counts. Can be used for Offline processing to recall it.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiHwRevision">
            <summary>
            Returns hardware revision number.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiDebugLevel">
            <summary>
            Set debug level
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiAutoBandwidthCalculation">
            <summary>
            Automatic bandwidth calculation,
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiFfsFileId">
            <summary>
            File number.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiFfsFileSize">
            <summary>
            Size of file.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiFreeFfsSize">
            <summary>
            Size of free camera FFS.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiUsedFfsSize">
            <summary>
            Size of used camera FFS.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiFfsAccessKey">
            <summary>
            Setting of key enables file operations on some cameras.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiSensorFeatureSelector">
            <summary>
            Selects the current feature which is accessible by XI_PRM_SENSOR_FEATURE_VALUE.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.XiSensorFeatureValue">
            <summary>
            Allows access to sensor feature value currently selected by XI_PRM_SENSOR_FEATURE_SELECTOR.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.AndroidFlashMode">
            <summary>
            Android flash mode
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.AndroidFocusMode">
            <summary>
            Android focus mode
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.AndroidWhiteBalance">
            <summary>
            Android white balance
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.AndroidAntibanding">
            <summary>
            Android anti banding
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.AndroidFocalLength">
            <summary>
            Android focal length
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.AndroidFocusDistanceNear">
            <summary>
            Android focus distance near
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.AndroidFocusDistanceOptimal">
            <summary>
            Android focus distance optimal
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.AndroidFocusDistanceFar">
            <summary>
            Android focus distance far
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.AndroidExposeLock">
            <summary>
            Android expose lock
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.AndroidWhitebalanceLock">
            <summary>
            Android white balance lock
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.IOSDeviceFocus">
            <summary>
            iOS device focus
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.IOSDeviceExposure">
            <summary>
            iOS device exposure
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.IOSDeviceFlash">
            <summary>
            iOS device flash
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.IOSDeviceWhitebalance">
            <summary>
            iOS device white-balance 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.IOSDeviceTorch">
            <summary>
            iOS device torch
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.GigaFrameOffsetX">
            <summary>
            Smartek Giganetix Ethernet Vision: frame offset X
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.GigaFrameOffsetY">
            <summary>
            Smartek Giganetix Ethernet Vision: frame offset Y
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.GigaFrameWidthMax">
            <summary>
            Smartek Giganetix Ethernet Vision: frame width max
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.GigaFrameHeighMax">
            <summary>
            Smartek Giganetix Ethernet Vision: frame height max
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.GigaFrameSensWidth">
            <summary>
            Smartek Giganetix Ethernet Vision: frame sens width
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.GigaFrameSensHeigh">
            <summary>
            Smartek Giganetix Ethernet Vision: frame sens height
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.IntelpercProfileCount">
            <summary>
            Intelperc Profile Count
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.IntelpercProfileIdx">
            <summary>
            Intelperc Profile Idx
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.IntelpercDepthLowConfidenceValue">
            <summary>
            Intelperc Depth Low Confidence Value
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.IntelpercDepthSaturationValue">
            <summary>
            Intelperc Depth Saturation Value
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.IntelpercDepthConfidenceThreshold">
            <summary>
            Intelperc Depth Confidence Threshold
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.IntelpercDepthFocalLengthHorz">
            <summary>
            Intelperc Depth Focal Length Horz
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.IntelpercDepthFocalLengthVert">
            <summary>
            Intelperc Depth Focal Length Vert
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.IntelpercDepthGenerator">
            <summary>
            Intelperc Depth Generator
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.IntelpercImageGenerator">
            <summary>
            Intelperc Image Generator
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CapProp.IntelpercGeneratorsMask">
            <summary>
            Intelperc Generators Mask
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.NamedWindowType">
            <summary>
            The named window type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NamedWindowType.Normal">
            <summary>
            The user can resize the window (no constraint) / also use to switch a fullscreen window to a normal size
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NamedWindowType.AutoSize">
            <summary>
            The user cannot resize the window, the size is constrainted by the image displayed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NamedWindowType.Opengl">
            <summary>
            Window with opengl support
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NamedWindowType.Fullscreen">
            <summary>
            Change the window to fullscreen
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NamedWindowType.FreeRatio">
            <summary>
            The image expends as much as it can (no ratio constraint)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NamedWindowType.KeepRatio">
            <summary>
            the ratio of the image is respected
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ChainApproxMethod">
            <summary>
            contour approximation method
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ChainApproxMethod.ChainCode">
            <summary>
            output contours in the Freeman chain code. All other methods output polygons (sequences of vertices). 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ChainApproxMethod.ChainApproxNone">
            <summary>
            translate all the points from the chain code into points;
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ChainApproxMethod.ChainApproxSimple">
            <summary>
            compress horizontal, vertical, and diagonal segments, that is, the function leaves only their ending points; 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ChainApproxMethod.ChainApproxTc89L1">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ChainApproxMethod.ChainApproxTc89Kcos">
            <summary>
            apply one of the flavors of Teh-Chin chain approximation algorithm
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ChainApproxMethod.LinkRuns">
            <summary>
            use completely different contour retrieval algorithm via linking of horizontal segments of 1s. Only LIST retrieval mode can be used with this method
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ColorConversion">
            <summary>
            Color Conversion code
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2Bgra">
            <summary>
            Convert BGR color to BGRA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2Rgba">
            <summary>
            Convert RGB color to RGBA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgra2Bgr">
            <summary>
            Convert BGRA color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgba2Rgb">
            <summary>
            Convert RGBA color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2Rgba">
            <summary>
            Convert BGR color to RGBA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2Bgra">
            <summary>
            Convert RGB color to BGRA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgba2Bgr">
            <summary>
            Convert RGBA color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgra2Rgb">
            <summary>
            Convert BGRA color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2Rgb">
            <summary>
            Convert BGR color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2Bgr">
            <summary>
            Convert RGB color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgra2Rgba">
            <summary>
            Convert BGRA color to RGBA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgba2Bgra">
            <summary>
            Convert RGBA color to BGRA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2Gray">
            <summary>
            Convert BGR color to GRAY color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2Gray">
            <summary>
            Convert RGB color to GRAY color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Gray2Bgr">
            <summary>
            Convert GRAY color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Gray2Rgb">
            <summary>
            Convert GRAY color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Gray2Bgra">
            <summary>
            Convert GRAY color to BGRA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Gray2Rgba">
            <summary>
            Convert GRAY color to RGBA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgra2Gray">
            <summary>
            Convert BGRA color to GRAY color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgba2Gray">
            <summary>
            Convert RGBA color to GRAY color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2Bgr565">
            <summary>
            Convert BGR color to BGR565 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2Bgr565">
            <summary>
            Convert RGB color to BGR565 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr5652Bgr">
            <summary>
            Convert BGR565 color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr5652Rgb">
            <summary>
            Convert BGR565 color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgra2Bgr565">
            <summary>
            Convert BGRA color to BGR565 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgba2Bgr565">
            <summary>
            Convert RGBA color to BGR565 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr5652Bgra">
            <summary>
            Convert BGR565 color to BGRA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr5652Rgba">
            <summary>
            Convert BGR565 color to RGBA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Gray2Bgr565">
            <summary>
            Convert GRAY color to BGR565 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr5652Gray">
            <summary>
            Convert BGR565 color to GRAY color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2Bgr555">
            <summary>
            Convert BGR color to BGR555 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2Bgr555">
            <summary>
            Convert RGB color to BGR555 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr5552Bgr">
            <summary>
            Convert BGR555 color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr5552Rgb">
            <summary>
            Convert BGR555 color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgra2Bgr555">
            <summary>
            Convert BGRA color to BGR555 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgba2Bgr555">
            <summary>
            Convert RGBA color to BGR555 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr5552Bgra">
            <summary>
            Convert BGR555 color to BGRA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr5552Rgba">
            <summary>
            Convert BGR555 color to RGBA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Gray2Bgr555">
            <summary>
            Convert GRAY color to BGR555 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr5552Gray">
            <summary>
            Convert BGR555 color to GRAY color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2Xyz">
            <summary>
            Convert BGR color to XYZ color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2Xyz">
            <summary>
            Convert RGB color to XYZ color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Xyz2Bgr">
            <summary>
            Convert XYZ color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Xyz2Rgb">
            <summary>
            Convert XYZ color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2YCrCb">
            <summary>
            Convert BGR color to YCrCb color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2YCrCb">
            <summary>
            Convert RGB color to YCrCb color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.YCrCb2Bgr">
            <summary>
            Convert YCrCb color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.YCrCb2Rgb">
            <summary>
            Convert YCrCb color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2Hsv">
            <summary>
            Convert BGR color to HSV color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2Hsv">
            <summary>
            Convert RGB colot to HSV color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2Lab">
            <summary>
            Convert BGR color to Lab color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2Lab">
            <summary>
            Convert RGB color to Lab color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerBg2Bgr">
            <summary>
            Convert BayerBG color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGb2Bgr">
            <summary>
            Convert BayerGB color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerRg2Bgr">
            <summary>
            Convert BayerRG color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGr2Bgr">
            <summary>
            Convert BayerGR color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerBg2Rgb">
            <summary>
            Convert BayerBG color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGb2Rgb">
            <summary>
            Convert BayerRG color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerRg2Rgb">
            <summary>
            Convert BayerRG color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGr2Rgb">
            <summary>
            Convert BayerGR color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2Luv">
            <summary>
            Convert BGR color to Luv color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2Luv">
            <summary>
            Convert RGB color to Luv color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2Hls">
            <summary>
            Convert BGR color to HLS color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2Hls">
            <summary>
            Convert RGB color to HLS color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Hsv2Bgr">
            <summary>
            Convert HSV color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Hsv2Rgb">
            <summary>
            Convert HSV color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Lab2Bgr">
            <summary>
            Convert Lab color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Lab2Rgb">
            <summary>
            Convert Lab color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Luv2Bgr">
            <summary>
            Convert Luv color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Luv2Rgb">
            <summary>
            Convert Luv color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Hls2Bgr">
            <summary>
            Convert HLS color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Hls2Rgb">
            <summary>
            Convert HLS color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerBg2BgrVng">
            <summary>
            Convert BayerBG pattern to BGR color using VNG
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGb2BgrVng">
            <summary>
            Convert BayerGB pattern to BGR color using VNG
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerRg2BgrVng">
            <summary>
            Convert BayerRG pattern to BGR color using VNG
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGr2BgrVng">
            <summary>
            Convert BayerGR pattern to BGR color using VNG
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerBg2RgbVng">
            <summary>
            Convert BayerBG pattern to RGB color using VNG
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGb2RgbVng">
            <summary>
            Convert BayerGB pattern to RGB color using VNG
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerRg2RgbVng">
            <summary>
            Convert BayerRG pattern to RGB color using VNG
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGr2RgbVng">
            <summary>
            Convert BayerGR pattern to RGB color using VNG
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2HsvFull">
            <summary>
            Convert BGR to HSV
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2HsvFull">
            <summary>
            Convert RGB to HSV
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2HlsFull">
            <summary>
            Convert BGR to HLS
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2HlsFull">
            <summary>
            Convert RGB to HLS
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Hsv2BgrFull">
            <summary>
            Convert HSV color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Hsv2RgbFull">
            <summary>
            Convert HSV color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Hls2BgrFull">
            <summary>
            Convert HLS color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Hls2RgbFull">
            <summary>
            Convert HLS color to RGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Lbgr2Lab">
            <summary>
            Convert sBGR color to Lab color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Lrgb2Lab">
            <summary>
            Convert sRGB color to Lab color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Lbgr2Luv">
            <summary>
            Convert sBGR color to Luv color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Lrgb2Luv">
            <summary>
            Convert sRGB color to Luv color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Lab2Lbgr">
            <summary>
            Convert Lab color to sBGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Lab2Lrgb">
            <summary>
            Convert Lab color to sRGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Luv2Lbgr">
            <summary>
            Convert Luv color to sBGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Luv2Lrgb">
            <summary>
            Convert Luv color to sRGB color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2Yuv">
            <summary>
            Convert BGR color to YUV
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2Yuv">
            <summary>
            Convert RGB color to YUV
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2Bgr">
            <summary>
            Convert YUV color to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2Rgb">
            <summary>
            Convert YUV color to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerBg2Gray">
            <summary>
            Convert BayerBG to GRAY
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGb2Gray">
            <summary>
            Convert BayerGB to GRAY
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerRg2Gray">
            <summary>
            Convert BayerRG to GRAY
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGr2Gray">
            <summary>
            Convert BayerGR to GRAY
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420I2Rgb">
            <summary>
            Convert YUV420i to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420I2Bgr">
            <summary>
            Convert YUV420i to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420Sp2Rgb">
            <summary>
            Convert YUV420sp to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420Sp2Bgr">
            <summary>
            Convert YUV320sp to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420I2Rgba">
            <summary>
            Convert YUV320i to RGBA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420I2Bgra">
            <summary>
            Convert YUV420i to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420Sp2Rgba">
            <summary>
            Convert YUV420sp to RGBA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420Sp2Bgra">
            <summary>
            Convert YUV420sp to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbYv12">
            <summary>
            Convert YUV (YV12) to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgrYv12">
            <summary>
            Convert YUV (YV12) to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbIyuv">
            <summary>
            Convert YUV (iYUV) to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgrIyuv">
            <summary>
            Convert YUV (iYUV) to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbI420">
            <summary>
            Convert YUV (i420) to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgrI420">
            <summary>
            Convert YUV (i420) to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420P2Rgb">
            <summary>
            Convert YUV (420p) to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420P2Bgr">
            <summary>
            Convert YUV (420p) to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbaYv12">
            <summary>
            Convert YUV (YV12) to RGBA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgraYv12">
            <summary>
            Convert YUV (YV12) to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbaIyuv">
            <summary>
            Convert YUV (iYUV) to RGBA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgraIyuv">
            <summary>
            Convert YUV (iYUV) to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbaI420">
            <summary>
            Convert YUV (i420) to RGBA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgraI420">
            <summary>
            Convert YUV (i420) to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420P2Rgba">
            <summary>
            Convert YUV (420p) to RGBA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420P2Bgra">
            <summary>
            Convert YUV (420p) to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2Gray420">
            <summary>
            Convert YUV 420 to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2GrayNv21">
            <summary>
            Convert YUV NV21 to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2GrayNv12">
            <summary>
            Convert YUV NV12 to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2GrayYv12">
            <summary>
            Convert YUV YV12 to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2GrayIyuv">
            <summary>
            Convert YUV (iYUV) to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2GrayI420">
            <summary>
            Convert YUV (i420) to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420Sp2Gray">
            <summary>
            Convert YUV (420sp) to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv420P2Gray">
            <summary>
            Convert YUV (420p) to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbUyvy">
            <summary>
            Convert YUV (UYVY) to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgrUyvy">
            <summary>
            Convert YUV (UYVY) to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbY422">
            <summary>
            Convert YUV (Y422) to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgrY422">
            <summary>
            Convert YUV (Y422) to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbUynv">
            <summary>
            Convert YUV (UYNY) to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgrUynv">
            <summary>
            Convert YUV (UYNV) to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbaUyvy">
            <summary>
            Convert YUV (UYVY) to RGBA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgraUyvy">
            <summary>
            Convert YUV (VYUY) to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbaY422">
            <summary>
            Convert YUV (Y422) to RGBA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgraY422">
            <summary>
            Convert YUV (Y422) to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbaUynv">
            <summary>
            Convert YUV (UYNV) to RGBA 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgraUynv">
            <summary>
            Convert YUV (UYNV) to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbYuy2">
            <summary>
            Convert YUV (YUY2) to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgrYuy2">
            <summary>
            Convert YUV (YUY2) to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbYvyu">
            <summary>
            Convert YUV (YVYU) to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgrYvyu">
            <summary>
            Convert YUV (YVYU) to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbYuyv">
            <summary>
            Convert YUV (YUYV) to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgrYuyv">
            <summary>
            Convert YUV (YUYV) to BGR 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbYunv">
            <summary>
            Convert YUV (YUNV) to RGB
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgrYunv">
            <summary>
            Convert YUV (YUNV) to BGR
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbaYuy2">
            <summary>
            Convert YUV (YUY2) to RGBA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgraYuy2">
            <summary>
            Convert YUV (YUY2) to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbaYvyu">
            <summary>
            Convert YUV (YVYU) to RGBA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgraYvyu">
            <summary>
            Convert YUV (YVYU) to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbaYuyv">
            <summary>
            Convert YUV (YUYV) to RGBA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgraYuyv">
            <summary>
            Convert YUV (YUYV) to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2RgbaYunv">
            <summary>
            Convert YUV (YUNV) to RGBA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2BgraYunv">
            <summary>
            Convert YUV (YUNV) to BGRA
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2GrayUyvy">
            <summary>
            Convert YUV (UYVY) to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2GrayYuy2">
            <summary>
            Convert YUV (YUY2) to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2GrayY422">
            <summary>
            Convert YUV (Y422) to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2GrayUynv">
            <summary>
            Convert YUV (UYNV) to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2GrayYvyu">
            <summary>
            Convert YUV (YVYU) to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2GrayYuyv">
            <summary>
            Convert YUV (YUYV) to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Yuv2GrayYunv">
            <summary>
            Convert YUV (YUNV) to Gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgba2MRgba">
            <summary>
            Alpha premultiplication
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.MRgba2Rgba">
            <summary>
            Alpha premultiplication
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2YuvI420">
            <summary>
            Convert RGB to YUV_I420
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2YuvI420">
            <summary>
            Convert BGR to YUV_I420
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2YuvIyuv">
            <summary>
            Convert RGB to YUV_IYUV
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2YuvIyuv">
            <summary>
            Convert BGR to YUV_IYUV
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgba2YuvI420">
            <summary>
            Convert RGBA to YUV_I420
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgra2YuvI420">
            <summary>
            Convert BGRA to YUV_I420
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgba2YuvIyuv">
            <summary>
            Convert RGBA to YUV_IYUV
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgra2YuvIyuv">
            <summary>
            Convert BGRA to YUV_IYUV
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgb2YuvYv12">
            <summary>
            Convert RGB to YUV_YV12
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgr2YuvYv12">
            <summary>
            Convert BGR to YUV_YV12
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Rgba2YuvYv12">
            <summary>
            Convert RGBA to YUV_YV12
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.Bgra2YuvYv12">
            <summary>
            Convert BGRA to YUV_YV12
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerBg2BgrEa">
            <summary>
            Convert BayerBG to BGR (Edge-Aware Demosaicing)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGb2BgrEa">
            <summary>
            Convert BayerGB to BGR (Edge-Aware Demosaicing)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerRg2BgrEa">
            <summary>
            Convert BayerRG to BGR (Edge-Aware Demosaicing)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGr2BgrEa">
            <summary>
            Convert BayerGR to BGR (Edge-Aware Demosaicing)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerBg2RgbEa">
            <summary>
            Convert BayerBG to RGB (Edge-Aware Demosaicing)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGb2RgbEa">
            <summary>
            Convert BayerGB to RGB (Edge-Aware Demosaicing)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerRg2RgbEa">
            <summary>
            Convert BayerRG to RGB (Edge-Aware Demosaicing)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.BayerGr2RgbEa">
            <summary>
            Convert BayerGR to RGB (Edge-Aware Demosaicing)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorConversion.ColorcvtMax">
            <summary>
            The max number, do not use
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.FontFace">
            <summary>
            Fonts
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FontFace.HersheySimplex">
            <summary>
            Hershey simplex
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FontFace.HersheyPlain">
            <summary>
            Hershey plain
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FontFace.HersheyDuplex">
            <summary>
            Hershey duplex 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FontFace.HersheyComplex">
            <summary>
            Hershey complex
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FontFace.HersheyTriplex">
            <summary>
            Hershey triplex
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FontFace.HersheyComplexSmall">
            <summary>
            Hershey complex small
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FontFace.HersheyScriptSimplex">
            <summary>
            Hershey script simplex
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FontFace.HersheyScriptComplex">
            <summary>
            Hershey script complex
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.GemmType">
            <summary>
            Flags used for GEMM function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GemmType.Default">
            <summary>
            Do not apply transpose to neither matrices
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GemmType.Src1Transpose">
            <summary>
            transpose src1
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GemmType.Src2Transpose">
            <summary>
            transpose src2
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GemmType.Src3Transpose">
            <summary>
            transpose src3
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.HoughType">
            <summary>
            Hough detection type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HoughType.Gradient">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.InpaintType">
            <summary>
            Inpaint type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.InpaintType.NS">
            <summary>
            Navier-Stokes based method.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.InpaintType.Telea">
            <summary>
            The method by Alexandru Telea 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.EdgePreservingFilterFlag">
            <summary>
            Edge preserving filter flag
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.EdgePreservingFilterFlag.RecursFilter">
            <summary>
            Recurs filter
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.EdgePreservingFilterFlag.NormconvFilter">
            <summary>
            Norm conv filter
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.Inter">
            <summary>
            Interpolation types
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Inter.Nearest">
            <summary>
            Nearest-neighbor interpolation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Inter.Linear">
            <summary>
            Bilinear interpolation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Inter.Cubic">
            <summary>
            Resampling using pixel area relation. It is the preferred method for image decimation that gives moire-free results. In case of zooming it is similar to CV_INTER_NN method
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Inter.Area">
            <summary>
            Bicubic interpolation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Inter.Lanczos4">
            <summary>
            LANCZOS 4
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.SmoothType">
            <summary>
            Interpolation type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SmoothType.BlurNoScale">
            <summary>
            (simple blur with no scaling) - summation over a pixel param1xparam2 neighborhood. If the neighborhood size may vary, one may precompute integral image with cvIntegral function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SmoothType.Blur">
            <summary>
            (simple blur) - summation over a pixel param1xparam2 neighborhood with subsequent scaling by 1/(param1xparam2). 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SmoothType.Gaussian">
            <summary>
            (Gaussian blur) - convolving image with param1xparam2 Gaussian kernel. 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SmoothType.Median">
            <summary>
            (median blur) - finding median of param1xparam1 neighborhood (i.e. the neighborhood is square). 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SmoothType.Bilateral">
            <summary>
            (bilateral filter) - applying bilateral 3x3 filtering with color sigma=param1 and space sigma=param2. Information about bilateral filtering can be found 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ImreadModes">
            <summary>
            cvLoadImage type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ImreadModes.Unchanged">
            <summary>
            If set, return the loaded image as is (with alpha channel, otherwise it gets cropped).
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ImreadModes.Grayscale">
            <summary>
            If set, always convert image to the single channel grayscale image.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ImreadModes.Color">
            <summary>
            If set, always convert image to the 3 channel BGR color image.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ImreadModes.AnyDepth">
            <summary>
            If set, return 16-bit/32-bit image when the input has the corresponding depth, otherwise convert it to 8-bit.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ImreadModes.AnyColor">
            <summary>
            If set, the image is read in any possible color format.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ImreadModes.LoadGdal">
            <summary>
            If set, use the gdal driver for loading the image.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ImreadModes.ReducedGrayscale2">
            <summary>
            If set, always convert image to the single channel grayscale image and the image size reduced 1/2.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ImreadModes.ReducedColor2">
            <summary>
            If set, always convert image to the 3 channel BGR color image and the image size reduced 1/2.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ImreadModes.ReducedGrayscale4">
            <summary>
            If set, always convert image to the single channel grayscale image and the image size reduced 1/4.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ImreadModes.ReducedColor4">
            <summary>
            If set, always convert image to the 3 channel BGR color image and the image size reduced 1/4.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ImreadModes.ReducedGrayscale8">
            <summary>
            If set, always convert image to the single channel grayscale image and the image size reduced 1/8.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ImreadModes.ReducedColor8">
            <summary>
            If set, always convert image to the 3 channel BGR color image and the image size reduced 1/8.
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ImwriteFlags">
            <summary>
            Flags for Imwrite function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ImwriteFlags.JpegQuality">
            <summary>
            For JPEG, it can be a quality from 0 to 100 (the higher is the better). Default value is 95.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ImwriteFlags.JpegProgressive">
            <summary>
            Enable JPEG features, 0 or 1, default is False.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ImwriteFlags.JpegOptimize">
            <summary>
            Enable JPEG features, 0 or 1, default is False.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ImwriteFlags.JpegRstInterval">
            <summary>
            JPEG restart interval, 0 - 65535, default is 0 - no restart.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ImwriteFlags.JpegLumaQuality">
            <summary>
            Separate luma quality level, 0 - 100, default is 0 - don't use.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ImwriteFlags.JpegChromaQuality">
            <summary>
            Separate chroma quality level, 0 - 100, default is 0 - don't use.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ImwriteFlags.PngCompression">
            <summary>
            For PNG, it can be the compression level from 0 to 9. A higher value means a smaller size and longer compression time. Default value is 3.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ImwriteFlags.PngStrategy">
            <summary>
            One of cv::ImwritePNGFlags, default is IMWRITE_PNG_STRATEGY_DEFAULT.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ImwriteFlags.PngBilevel">
            <summary>
            Binary level PNG, 0 or 1, default is 0.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ImwriteFlags.PxmBinary">
            <summary>
            For PPM, PGM, or PBM, it can be a binary format flag, 0 or 1. Default value is 1.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ImwriteFlags.WebpQuality">
            <summary>
            For WEBP, it can be a quality from 1 to 100 (the higher is the better). By default (without any parameter) and for quality above 100 the lossless compression is used.
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.DepthType">
            <summary>
            OpenCV depth type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DepthType.Default">
            <summary>
            default
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DepthType.Cv8U">
            <summary>
            Byte
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DepthType.Cv8S">
            <summary>
            SByte
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DepthType.Cv16U">
            <summary>
            UInt16
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DepthType.Cv16S">
            <summary>
            Int16
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DepthType.Cv32S">
            <summary>
            Int32
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DepthType.Cv32F">
            <summary>
            float
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DepthType.Cv64F">
            <summary>
            double
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.RetrType">
            <summary>
            contour retrieval mode
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RetrType.External">
            <summary>
            retrieve only the extreme outer contours 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RetrType.List">
            <summary>
             retrieve all the contours and puts them in the list 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RetrType.Ccomp">
            <summary>
            retrieve all the contours and organizes them into two-level hierarchy: top level are external boundaries of the components, second level are bounda boundaries of the holes 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RetrType.Tree">
            <summary>
            retrieve all the contours and reconstructs the full hierarchy of nested contours 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqConst.EltypeBits">
            <summary>
            The bit to shift for SEQ_ELTYPE
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqConst.EltypeMask">
            <summary>
            The mask of CV_SEQ_ELTYPE
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqConst.KindBits">
            <summary>
            The bits to shift for SEQ_KIND
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqConst.Shift">
            <summary>
            The bits to shift for SEQ_FLAG
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.SeqEltype">
            <summary>
            Sequence element type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqEltype.Point">
            <summary>
              (x,y) 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqEltype.Code">
            <summary>  
            freeman code: 0..7 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqEltype.Generic">
            <summary>  
            unspecified type of sequence elements 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqEltype.Ptr">
            <summary>  
            =6 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqEltype.Ppoint">
            <summary>  
            pointer to element of other sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqEltype.Index">
            <summary>  
            index of element of some other sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqEltype.GraphEdge">
            <summary>  
            next_o, next_d, vtx_o, vtx_d 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqEltype.GraphVertex">
            <summary>  
            first_edge, (x,y) 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqEltype.TrainAtr">
            <summary>  
            vertex of the binary tree   
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqEltype.ConnectedComp">
            <summary>  
            connected component  
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqEltype.Point3D">
            <summary>  
            (x,y,z)  
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.SeqKind">
            <summary>
            The kind of sequence available
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqKind.Generic">
            <summary>
            generic (unspecified) kind of sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqKind.Curve">
            <summary>
            dense sequence subtypes 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqKind.BinTree">
            <summary>
            dense sequence subtypes 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqKind.Graph">
            <summary>
            sparse sequence (or set) subtypes 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqKind.Subdiv2D">
            <summary>
            sparse sequence (or set) subtypes 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.SeqFlag">
            <summary>
            Sequence flag
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqFlag.Closed">
            <summary>
            close sequence
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqFlag.Simple">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqFlag.Convex">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqFlag.Hole">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.SeqType">
            <summary>
            Sequence type for point sets
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqType.PointSet">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqType.Point3DSet">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqType.Polyline">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqType.Polygon">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqType.SimplePolygon">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.TermCritType">
            <summary>
            CV_TERMCRIT
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TermCritType.Iter">
            <summary>
            Iteration
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TermCritType.Eps">
            <summary>
            Epsilon
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ThresholdType">
            <summary>
            Types of thresholding 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ThresholdType.Binary">
            <summary>
            value = value > threshold ? max_value : 0
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ThresholdType.BinaryInv">
            <summary>
             value = value > threshold ? 0 : max_value       
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ThresholdType.Trunc">
            <summary>
             value = value > threshold ? threshold : value   
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ThresholdType.ToZero">
            <summary>
             value = value > threshold ? value : 0           
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ThresholdType.ToZeroInv">
            <summary>
             value = value > threshold ? 0 : value           
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ThresholdType.Mask">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ThresholdType.Otsu">
            <summary>
             use Otsu algorithm to choose the optimal threshold value;
             combine the flag with one of the above CV_THRESH_* values 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.TemplateMatchingType">
            <summary>
            Methods for comparing two array
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TemplateMatchingType.Sqdiff">
            <summary>
            R(x,y)=sumx',y'[T(x',y')-I(x+x',y+y')]2
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TemplateMatchingType.SqdiffNormed">
            <summary>
            R(x,y)=sumx',y'[T(x',y')-I(x+x',y+y')]2/sqrt[sumx',y'T(x',y')2 sumx',y'I(x+x',y+y')2]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TemplateMatchingType.Ccorr">
            <summary>
            R(x,y)=sumx',y'[T(x',y') I(x+x',y+y')]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TemplateMatchingType.CcorrNormed">
            <summary>
            R(x,y)=sumx',y'[T(x',y') I(x+x',y+y')]/sqrt[sumx',y'T(x',y')2 sumx',y'I(x+x',y+y')2]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TemplateMatchingType.Ccoeff">
            <summary>
            R(x,y)=sumx',y'[T'(x',y') I'(x+x',y+y')],
            where T'(x',y')=T(x',y') - 1/(wxh) sumx",y"T(x",y")
               I'(x+x',y+y')=I(x+x',y+y') - 1/(wxh) sumx",y"I(x+x",y+y")
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TemplateMatchingType.CcoeffNormed">
            <summary>
            R(x,y)=sumx',y'[T'(x',y') I'(x+x',y+y')]/sqrt[sumx',y'T'(x',y')2 sumx',y'I'(x+x',y+y')2]
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.IplDepth">
            <summary>
            IPL_DEPTH
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IplDepth.IplDepthSign">
            <summary>
            indicates if the value is signed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IplDepth.IplDepth_1U">
            <summary>
            1bit unsigned
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IplDepth.IplDepth_8U">
            <summary>
            8bit unsigned (Byte)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IplDepth.IplDepth16U">
            <summary>
            16bit unsigned
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IplDepth.IplDepth32F">
            <summary>
            32bit float (Single)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IplDepth.IplDepth_8S">
            <summary>
            8bit signed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IplDepth.IplDepth16S">
            <summary>
            16bit signed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IplDepth.IplDepth32S">
            <summary>
            32bit signed 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IplDepth.IplDepth64F">
            <summary>
            double
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.FlipType">
            <summary>
            Enumeration used by cvFlip
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FlipType.None">
            <summary>
            No flipping
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FlipType.Horizontal">
            <summary>
            Flip horizontally
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FlipType.Vertical">
            <summary>
            Flip vertically
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CheckType">
            <summary>
            Enumeration used by cvCheckArr
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CheckType.NanInfinity">
            <summary>
            Checks that every element is neither NaN nor Infinity
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CheckType.Range">
            <summary>
            If set, the function checks that every value of array is within [minVal,maxVal) range, otherwise it just checks that every element is neigther NaN nor Infinity
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CheckType.Quite">
            <summary>
            If set, the function does not raises an error if an element is invalid or out of range
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.FloodFillType">
            <summary>
            Type of floodfill operation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FloodFillType.Default">
            <summary>
            The default type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FloodFillType.FixedRange">
            <summary>
            If set the difference between the current pixel and seed pixel is considered,
            otherwise difference between neighbor pixels is considered (the range is floating).
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FloodFillType.MaskOnly">
            <summary>
            If set, the function does not fill the image (new_val is ignored),
            but the fills mask (that must be non-NULL in this case).
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.Connectivity">
            <summary>
            The type for cvSampleLine
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Connectivity.EightConnected">
            <summary>
            8-connected
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Connectivity.FourConnected">
            <summary>
            4-connected
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.LineType">
            <summary>
            The type of line for drawing
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LineType.EightConnected">
            <summary>
            8-connected
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LineType.FourConnected">
            <summary>
            4-connected
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LineType.AntiAlias">
            <summary>
            Anti-alias
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.DistLabelType">
            <summary>
            Distance transform algorithm flags
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DistLabelType.CComp">
            <summary>
            Connected component
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DistLabelType.Pixel">
            <summary>
            The pixel
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.DistType">
            <summary>
            Defines for Distance Transform
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DistType.User">
            <summary>
              User defined distance 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DistType.L1">
            <summary>
              distance = |x1-x2| + |y1-y2| 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DistType.L2">
            <summary>
              Simple euclidean distance 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DistType.C">
            <summary>
              distance = max(|x1-x2|,|y1-y2|) 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DistType.L12">
            <summary>
              L1-L2 metric: distance = 2(sqrt(1+x*x/2) - 1)) 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DistType.Fair">
            <summary>
              distance = c^2(|x|/c-log(1+|x|/c)), c = 1.3998 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DistType.Welsch">
            <summary>
              distance = c^2/2(1-exp(-(x/c)^2)), c = 2.9846 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DistType.Huber">
            <summary>
              distance = |x|&lt;c ? x^2/2 : c(|x|-c/2), c=1.345 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.MulSpectrumsType">
            <summary>
            The types for cvMulSpectrums
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MulSpectrumsType.Default">
            <summary>
            The default type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MulSpectrumsType.DxtRows">
            <summary>
            Do forward or inverse transform of every individual row of the input matrix. This flag allows user to transform multiple vectors simultaneously and can be used to decrease the overhead (which is sometimes several times larger than the processing itself), to do 3D and higher-dimensional transforms etc
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MulSpectrumsType.DxtMulConj">
            <summary>
            Conjugate the second argument of cvMulSpectrums
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.DxtType">
            <summary>
            Flag used for cvDFT
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DxtType.Forward">
            <summary>
            Do forward 1D or 2D transform. The result is not scaled
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DxtType.Inverse">
            <summary>
            Do inverse 1D or 2D transform. The result is not scaled. CV_DXT_FORWARD and CV_DXT_INVERSE are mutually exclusive, of course
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DxtType.Scale">
            <summary>
            Scale the result: divide it by the number of array elements. Usually, it is combined with CV_DXT_INVERSE, and one may use a shortcut 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DxtType.Rows">
            <summary>
            Do forward or inverse transform of every individual row of the input matrix. This flag allows user to transform multiple vectors simultaneously and can be used to decrease the overhead (which is sometimes several times larger than the processing itself), to do 3D and higher-dimensional transforms etc
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DxtType.InvScale">
            <summary>
            Inverse and scale
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.DctType">
            <summary>
            Flag used for cvDCT
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DctType.Forward">
            <summary>
            Do forward 1D or 2D transform. The result is not scaled
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DctType.Inverse">
            <summary>
            Do inverse 1D or 2D transform. The result is not scaled. CV_DXT_FORWARD and CV_DXT_INVERSE are mutually exclusive, of course
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DctType.Rows">
            <summary>
            Do forward or inverse transform of every individual row of the input matrix. This flag allows user to transform multiple vectors simultaneously and can be used to decrease the overhead (which is sometimes several times larger than the processing itself), to do 3D and higher-dimensional transforms etc
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.FmType">
            <summary>
            Calculates fundamental matrix given a set of corresponding points
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FmType.SevenPoint">
            <summary>
            for 7-point algorithm. N == 7
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FmType.EightPoint">
            <summary>
            for 8-point algorithm. N >= 8
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FmType.LMedsOnly">
            <summary>
            for LMedS algorithm. N >= 8
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FmType.RansacOnly">
            <summary>
            for RANSAC algorithm. N >= 8
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FmType.LMeds">
            <summary>
            CV_FM_LMEDS_ONLY | CV_FM_8POINT
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FmType.Ransac">
            <summary>
            CV_FM_RANSAC_ONLY | CV_FM_8POINT
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.General">
            <summary>
            General enumeration
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.General.MaxDim">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.General.SeqMagicVal">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.General.SetMagicVal">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ErrorCodes">
            <summary>
             Error codes
             </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsOk">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsBacktrace">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsError">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsInternal">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsNoMem">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsBadArg">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsBadFunc">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsNoConv">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsAutoTrace">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.HeaderIsNull">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadImageSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadOffset">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadDataPtr">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.Badstep">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadModelOrChseq">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadNumChannels">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadNumChannel1U">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadDepth">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadAlphaChannel">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadOrder">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadOrigin">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadAlign">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadCallback">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadTileSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadCoi">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.BadRoiSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.MaskIsTiled">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsNullPtr">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsVecLengthErr">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsFilterStructContenterr">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsKernelStructContenterr">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsFilterOffSetErr">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsBadSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsDivByZero">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsInplaceNotSupported">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsObjectNotFound">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsUnmatchedFormats">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsBadFlag">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsBadPoint">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsBadMask">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsUnmatchedSizes">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsUnsupportedFormat">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsOutOfRange">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsParseError">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsNotImplemented">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ErrorCodes.StsBadMemBlock">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.Warp">
            <summary>
            Types for WarpAffine
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Warp.Default">
            <summary>
            Neither FILL_OUTLIERS nor CV_WRAP_INVERSE_MAP
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Warp.FillOutliers">
            <summary>
            Fill all the destination image pixels. If some of them correspond to outliers in the source image, they are set to fillval.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Warp.InverseMap">
            <summary>
            Indicates that matrix is inverse transform from destination image to source and, thus, can be used directly for pixel interpolation. Otherwise, the function finds the inverse transform from map_matrix.
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.AdaptiveThresholdType">
            <summary>
            Types of Adaptive Threshold
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.AdaptiveThresholdType.MeanC">
            <summary>
            indicates that "Mean minus C" should be used for adaptive threshold.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.AdaptiveThresholdType.GaussianC">
            <summary>
            indicates that "Gaussian minus C" should be used for adaptive threshold.
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ElementShape">
            <summary>
            Shape of the Structuring Element
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ElementShape.Rectangle">
            <summary>
            A rectangular element.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ElementShape.Cross">
            <summary>
            A cross-shaped element.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ElementShape.Ellipse">
            <summary>
            An elliptic element.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ElementShape.Custom">
            <summary>
            A user-defined element.
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.PcaType">
            <summary>
            PCA Type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.PcaType.DataAsRow">
            <summary>
            the vectors are stored as rows (i.e. all the components of a certain vector are stored continously)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.PcaType.DataAsCol">
            <summary>
             the vectors are stored as columns (i.e. values of a certain vector component are stored continuously)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.PcaType.UseAvg">
            <summary>
            use pre-computed average vector
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.DecompMethod">
            <summary>
            cvInvert method
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DecompMethod.LU">
            <summary>
            Gaussian elimination with optimal pivot element chose
            In case of LU method the function returns src1 determinant (src1 must be square). If it is 0, the matrix is not inverted and src2 is filled with zeros.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DecompMethod.Svd">
            <summary>
            Singular value decomposition (SVD) method
            In case of SVD methods the function returns the inversed condition number of src1 (ratio of the smallest singular value to the largest singular value) and 0 if src1 is all zeros. The SVD methods calculate a pseudo-inverse matrix if src1 is singular
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DecompMethod.Eig">
            <summary>
            Eig
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DecompMethod.Cholesky">
            <summary>
            method for a symmetric positively-defined matrix
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DecompMethod.QR">
            <summary>
            QR decomposition
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DecompMethod.Normal">
            <summary>
            Normal
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CovarMethod">
            <summary>
            cvCalcCovarMatrix method types
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CovarMethod.Scrambled">
            <summary>
            Calculates covariation matrix for a set of vectors 
            transpose([v1-avg, v2-avg,...]) * [v1-avg,v2-avg,...] 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CovarMethod.Normal">
            <summary>
            [v1-avg, v2-avg,...] * transpose([v1-avg,v2-avg,...])
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CovarMethod.UseAvg">
            <summary>
            Do not calc average (i.e. mean vector) - use the input vector instead
            (useful for calculating covariance matrix by parts)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CovarMethod.Scale">
            <summary>
            Scale the covariance matrix coefficients by number of the vectors
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CovarMethod.Rows">
            <summary>
            All the input vectors are stored in a single matrix, as its rows 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CovarMethod.Cols">
            <summary>
            All the input vectors are stored in a single matrix, as its columns
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.SvdFlag">
            <summary>
            Type for cvSVD
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SvdFlag.Default">
            <summary>
            The default type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SvdFlag.ModifyA">
            <summary>
            enables modification of matrix src1 during the operation. It speeds up the processing. 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SvdFlag.NoUV">
            <summary>
            indicates that only a vector of singular values `w` is to be processed, while u and vt will be set to empty matrices
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SvdFlag.FullUV">
            <summary>
            when the matrix is not square, by default the algorithm produces u and vt matrices of
            sufficiently large size for the further A reconstruction; if, however, FULL_UV flag is
            specified, u and vt will be full-size square orthogonal matrices.
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.LKFlowFlag">
            <summary>
            Type for cvCalcOpticalFlowPyrLK
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LKFlowFlag.Default">
            <summary>
            The default type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LKFlowFlag.UserInitialFlow">
            <summary>
            Uses initial estimations, stored in nextPts; if the flag is not set, then prevPts is copied to nextPts and is considered the initial estimate.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LKFlowFlag.LKGetMinEigenvals">
            <summary>
            use minimum eigen values as an error measure (see minEigThreshold description); if the flag is not set, then L1 distance between patches around the original and a moved point, divided by number of pixels in a window, is used as a error measure.
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CalibType">
            <summary>
            Various camera calibration flags
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.Default">
            <summary>
            The default value
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.UseIntrinsicGuess">
            <summary>
            intrinsic_matrix contains valid initial values of fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image center (image_size is used here), and focal distances are computed in some least-squares fashion
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.FixAspectRatio">
            <summary>
            The optimization procedure consider only one of fx and fy as independent variable and keeps the aspect ratio fx/fy the same as it was set initially in intrinsic_matrix. In this case the actual initial values of (fx, fy) are either taken from the matrix (when CV_CALIB_USE_INTRINSIC_GUESS is set) or estimated somehow (in the latter case fx, fy may be set to arbitrary values, only their ratio is used)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.FixPrincipalPoint">
            <summary>
            The principal point is not changed during the global optimization, it stays at the center and at the other location specified (when CV_CALIB_FIX_FOCAL_LENGTH - Both fx and fy are fixed.
            CV_CALIB_USE_INTRINSIC_GUESS is set as well)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.ZeroTangentDist">
            <summary>
            Tangential distortion coefficients are set to zeros and do not change during the optimization
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.FixFocalLength">
            <summary>
            The focal length is fixed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.FixK1">
            <summary>
            The 1st distortion coefficient (k1) is fixed to 0 or to the initial passed value if CV_CALIB_USE_INTRINSIC_GUESS is passed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.FixK2">
            <summary>
            The 2nd distortion coefficient (k2) is fixed to 0 or to the initial passed value if CV_CALIB_USE_INTRINSIC_GUESS is passed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.FixK3">
            <summary>
            The 3rd distortion coefficient (k3) is fixed to 0 or to the initial passed value if CV_CALIB_USE_INTRINSIC_GUESS is passed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.FixK4">
            <summary>
            The 4th distortion coefficient (k4) is fixed (see above)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.FixK5">
            <summary>
            The 5th distortion coefficient (k5) is fixed to 0 or to the initial passed value if CV_CALIB_USE_INTRINSIC_GUESS is passed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.FixK6">
            <summary>
            The 6th distortion coefficient (k6) is fixed to 0 or to the initial passed value if CV_CALIB_USE_INTRINSIC_GUESS is passed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.RationalModel">
            <summary>
            Rational model
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.ThinPrismModel">
            <summary>
            Thin prism model
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.FixS1S2S3S4">
            <summary>
            Fix S1, S2, S3, S4
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.TiltedModel">
            <summary>
            Tilted model
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.FixTauxTauy">
            <summary>
            Fix Taux Tauy
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.UseQR">
            <summary>
            Use QR instead of SVD decomposition for solving. Faster but potentially less precise
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.FixIntrinsic">
            <summary>
            Only for stereo: Fix intrinsic
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.SameFocalLength">
            <summary>
            Only for stereo: Same focal length
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.ZeroDisparity">
            <summary>
            For stereo rectification: Zero disparity
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibType.UseLU">
            <summary>
            For stereo rectification: use LU instead of SVD decomposition for solving. much faster but potentially less precise
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CalibCbType">
            <summary>
            Type of chessboard calibration
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibCbType.Default">
            <summary>
            Default type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibCbType.AdaptiveThresh">
            <summary>
            Use adaptive thresholding to convert the image to black-n-white, rather than a fixed threshold level (computed from the average image brightness)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibCbType.NormalizeImage">
            <summary>
            Normalize the image using cvNormalizeHist before applying fixed or adaptive thresholding.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibCbType.FilterQuads">
            <summary>
            Use additional criteria (like contour area, perimeter, square-like shape) to filter out false quads that are extracted at the contour retrieval stage
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibCbType.FastCheck">
            <summary>
            If it is on, then this check is performed before the main algorithm and if a chessboard is not found, the function returns 0 instead of wasting 0.3-1s on doing the full search.
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CalibCgType">
            <summary>
            Type of circles grid calibration
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibCgType.SymmetricGrid">
            <summary>
            symmetric grid
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibCgType.AsymmetricGrid">
            <summary>
            asymmetric grid
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CalibCgType.Clustering">
            <summary>
            Clustering
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.EigobjType">
            <summary>
            IO type for eigen object related functions
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.EigobjType.NoCallback">
            <summary>
            No callback
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.EigobjType.InputCallback">
            <summary>
            input callback
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.EigobjType.OutputCallback">
            <summary>
            output callback
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.EigobjType.BothCallback">
            <summary>
            both callback
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.Orientation">
            <summary>
            orientation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Orientation.Clockwise">
            <summary>
            clockwise
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Orientation.CounterClockwise">
            <summary>
            counter clockwise
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.StereoBmPrefilter">
            <summary>
            Stereo Block Matching Prefilter type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.StereoBmPrefilter.NormalizedResponse">
            <summary>
            No prefilter
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.StereoBmPrefilter.XSobel">
            <summary>
            XSobel
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.HomographyMethod">
            <summary>
            Type of cvHomography method
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HomographyMethod.Default">
            <summary>
            regular method using all the point pairs
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HomographyMethod.LMEDS">
            <summary>
            Least-Median robust method
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HomographyMethod.Ransac">
            <summary>
            RANSAC-based robust method
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ContoursMatchType">
            <summary>
            Type used by cvMatchShapes
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ContoursMatchType.I1">
            <summary>
            I_1(A,B)=sum_{i=1..7} abs(1/m^A_i - 1/m^B_i) where m^A_i=sign(h^A_i) log(h^A_i), m^B_i=sign(h^B_i) log(h^B_i), h^A_i, h^B_i - Hu moments of A and B, respectively
            </summary> 
        </member>
        <member name="F:Emgu.CV.CvEnum.ContoursMatchType.I2">
            <summary>
            I_2(A,B)=sum_{i=1..7} abs(m^A_i - m^B_i) where m^A_i=sign(h^A_i) log(h^A_i), m^B_i=sign(h^B_i) log(h^B_i), h^A_i, h^B_i - Hu moments of A and B, respectively
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ContoursMatchType.I3">
            <summary>
            I_3(A,B)=sum_{i=1..7} abs(m^A_i - m^B_i)/abs(m^A_i) where m^A_i=sign(h^A_i) log(h^A_i), m^B_i=sign(h^B_i) log(h^B_i), h^A_i, h^B_i - Hu moments of A and B, respectively
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.Subdiv2DPointLocationType">
            <summary>
            The result type of cvSubdiv2DLocate.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Subdiv2DPointLocationType.Error">
            <summary>
            One of input arguments is invalid.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Subdiv2DPointLocationType.OutsideRect">
            <summary>
            Point is outside the subdivision reference rectangle
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Subdiv2DPointLocationType.Inside">
            <summary>
            Point falls into some facet
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Subdiv2DPointLocationType.Vertex">
            <summary>
            Point coincides with one of subdivision vertices
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Subdiv2DPointLocationType.OnEdge">
            <summary>
            Point falls onto the edge
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.StereoRectifyType">
            <summary>
            Type used in cvStereoRectify
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.StereoRectifyType.Default">
            <summary>
            Shift one of the image in horizontal or vertical direction (depending on the orientation of epipolar lines) in order to maximise the useful image area
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.StereoRectifyType.CalibZeroDisparity">
            <summary>
            Makes the principal points of each camera have the same pixel coordinates in the rectified views
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.BorderType">
            <summary>
            The type for CopyMakeBorder function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BorderType.NegativeOne">
            <summary>
            Used by some cuda methods, will pass the value -1 to the function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BorderType.Constant">
            <summary>
            Border is filled with the fixed value, passed as last parameter of the function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BorderType.Replicate">
            <summary>
            The pixels from the top and bottom rows, the left-most and right-most columns are replicated to fill the border
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BorderType.Reflect">
            <summary>
            Reflect
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BorderType.Wrap">
            <summary>
            Wrap
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BorderType.Reflect101">
            <summary>
            Reflect 101
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BorderType.Transparent">
            <summary>
            Transparent
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BorderType.Default">
            <summary>
            The default border interpolation type.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BorderType.Isolated">
            <summary>
            do not look outside of ROI
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.HaarDetectionType">
            <summary>
            The types for haar detection
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HaarDetectionType.Default">
            <summary>
            The default type where no optimization is done.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HaarDetectionType.DoCannyPruning">
            <summary>
            If it is set, the function uses Canny edge detector to reject some image regions that contain too few or too much edges and thus can not contain the searched object. The particular threshold values are tuned for face detection and in this case the pruning speeds up the processing
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HaarDetectionType.ScaleImage">
            <summary>
            For each scale factor used the function will downscale the image rather than "zoom" the feature coordinates in the classifier cascade. Currently, the option can only be used alone, i.e. the flag can not be set together with the others
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HaarDetectionType.FindBiggestObject">
            <summary>
            If it is set, the function finds the largest object (if any) in the image. That is, the output sequence will contain one (or zero) element(s)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HaarDetectionType.DoRoughSearch">
            <summary>
            It should be used only when CV_HAAR_FIND_BIGGEST_OBJECT is set and min_neighbors &gt; 0. If the flag is set, the function does not look for candidates of a smaller size as soon as it has found the object (with enough neighbor candidates) at the current scale. Typically, when min_neighbors is fixed, the mode yields less accurate (a bit larger) object rectangle than the regular single-object mode (flags=CV_HAAR_FIND_BIGGEST_OBJECT), but it is much faster, up to an order of magnitude. A greater value of min_neighbors may be specified to improve the accuracy
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.BackOrFront">
            <summary>
            Specific if it is back or front
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BackOrFront.Back">
            <summary>
            Back
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BackOrFront.Front">
            <summary>
            Front
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.StorageOp">
            <summary>
            The file storage operation type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.StorageOp.Read">
            <summary>
            The storage is open for reading
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.StorageOp.Write">
            <summary>
            The storage is open for writing
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.StorageOp.Append">
            <summary>
            The storage is open for append
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.HistogramCompMethod">
            <summary>
            Histogram comparison method
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HistogramCompMethod.Correl">
            <summary>
            Correlation/ 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HistogramCompMethod.Chisqr">
            <summary>
            Chi-Square
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HistogramCompMethod.Intersect">
            <summary>
            Intersection
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HistogramCompMethod.Bhattacharyya">
            <summary>
            Bhattacharyya distance
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HistogramCompMethod.Hellinger">
            <summary>
             Synonym for Bhattacharyya
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HistogramCompMethod.ChisqrAlt">
            <summary>
            Alternative Chi-Square
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.OpticalflowFarnebackFlag">
            <summary>
            The available flags for Farneback optical flow computation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.OpticalflowFarnebackFlag.Default">
            <summary>
            Default
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.OpticalflowFarnebackFlag.UseInitialFlow">
            <summary>
            Use the input flow as the initial flow approximation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.OpticalflowFarnebackFlag.FarnebackGaussian">
            <summary>
            Use a Gaussian winsize x winsizefilter instead of box
            filter of the same size for optical flow estimation. Usually, this option gives more accurate
            flow than with a box filter, at the cost of lower speed (and normally winsize for a
            Gaussian window should be set to a larger value to achieve the same level of robustness)
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.GrabcutInitType">
            <summary>
            Grabcut initialization type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GrabcutInitType.InitWithRect">
            <summary>
            Initialize with rectangle
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GrabcutInitType.InitWithMask">
            <summary>
            Initialize with mask
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GrabcutInitType.Eval">
            <summary>
            Eval
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CaptureType">
            <summary>
            CvCapture type. This is the equivalent to CV_CAP_ macros.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Any">
            <summary>
            Auto detect
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Vfw">
            <summary>
            Platform native
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.V4L">
            <summary>
            Platform native
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.V4L2">
            <summary>
            Platform native
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Firewire">
            <summary>
            IEEE 1394 drivers
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.IEEE1394">
            <summary>
            IEEE 1394 drivers
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.DC1394">
            <summary>
            IEEE 1394 drivers
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.CMU1394">
            <summary>
            IEEE 1394 drivers
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.QT">
            <summary>
            QuickTime
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Unicap">
            <summary>
            Unicap drivers
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.DShow">
            <summary>
            DirectShow (via videoInput)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Pvapi">
            <summary>
            PvAPI, Prosilica GigE SDK
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.OpenNI">
            <summary>
            OpenNI (for Kinect)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.OpenNIAsus">
            <summary>
            OpenNI (for Asus Xtion)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Android">
            <summary>
            Android
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.XiApi">
            <summary>
            XIMEA Camera API
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.AVFoundation">
            <summary>
            AVFoundation framework for iOS (OS X Lion will have the same API)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Giganetix">
            <summary>
             Smartek Giganetix GigEVisionSDK
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Msmf">
            <summary>
            Microsoft Media Foundation (via videoInput)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Winrt">
            <summary>
            Microsoft Windows Runtime using Media Foundation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.IntelPerc">
            <summary>
            Intel Perceptual Computing SDK
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Openni2">
            <summary>
            OpenNI2 (for Kinect)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Openni2Asus">
            <summary>
            OpenNI2 (for Asus Xtion and Occipital Structure sensors)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Gphoto2">
            <summary>
            gPhoto2 connection
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Gstreamer">
            <summary>
            GStreamer
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Ffmpeg">
            <summary>
            FFMPEG
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CaptureType.Images">
            <summary>
            OpenCV Image Sequence (e.g. img_%02d.jpg)
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.KMeansInitType">
            <summary>
            KMeans initialization type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.KMeansInitType.RandomCenters">
            <summary>
            Chooses random centers for k-Means initialization
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.KMeansInitType.UseInitialLabels">
            <summary>
            Uses the user-provided labels for K-Means initialization
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.KMeansInitType.PPCenters">
            <summary>
            Uses k-Means++ algorithm for initialization
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ColorMapType">
            <summary>
            The type of color map
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorMapType.Autumn">
            <summary>
            Autumn
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorMapType.Bone">
            <summary>
            Bone
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorMapType.Jet">
            <summary>
            Jet
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorMapType.Winter">
            <summary>
            Winter
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorMapType.Rainbow">
            <summary>
            Rainbow
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorMapType.Ocean">
            <summary>
            Ocean
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorMapType.Summer">
            <summary>
            Summer
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorMapType.Spring">
            <summary>
            Spring
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorMapType.Cool">
            <summary>
            Cool
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorMapType.Hsv">
            <summary>
            Hsv
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorMapType.Pink">
            <summary>
            Pink
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ColorMapType.Hot">
            <summary>
            Hot
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.SolveLPResult">
            <summary>
            The return value for solveLP function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SolveLPResult.Unbounded">
            <summary>
            Problem is unbounded (target function can achieve arbitrary high values)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SolveLPResult.Unfeasible">
            <summary>
            Problem is unfeasible (there are no points that satisfy all the constraints imposed)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SolveLPResult.Single">
            <summary>
            There is only one maximum for target function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SolveLPResult.Multi">
            <summary>
            there are multiple maxima for target function - the arbitrary one is returned
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.MorphOp">
            <summary>
            Morphology operation type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MorphOp.Erode">
            <summary>
            Erode
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MorphOp.Dilate">
            <summary>
            Dilate
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MorphOp.Open">
            <summary>
            Open
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MorphOp.Close">
            <summary>
            Close
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MorphOp.Gradient">
            <summary>
            Gradient
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MorphOp.Tophat">
            <summary>
            Tophat
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MorphOp.Blackhat">
            <summary>
            Blackhat
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.AccessType">
            <summary>
            Access type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.AccessType.Read">
            <summary>
            Read
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.AccessType.Write">
            <summary>
            Write
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.AccessType.ReadWrite">
            <summary>
            Read and write
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.AccessType.Mask">
            <summary>
            Mask
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.AccessType.Fast">
            <summary>
            Dast
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.RectIntersectType">
            <summary>
            Rectangle intersect type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RectIntersectType.None">
            <summary>
            No intersection
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RectIntersectType.Partial">
            <summary>
            There is a partial intersection
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RectIntersectType.Full">
            <summary>
            One of the rectangle is fully enclosed in the other
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.SolvePnpMethod">
            <summary>
            Method for solving a PnP problem
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SolvePnpMethod.Iterative">
            <summary>
            Iterative
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SolvePnpMethod.EPnP">
            <summary>
            F.Moreno-Noguer, V.Lepetit and P.Fua "EPnP: Efficient Perspective-n-Point Camera Pose Estimation"
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SolvePnpMethod.P3P">
            <summary>
            X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang; "Complete Solution Classification for the Perspective-Three-Point Problem"
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SolvePnpMethod.Dls">
            <summary>
            A Direct Least-Squares (DLS) Method for PnP
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SolvePnpMethod.UPnP">
            <summary>
            Exhaustive Linearization for Robust Camera Pose and Focal Length Estimation
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CloningMethod">
            <summary>
            Seamless clone method
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CloningMethod.Normal">
            <summary>
            The power of the method is fully expressed when inserting objects with complex outlines into a new background
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CloningMethod.Mixed">
            <summary>
            The classic method, color-based selection and alpha masking might be time consuming and often leaves an undesirable halo. Seamless cloning, even averaged with the original image, is not effective. Mixed seamless cloning based on a loose selection proves effective.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CloningMethod.MonochromeTransfer">
            <summary>
            Monochrome transfer
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ConnectecComponentsTypes">
            <summary>
            Connected components algorithm output formats
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ConnectecComponentsTypes.Left">
            <summary>
            The leftmost (x) coordinate which is the inclusive start of the bounding box in the horizontal direction.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ConnectecComponentsTypes.Top">
            <summary>
            The topmost (y) coordinate which is the inclusive start of the bounding box in the vertical direction.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ConnectecComponentsTypes.Width">
            <summary>
            The horizontal size of the bounding box.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ConnectecComponentsTypes.Height">
            <summary>
            The vertical size of the bounding box.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ConnectecComponentsTypes.Area">
            <summary>
            The total area (in pixels) of the connected component.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ConnectecComponentsTypes.Max">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.Fisheye">
            <summary>
            Fisheye Camera model
            </summary>
        </member>
        <member name="M:Emgu.CV.Fisheye.ProjectPoints(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Double,Emgu.CV.IOutputArray)">
            <summary>
            Projects points using fisheye model. The function computes projections of 3D points to the image plane given intrinsic and extrinsic camera parameters. Optionally, the function computes Jacobians - matrices of partial derivatives of image points coordinates (as functions of all the input parameters) with respect to the particular parameters, intrinsic and/or extrinsic.
            </summary>
            <param name="objectPoints">Array of object points, 1xN/Nx1 3-channel (or vector&lt;Point3f&gt; ), where N is the number of points in the view.</param>
            <param name="imagePoints">Output array of image points, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel, or vector&lt;Point2f&gt;.</param>
            <param name="rvec">rotation vector</param>
            <param name="tvec">translation vector</param>
            <param name="K">Camera matrix</param>
            <param name="D">	Input vector of distortion coefficients (k1,k2,k3,k4).</param>
            <param name="alpha">The skew coefficient.</param>
            <param name="jacobian">Optional output 2Nx15 jacobian matrix of derivatives of image points with respect to components of the focal lengths, coordinates of the principal point, distortion coefficients, rotation vector, translation vector, and the skew. In the old interface different components of the jacobian are returned via different output parameters.</param>
        </member>
        <member name="M:Emgu.CV.Fisheye.DistortPoints(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Double)">
            <summary>
            Distorts 2D points using fisheye model.
            </summary>
            <param name="undistored">Array of object points, 1xN/Nx1 2-channel (or vector&lt;Point2f&gt; ), where N is the number of points in the view.</param>
            <param name="distorted">	Output array of image points, 1xN/Nx1 2-channel, or vector&lt;Point2f&gt; .</param>
            <param name="K">Camera matrix</param>
            <param name="D">Input vector of distortion coefficients (k1,k2,k3,k4).</param>
            <param name="alpha">The skew coefficient.</param>
        </member>
        <member name="M:Emgu.CV.Fisheye.UndistorPoints(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Transforms an image to compensate for fisheye lens distortion.
            </summary>
            <param name="distorted">Array of object points, 1xN/Nx1 2-channel (or vector&lt;Point2f&gt; ), where N is the number of points in the view.</param>
            <param name="undistorted">Output array of image points, 1xN/Nx1 2-channel, or vector&lt;Point2f&gt;.</param>
            <param name="K">Camera matrix</param>
            <param name="D">Input vector of distortion coefficients (k1,k2,k3,k4).</param>
            <param name="R">Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3 1-channel or 1x1 3-channel</param>
            <param name="P">New camera matrix (3x3) or new projection matrix (3x4)</param>
        </member>
        <member name="M:Emgu.CV.Fisheye.InitUndistorRectifyMap(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.CvEnum.DepthType,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray)">
            <summary>
            Computes undistortion and rectification maps for image transform by cv::remap(). If D is empty zero distortion is used, if R or P is empty identity matrixes are used.
            </summary>
            <param name="K">Camera matrix</param>
            <param name="D">	Input vector of distortion coefficients (k1,k2,k3,k4).</param>
            <param name="R">Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3 1-channel or 1x1 3-channel</param>
            <param name="P">New camera matrix (3x3) or new projection matrix (3x4)</param>
            <param name="size">Undistorted image size.</param>
            <param name="m1Type">Type of the first output map that can be CV_32FC1 or CV_16SC2 . See convertMaps() for details.</param>
            <param name="map1">The first output map.</param>
            <param name="map2">The second output map.</param>
        </member>
        <member name="M:Emgu.CV.Fisheye.UndistorImage(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.Size)">
            <summary>
            Transforms an image to compensate for fisheye lens distortion. The function is simply a combination of fisheye::initUndistortRectifyMap (with unity R ) and remap (with bilinear interpolation). 
            </summary>
            <param name="distorted">Image with fisheye lens distortion.</param>
            <param name="undistored">Output image with compensated fisheye lens distortion.</param>
            <param name="K">Camera matrix </param>
            <param name="D">Input vector of distortion coefficients (k1,k2,k3,k4).</param>
            <param name="Knew">Camera matrix of the distorted image. By default, it is the identity matrix but you may additionally scale and shift the result by using a different matrix.</param>
            <param name="newSize">The function transforms an image to compensate radial and tangential lens distortion.</param>
        </member>
        <member name="M:Emgu.CV.Fisheye.EstimateNewCameraMatrixForUndistorRectify(Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Drawing.Size,System.Double)">
            <summary>
            Estimates new camera matrix for undistortion or rectification.
            </summary>
            <param name="K">Camera matrix</param>
            <param name="D">Input vector of distortion coefficients (k1,k2,k3,k4).</param>
            <param name="imageSize"></param>
            <param name="R">Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3 1-channel or 1x1 3-channel</param>
            <param name="P">New camera matrix (3x3) or new projection matrix (3x4)</param>
            <param name="balance">Sets the new focal length in range between the min focal length and the max focal length. Balance is in range of [0, 1]</param>
            <param name="newSize"></param>
            <param name="fovScale">Divisor for new focal length.</param>
        </member>
        <member name="M:Emgu.CV.Fisheye.SteteoRectify(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Int32,System.Drawing.Size,System.Double,System.Double)">
            <summary>
            Stereo rectification for fisheye camera model.
            </summary>
            <param name="K1">First camera matrix.</param>
            <param name="D1">First camera distortion parameters.</param>
            <param name="K2">Second camera matrix.</param>
            <param name="D2">Second camera distortion parameters.</param>
            <param name="imageSize">Size of the image used for stereo calibration.</param>
            <param name="R">Rotation matrix between the coordinate systems of the first and the second cameras.</param>
            <param name="tvec">Translation vector between coordinate systems of the cameras.</param>
            <param name="R1">Output 3x3 rectification transform (rotation matrix) for the first camera.</param>
            <param name="R2">Output 3x3 rectification transform (rotation matrix) for the second camera.</param>
            <param name="P1">Output 3x4 projection matrix in the new (rectified) coordinate systems for the first camera.</param>
            <param name="P2">Output 3x4 projection matrix in the new (rectified) coordinate systems for the second camera.</param>
            <param name="Q">	Output 44 disparity-to-depth mapping matrix (see reprojectImageTo3D ).</param>
            <param name="flags">Operation flags that may be zero or ZeroDisparity . If the flag is set, the function makes the principal points of each camera have the same pixel coordinates in the rectified views. And if the flag is not set, the function may still shift the images in the horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the useful image area.</param>
            <param name="newImageSize">New image resolution after rectification. The same size should be passed to initUndistortRectifyMap. When (0,0) is passed (default), it is set to the original imageSize . Setting it to larger value can help you preserve details in the original image, especially when there is a big radial distortion.</param>
            <param name="balance">Sets the new focal length in range between the min focal length and the max focal length. Balance is in range of [0, 1].</param>
            <param name="fovScale">Divisor for new focal length.</param>
        </member>
        <member name="M:Emgu.CV.Fisheye.Calibrate(Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.Fisheye.CalibrationFlag,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Performs camera calibaration.
            </summary>
            <param name="objectPoints">vector of vectors of calibration pattern points in the calibration pattern coordinate space.</param>
            <param name="imagePoints">vector of vectors of the projections of calibration pattern points. imagePoints.size() and objectPoints.size() and imagePoints[i].size() must be equal to objectPoints[i].size() for each i.</param>
            <param name="imageSize">Size of the image used only to initialize the intrinsic camera matrix.</param>
            <param name="K">Output 3x3 floating-point camera matrix. If UseIntrisicGuess is specified, some or all of fx, fy, cx, cy must be initialized before calling the function. </param>
            <param name="D">Output vector of distortion coefficients (k1,k2,k3,k4).</param>
            <param name="rvecs">Output vector of rotation vectors (see Rodrigues ) estimated for each pattern view. That is, each k-th rotation vector together with the corresponding k-th translation vector (see the next output parameter description) brings the calibration pattern from the model coordinate space (in which object points are specified) to the world coordinate space, that is, a real position of the calibration pattern in the k-th pattern view (k=0.. M -1).</param>
            <param name="tvecs">Output vector of translation vectors estimated for each pattern view.</param>
            <param name="flags">Different flags</param>
            <param name="criteria">Termination criteria for the iterative optimization algorithm.</param>
        </member>
        <member name="M:Emgu.CV.Fisheye.StereoCalibrate(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,System.Drawing.Size,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.Fisheye.CalibrationFlag,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Performs stereo calibration.
            </summary>
            <param name="objectPoints">Vector of vectors of the calibration pattern points.</param>
            <param name="imagePoints1">Vector of vectors of the projections of the calibration pattern points, observed by the first camera.</param>
            <param name="imagePoints2">Vector of vectors of the projections of the calibration pattern points, observed by the second camera.</param>
            <param name="K1">Input/output first camera matrix.If FixIntrinsic is specified, some or all of the matrix components must be initialized.</param>
            <param name="D1">Input/output vector of distortion coefficients (k1,k2,k3,k4) of 4 elements.</param>
            <param name="K2">Input/output second camera matrix. The parameter is similar to <paramref name="K1"/> </param>
            <param name="D2">Input/output lens distortion coefficients for the second camera. The parameter is similar to <paramref name="D1"/></param>
            <param name="imageSize">Size of the image used only to initialize intrinsic camera matrix.</param>
            <param name="R">Output rotation matrix between the 1st and the 2nd camera coordinate systems.</param>
            <param name="T">Output translation vector between the coordinate systems of the cameras.</param>
            <param name="flags">Fish eye calibration flags</param>
            <param name="criteria">Termination criteria for the iterative optimization algorithm.</param>
        </member>
        <member name="T:Emgu.CV.Fisheye.CalibrationFlag">
            <summary>
            Fisheye calibration flag.
            </summary>
        </member>
        <member name="F:Emgu.CV.Fisheye.CalibrationFlag.Default">
            <summary>
            Default flag
            </summary>
        </member>
        <member name="F:Emgu.CV.Fisheye.CalibrationFlag.UseIntrinsicGuess">
            <summary>
            cameraMatrix contains valid initial values of fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image center ( imageSize is used), and focal distances are computed in a least-squares fashion.
            </summary>
        </member>
        <member name="F:Emgu.CV.Fisheye.CalibrationFlag.RecomputeExtrinsic">
            <summary>
            Extrinsic will be recomputed after each iteration of intrinsic optimization.
            </summary>
        </member>
        <member name="F:Emgu.CV.Fisheye.CalibrationFlag.CheckCond">
            <summary>
            The functions will check validity of condition number.
            </summary>
        </member>
        <member name="F:Emgu.CV.Fisheye.CalibrationFlag.FixSkew">
            <summary>
            Skew coefficient (alpha) is set to zero and stay zero.
            </summary>
        </member>
        <member name="F:Emgu.CV.Fisheye.CalibrationFlag.FixK1">
            <summary>
            Selected distortion coefficients are set to zeros and stay zero.
            </summary>
        </member>
        <member name="F:Emgu.CV.Fisheye.CalibrationFlag.FixK2">
            <summary>
            Selected distortion coefficients are set to zeros and stay zero.
            </summary>
        </member>
        <member name="F:Emgu.CV.Fisheye.CalibrationFlag.FixK3">
            <summary>
            Selected distortion coefficients are set to zeros and stay zero.
            </summary>
        </member>
        <member name="F:Emgu.CV.Fisheye.CalibrationFlag.FixK4">
            <summary>
            Selected distortion coefficients are set to zeros and stay zero.
            </summary>
        </member>
        <member name="F:Emgu.CV.Fisheye.CalibrationFlag.FixIntrinsic">
            <summary>
            Fix intrinsic
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.CircleF">
            <summary> A circle </summary>
        </member>
        <member name="M:Emgu.CV.Structure.CircleF.#ctor(System.Drawing.PointF,System.Single)">
            <summary> Create a circle with the specific center and radius </summary>
            <param name="center"> The center of this circle </param>
            <param name="radius"> The radius of this circle </param>
        </member>
        <member name="M:Emgu.CV.Structure.CircleF.Equals(Emgu.CV.Structure.CircleF)">
            <summary>
            Compare this circle with <paramref name="circle2"/>
            </summary>
            <param name="circle2">The other box to be compared</param>
            <returns>true if the two boxes equals</returns>
        </member>
        <member name="P:Emgu.CV.Structure.CircleF.Center">
            <summary> Get or Set the center of the circle </summary>
        </member>
        <member name="P:Emgu.CV.Structure.CircleF.Radius">
            <summary> The radius of the circle </summary>
        </member>
        <member name="P:Emgu.CV.Structure.CircleF.Area">
            <summary> The area of the circle </summary>
        </member>
        <member name="T:Emgu.CV.Structure.ColorPoint">
            <summary>
            A point with Bgr color information
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.ColorPoint.Position">
            <summary>
            The position in meters
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.ColorPoint.Blue">
            <summary>
            The blue color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.ColorPoint.Green">
            <summary>
            The green color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.ColorPoint.Red">
            <summary>
            The red color
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Cross2DF">
            <summary>
            A 2D cross
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Cross2DF.#ctor(System.Drawing.PointF,System.Single,System.Single)">
            <summary>
            Construct a cross
            </summary>
            <param name="center">The center of the cross</param>
            <param name="width">the width of the cross</param>
            <param name="height">the height of the cross</param>
        </member>
        <member name="P:Emgu.CV.Structure.Cross2DF.Center">
            <summary>
            The center of this cross
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Cross2DF.Size">
            <summary>
            The size of this cross
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Cross2DF.Horizontal">
            <summary>
            Get the horizonal linesegment of this cross
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Cross2DF.Vertical">
            <summary>
            Get the vertical linesegment of this cross
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Cuboid">
            <summary>
            A solid resembling a cube, with the rectangular faces not all equal; a rectangular parallelepiped.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Cuboid.Min">
            <summary>
            The coordinate of the upper corner
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Cuboid.Max">
            <summary>
            The coordinate of the lower corner
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Cuboid.Contains(Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Check if the specific point is in the Cuboid
            </summary>
            <param name="point">The point to be checked</param>
            <returns>True if the point is in the cuboid</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Cuboid.Centroid">
            <summary>
            Get the centroid of this cuboid
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.CvStructSizes">
            <summary>
            This is used to hold the sizes of the Open CV structures
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvPoint">
            <summary>
            The size of CvPoint
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvPoint2D32f">
            <summary>
            The size of CvPoint2D32f
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvPoint3D32f">
            <summary>
            The size of CvPoint3D32f
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvSize">
            <summary>
            The size of CvSize
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvSize2D32f">
            <summary>
            The size of CvSize2D32f
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvScalar">
            <summary>
            The size of CvScalar
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvRect">
            <summary>
            The size of CvRect
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvBox2D">
            <summary>
            The size of CvBox2D
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvMat">
            <summary>
            The size of CvMat
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvMatND">
            <summary>
            The size of CvMatND
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.CvTermCriteria">
            <summary>
            The size of CvTermCriteria
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.CvStructSizes.IplImage">
            <summary>
            The size of IplImage
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Ellipse">
            <summary>
            An ellipse
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Ellipse.#ctor(System.Drawing.PointF,System.Drawing.SizeF,System.Single)">
            <summary>
            Create an ellipse with specific parameters
            </summary>
            <param name="center"> The center of the ellipse</param>
            <param name="size"> The width and height of the ellipse</param>
            <param name="angle"> The rotation angle in radian for the ellipse</param>
        </member>
        <member name="M:Emgu.CV.Structure.Ellipse.#ctor(Emgu.CV.Structure.RotatedRect)">
            <summary>
            Create an ellipse from the specific RotatedRect
            </summary>
            <param name="box2d">The RotatedRect representation of this ellipse</param>
        </member>
        <member name="P:Emgu.CV.Structure.Ellipse.RotatedRect">
            <summary>
            The RotatedRect representation of this ellipse
            </summary>
        </member>
        <member name="T:Emgu.CV.IConvexPolygon">
            <summary>
            An interface for the convex polygon
            </summary>
        </member>
        <member name="M:Emgu.CV.IConvexPolygon.GetVertices">
            <summary>
            Get the vertices of this convex polygon
            </summary>
            <returns>The vertices of this convex polygon</returns>
        </member>
        <member name="T:Emgu.CV.IConvexPolygonF">
            <summary>
            An interface for the convex polygon
            </summary>
        </member>
        <member name="M:Emgu.CV.IConvexPolygonF.GetVertices">
            <summary>
            Get the vertices of this convex polygon
            </summary>
            <returns>The vertices of this convex polygon</returns>
        </member>
        <member name="T:Emgu.CV.Structure.MCvAvgComp">
            <summary>
            Result of cvHaarDetectObjects
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvAvgComp.Rect">
            <summary>
            Bounding rectangle for the object (average rectangle of a group)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvAvgComp.Neighbors">
            <summary>
            Number of neighbor rectangles in the group
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvMat">
            <summary>
            Managed structure equivalent to CvMat
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.Type">
            <summary>
            CvMat signature (CV_MAT_MAGIC_VAL), element type and flags
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.Step">
            <summary>
            full row length in bytes
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.Refcount">
            <summary>
            underlying data reference counter
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.HdrRefcount">
            <summary>
            Header reference count
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.Data">
            <summary>
            data pointers
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.Rows">
            <summary>
            number of rows
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.Cols">
            <summary>
            number of columns
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMat.Width">
            <summary>
            Width
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMat.Height">
            <summary>
            Height
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMat.NumberOfChannels">
            <summary>
            Get the number of channels
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvMatConstants">
            <summary>
            Constants used by the MCvMat structure
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatConstants.TypeOffset">
            <summary>
            Offset of roi
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvMatND">
            <summary>
            Managed structure equivalent to CvMatND
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.type">
            <summary>
            CvMatND signature (CV_MATND_MAGIC_VAL), element type and flags
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dims">
            <summary>
            number of array dimensions
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.refcount">
            <summary>
            underlying data reference counter
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.hdr_refcount">
            <summary>
            Header reference count
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.data">
            <summary>
            data pointers
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim0">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim1">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim2">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim3">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim4">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim5">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim6">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim7">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim8">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim9">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim10">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim11">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim12">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim13">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim14">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim15">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim16">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim17">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim18">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim19">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim20">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim21">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim22">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim23">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim24">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim25">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim26">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim27">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim28">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim29">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim30">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim31">
            <summary>
            pairs (number of elements, distance between elements in bytes)
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMatND.dim">
            <summary>
            pairs (number of elements, distance between elements in bytes) for every dimension
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvMatND.Dimension">
            <summary>
            The MatND Dimension
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMatND.Dimension.Size">
            <summary>
            Number of elements in this dimension
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMatND.Dimension.Step">
            <summary>
            distance between elements in bytes for this dimension
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvMoments">
            <summary>
            spatial and central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.M00">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.M10">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.M01">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.M20">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.M11">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.M02">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.M30">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.M21">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.M12">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.M03">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.Mu20">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.Mu11">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.Mu02">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.Mu30">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.Mu21">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.Mu12">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.Mu03">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.InvSqrtM00">
            <summary>
            m00 != 0 ? 1/sqrt(m00) : 0
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvMoments.GetSpatialMoment(System.Int32,System.Int32)">
            <summary>
            Retrieves the spatial moment, which in case of image moments is defined as:
            M_{x_order,y_order}=sum_{x,y}(I(x,y) * x^{x_order} * y^{y_order})
            where I(x,y) is the intensity of the pixel (x, y). 
            </summary>
            <param name="xOrder">x order of the retrieved moment, x_order &gt;= 0</param>
            <param name="yOrder">y order of the retrieved moment, y_order &gt;= 0 and x_order + y_order &lt;= 3</param>
            <returns>The spatial moment of the specific order</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvMoments.GetCentralMoment(System.Int32,System.Int32)">
            <summary>
            Retrieves the central moment, which in case of image moments is defined as:
            mu_{x_order,y_order}=sum_{x,y}(I(x,y)*(x-x_c)^{x_order} * (y-y_c)^{y_order}),
            where x_c=M10/M00, y_c=M01/M00 - coordinates of the gravity center
            </summary>
            <param name="xOrder">x order of the retrieved moment, x_order &gt;= 0.</param>
            <param name="yOrder">y order of the retrieved moment, y_order &gt;= 0 and x_order + y_order &lt;= 3</param>
            <returns>The center moment</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvMoments.GetNormalizedCentralMoment(System.Int32,System.Int32)">
            <summary>
            Retrieves normalized central moment, which in case of image moments is defined as:
            eta_{x_order,y_order}=mu_{x_order,y_order} / M00^{(y_order+x_order)/2+1},
            where mu_{x_order,y_order} is the central moment
            </summary>
            <param name="xOrder">x order of the retrieved moment, x_order &gt;= 0.</param>
            <param name="yOrder">y order of the retrieved moment, y_order &gt;= 0 and x_order + y_order &lt;= 3</param>
            <returns>The normalized center moment</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvMoments.GetHuMoment">
            <summary>
            Get the HuMoments 
            </summary>
            <returns>The Hu moment computed from this moment</returns>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMoments.GravityCenter">
            <summary>
            The Gravity Center of this Moment
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvObjectDetection">
            <summary>
            Structure contains the bounding box and confidence level for detected object
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvObjectDetection.Rect">
            <summary>
            Bounding box for a detected object
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvObjectDetection.Score">
            <summary>
            Confidence level 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvObjectDetection.ClassId">
            <summary>
            The class identifier
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvPoint2D64f">
            <summary>
            Managed Structure equivalent to CvPoint2D64f
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint2D64f.X">
            <summary>
            x-coordinate
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint2D64f.Y">
            <summary>
            y-coordinate
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint2D64f.#ctor(System.Double,System.Double)">
            <summary>
            Create a MCvPoint2D64f structure with the specific x and y coordinates
            </summary>
            <param name="x">x-coordinate</param>
            <param name="y">y-coordinate</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint2D64f.op_Addition(Emgu.CV.Structure.MCvPoint2D64f,Emgu.CV.Structure.MCvPoint2D64f)">
            <summary>
            Compute the sum of two 3D points
            </summary>
            <param name="p1">The first point to be added</param>
            <param name="p2">The second point to be added</param>
            <returns>The sum of two points</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint2D64f.op_Subtraction(Emgu.CV.Structure.MCvPoint2D64f,Emgu.CV.Structure.MCvPoint2D64f)">
            <summary>
            Subtract <paramref name="p2"/> from <paramref name="p1"/>
            </summary>
            <param name="p1">The first point</param>
            <param name="p2">The point to be added</param>
            <returns>The sum of two points</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint2D64f.op_Multiply(Emgu.CV.Structure.MCvPoint2D64f,System.Double)">
            <summary>
            Multiply the point with a scale
            </summary>
            <param name="p">The point to be multiplied</param>
            <param name="scale">The scale</param>
            <returns>The point multiplied by the scale</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint2D64f.op_Multiply(System.Double,Emgu.CV.Structure.MCvPoint2D64f)">
            <summary>
            Multiply the point with a scale
            </summary>
            <param name="p">The point to be multiplied</param>
            <param name="scale">The scale</param>
            <returns>The point multiplied by the scale</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint2D64f.Equals(Emgu.CV.Structure.MCvPoint2D64f)">
            <summary>
            Returns true if the two points equals.
            </summary>
            <param name="other">The other point to compare with</param>
            <returns>True if the two points equals</returns>
        </member>
        <member name="T:Emgu.CV.Structure.MCvPoint3D32f">
            <summary>
            Managed Structure equivalent to CvPoint3D32f
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint3D32f.X">
            <summary>
            x-coordinate
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint3D32f.Y">
            <summary>
            y-coordinate
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint3D32f.Z">
            <summary>
            z-coordinate
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Create a MCvPoint3D32f structure with the specific x and y coordinates
            </summary>
            <param name="x">x-coordinate</param>
            <param name="y">y-coordinate</param>
            <param name="z">z-coordinate</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.CrossProduct(Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Return the cross product of two 3D point
            </summary>
            <param name="point">the other 3D point</param>
            <returns>The cross product of the two 3D point</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.DotProduct(Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Return the dot product of two 3D point
            </summary>
            <param name="point">the other 3D point</param>
            <returns>The dot product of the two 3D point</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.GetNormalizedPoint">
            <summary>
            Get the normalized point
            </summary>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.op_Implicit(Emgu.CV.Structure.MCvPoint3D32f)~Emgu.CV.Structure.MCvPoint3D64f">
            <summary>
            The implicit operator to convert MCvPoint3D32f to MCvPoint3D64f
            </summary>
            <param name="point">The point to be converted</param>
            <returns>The converted point</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.op_Subtraction(Emgu.CV.Structure.MCvPoint3D32f,Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Subtract one point from the other
            </summary>
            <param name="p1">The point to subtract from</param>
            <param name="p2">The value to be subtracted</param>
            <returns>The subtraction of one point from the other</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.op_Addition(Emgu.CV.Structure.MCvPoint3D32f,Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Compute the sum of two 3D points
            </summary>
            <param name="p1">The first point to be added</param>
            <param name="p2">The second point to be added</param>
            <returns>The sum of two points</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.op_Multiply(Emgu.CV.Structure.MCvPoint3D32f,System.Single)">
            <summary>
            Multiply the point with a scale
            </summary>
            <param name="p">The point to be multiplied</param>
            <param name="scale">The scale</param>
            <returns>The point multiplied by the scale</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.op_Multiply(System.Single,Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Multiply the point with a scale
            </summary>
            <param name="p">The point to be multiplied</param>
            <param name="scale">The scale</param>
            <returns>The point multiplied by the scale</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.Equals(Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Return true if the location of the two points are equal
            </summary>
            <param name="other">The other point to compare with</param>
            <returns>True if the location of the two points are equal</returns>
        </member>
        <member name="P:Emgu.CV.Structure.MCvPoint3D32f.Norm">
            <summary>
            return the norm of this 3D point
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvPoint3D64f">
            <summary>
            Managed Structure equivalent to CvPoint3D64f
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint3D64f.X">
            <summary>
            x-coordinate
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint3D64f.Y">
            <summary>
            y-coordinate
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint3D64f.Z">
            <summary>
            z-coordinate
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Create a MCvPoint3D64f structure with the specific x and y coordinates
            </summary>
            <param name="x">x-coordinate</param>
            <param name="y">y-coordinate</param>
            <param name="z">z-coordinate</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.CrossProduct(Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Return the cross product of two 3D point
            </summary>
            <param name="point">the other 3D point</param>
            <returns>The cross product of the two 3D point</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.DotProduct(Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Return the dot product of two 3D point
            </summary>
            <param name="point">the other 3D point</param>
            <returns>The dot product of the two 3D point</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.op_Addition(Emgu.CV.Structure.MCvPoint3D64f,Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Compute the sum of two 3D points
            </summary>
            <param name="p1">The first point to be added</param>
            <param name="p2">The second point to be added</param>
            <returns>The sum of two points</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.op_Subtraction(Emgu.CV.Structure.MCvPoint3D64f,Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Subtract <paramref name="p2"/> from <paramref name="p1"/>
            </summary>
            <param name="p1">The first point</param>
            <param name="p2">The point to be added</param>
            <returns>The sum of two points</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.op_Multiply(Emgu.CV.Structure.MCvPoint3D64f,System.Double)">
            <summary>
            Multiply the point with a scale
            </summary>
            <param name="p">The point to be multiplied</param>
            <param name="scale">The scale</param>
            <returns>The point multiplied by the scale</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.op_Multiply(System.Double,Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Multiply the point with a scale
            </summary>
            <param name="p">The point to be multiplied</param>
            <param name="scale">The scale</param>
            <returns>The point multiplied by the scale</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.Equals(Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Check if the other point equals to this point
            </summary>
            <param name="other">The point to be compared</param>
            <returns>True if the two points are equal</returns>
        </member>
        <member name="T:Emgu.CV.Structure.MCvScalar">
            <summary>
            Managed structure equivalent to CvScalar 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvScalar.V0">
            <summary>
            The scalar value
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvScalar.V1">
            <summary>
            The scalar value
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvScalar.V2">
            <summary>
            The scalar value
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvScalar.V3">
            <summary>
            The scalar value
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.ToArray">
            <summary>
            The scalar values as a vector (of size 4)
            </summary>
            <returns>The scalar values as an array</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.#ctor(System.Double)">
            <summary>
            Create a new MCvScalar structure using the specific values
            </summary>
            <param name="v0">v0</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.#ctor(System.Double,System.Double)">
            <summary>
            Create a new MCvScalar structure using the specific values
            </summary>
            <param name="v0">v0</param>
            <param name="v1">v1</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Create a new MCvScalar structure using the specific values
            </summary>
            <param name="v0">v0</param>
            <param name="v1">v1</param>
            <param name="v2">v2</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Create a new MCvScalar structure using the specific values
            </summary>
            <param name="v0">v0</param>
            <param name="v1">v1</param>
            <param name="v2">v2</param>
            <param name="v3">v3</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.ToCode(Emgu.Util.TypeEnum.ProgrammingLanguage)">
            <summary>
            Return the code to generate this MCvScalar from specific language
            </summary>
            <param name="language">The programming language to generate code from</param>
            <returns>The code to generate this MCvScalar from specific language</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.Equals(Emgu.CV.Structure.MCvScalar)">
            <summary>
            Return true if the two MCvScalar equals
            </summary>
            <param name="other">The other MCvScalar to compare with</param>
            <returns>true if the two MCvScalar equals</returns>
        </member>
        <member name="T:Emgu.CV.Structure.MCvSlice">
            <summary>
            Managed structure equivalent to CvSlice
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSlice.start_index">
            <summary>
            Start index
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSlice.end_index">
            <summary>
            End index
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvSlice.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new MCvSlice using the specific start and end index
            </summary>
            <param name="start">start index</param>
            <param name="end">end index</param>
        </member>
        <member name="P:Emgu.CV.Structure.MCvSlice.WholeSeq">
            <summary>
            Get the equivalent of CV_WHOLE_SEQ
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvTermCriteria">
            <summary>
            Managed structure equivalent to CvTermCriteria
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvTermCriteria.Type">
            <summary>
            CV_TERMCRIT value
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvTermCriteria.MaxIter">
            <summary>
            Maximum iteration
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvTermCriteria.Epsilon">
            <summary>
            Epsilon
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvTermCriteria.#ctor(System.Int32)">
            <summary>
            Create the termination criteria using the constrain of maximum iteration
            </summary>
            <param name="maxIteration">The maximum number of iteration allowed</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvTermCriteria.#ctor(System.Double)">
            <summary>
            Create the termination Criteria using only the constrain of epsilon
            </summary>
            <param name="eps"> The epsilon value</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvTermCriteria.#ctor(System.Int32,System.Double)">
            <summary>
            Create the termination criteria using the constrain of maximum iteration as well as epsilon
            </summary>
            <param name="maxIteration">The maximum number of iteration allowed</param>
            <param name="eps">The epsilon value</param>
        </member>
        <member name="T:Emgu.CV.Structure.MDMatch">
            <summary>
            OpenCV's DMatch structure
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MDMatch.QueryIdx">
            <summary>
            Query descriptor index
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MDMatch.TrainIdx">
            <summary>
            Train descriptor index
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MDMatch.ImgIdx">
            <summary>
            Train image index
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MDMatch.Distance">
            <summary>
            Distance
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MIplImage">
            <summary>
            Managed structure equivalent to IplImage
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.NSize">
            <summary>
            sizeof(IplImage) 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ID">
            <summary>
            version (=0)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.NChannels">
            <summary>
            Most of OpenCV functions support 1,2,3 or 4 channels 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.AlphaChannel">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.Depth">
            <summary>
            pixel depth in bits: IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_16U, IPL_DEPTH_16S, IPL_DEPTH_32S, IPL_DEPTH_32F and IPL_DEPTH_64F are supported 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ColorModel0">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ColorModel1">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ColorModel2">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ColorModel3">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ChannelSeq0">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ChannelSeq1">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ChannelSeq2">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ChannelSeq3">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.DataOrder">
            <summary>
            0 - interleaved color channels, 1 - separate color channels.
            cvCreateImage can only create interleaved images 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.Origin">
            <summary>
            0 - top-left origin,
            1 - bottom-left origin (Windows bitmaps style)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.Align">
            <summary>
            Alignment of image rows (4 or 8).
            OpenCV ignores it and uses widthStep instead 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.Width">
            <summary>
            image width in pixels 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.Height">
            <summary>
            image height in pixels 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.Roi">
            <summary>
            image ROI. when it is not NULL, this specifies image region to process 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.MaskROI">
            <summary>
            must be NULL in OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ImageId">
            <summary>
            ditto
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.TileInfo">
            <summary>
            ditto 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ImageSize">
            <summary>
            image data size in bytes
            (=image->height*image->widthStep in case of interleaved data)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ImageData">
            <summary>
            pointer to aligned image data 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.WidthStep">
            <summary>
            size of aligned image row in bytes 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderMode0">
            <summary>
            border completion mode, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderMode1">
            <summary>
            border completion mode, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderMode2">
            <summary>
            border completion mode, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderMode3">
            <summary>
            border completion mode, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderConst0">
            <summary>
            border const, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderConst1">
            <summary>
            border const, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderConst2">
            <summary>
            border const, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderConst3">
            <summary>
            border const, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ImageDataOrigin">
            <summary>
             pointer to a very origin of image data (not necessarily aligned) - it is needed for correct image deallocation 
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MKeyPoint">
            <summary>
            OpenCV's KeyPoint class
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MKeyPoint.Point">
            <summary>
            The location of the keypoint
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MKeyPoint.Size">
            <summary>
            Size of the keypoint
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MKeyPoint.Angle">
            <summary>
            Orientation of the keypoint
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MKeyPoint.Response">
            <summary>
            Response of the keypoint
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MKeyPoint.Octave">
            <summary>
            octave
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MKeyPoint.ClassId">
            <summary>
            class id
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Range">
            <summary>
            The range use to setup the histogram
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Range.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a range of the specific min/max value
            </summary>
            <param name="start">The start value of this range</param>
            <param name="end">The max value of this range</param>
        </member>
        <member name="M:Emgu.CV.Structure.Range.Equals(Emgu.CV.Structure.Range)">
            <summary>
            Return true if the two Range equals
            </summary>
            <param name="other">The other Range to compare with</param>
            <returns>True if the two Range equals</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Range.All">
            <summary>
            return the full range.
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Range.Start">
            <summary>
            The start value of this range
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Range.End">
            <summary>
            The end value of this range
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.RangeF">
            <summary>
            The range use to setup the histogram
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.RangeF.#ctor(System.Single,System.Single)">
            <summary>
            Create a range of the specific min/max value
            </summary>
            <param name="min">The min value of this range</param>
            <param name="max">The max value of this range</param>
        </member>
        <member name="M:Emgu.CV.Structure.RangeF.Equals(Emgu.CV.Structure.RangeF)">
            <summary>
            Return true if the two RangeF equals
            </summary>
            <param name="other">The other RangeF to compare with</param>
            <returns>True if the two RangeF equals</returns>
        </member>
        <member name="P:Emgu.CV.Structure.RangeF.Min">
            <summary>
            The minimum value of this range
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.RangeF.Max">
            <summary>
            The Maximum value of this range
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.RotatedRect">
            <summary>
            Managed structure equivalent to CvBox2D
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.RotatedRect.Center">
            <summary>
            The center of the box
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.RotatedRect.Size">
            <summary>
            The size of the box
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.RotatedRect.Angle">
            <summary>
            The angle between the horizontal axis and the first side (i.e. width) in degrees
            </summary>
            <remarks>Possitive value means counter-clock wise rotation</remarks>
        </member>
        <member name="M:Emgu.CV.Structure.RotatedRect.#ctor(System.Drawing.PointF,System.Drawing.SizeF,System.Single)">
            <summary>
            Create a RotatedRect structure with the specific parameters
            </summary>
            <param name="center">The center of the box</param>
            <param name="size">The size of the box</param>
            <param name="angle">The angle of the box in degrees. Possitive value means counter-clock wise rotation</param>
        </member>
        <member name="M:Emgu.CV.Structure.RotatedRect.Offset(System.Int32,System.Int32)">
            <summary>
            Shift the box by the specific amount
            </summary>
            <param name="x">The x value to be offseted</param>
            <param name="y">The y value to be offseted</param>
        </member>
        <member name="M:Emgu.CV.Structure.RotatedRect.GetVertices">
            <summary>
            Get the 4 verticies of this Box.
            </summary>
            <returns>The vertives of this RotatedRect</returns>
        </member>
        <member name="M:Emgu.CV.Structure.RotatedRect.MinAreaRect">
            <summary>
            Get the minimum enclosing rectangle for this Box
            </summary>
            <returns>The minimum enclosing rectangle for this Box</returns>
        </member>
        <member name="M:Emgu.CV.Structure.RotatedRect.Equals(Emgu.CV.Structure.RotatedRect)">
            <summary>
            Returns true if the two box are equal
            </summary>
            <param name="other">The other box to compare with</param>
            <returns>True if two boxes are equal</returns>
        </member>
        <member name="M:Emgu.CV.Structure.RotatedRect.op_Implicit(System.Drawing.RectangleF)~Emgu.CV.Structure.RotatedRect">
            <summary>
            Convert a RectangleF to RotatedRect
            </summary>
            <param name="rectangle">The rectangle</param>
            <returns>The equivalent RotatedRect</returns>
        </member>
        <member name="P:Emgu.CV.Structure.RotatedRect.Empty">
            <summary>
            Represent an uninitialized RotatedRect
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Triangle2DF">
            <summary>
            A 2D triangle
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Triangle2DF.#ctor(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            Create a triangle using the specific vertices
            </summary>
            <param name="v0">The first vertex</param>
            <param name="v1">The second vertex</param>
            <param name="v2">The third vertex</param>
        </member>
        <member name="M:Emgu.CV.Structure.Triangle2DF.Equals(Emgu.CV.Structure.Triangle2DF)">
            <summary>
            Compare two triangles and return true if equal
            </summary>
            <param name="tri">the other triangles to compare with</param>
            <returns>true if the two triangles equals, false otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Triangle2DF.GetVertices">
            <summary>
            Get the vertices of this triangle
            </summary>
            <returns>The vertices of this triangle</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle2DF.V0">
            <summary>
            One of the vertex of the triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle2DF.V1">
            <summary>
            One of the vertex of the triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle2DF.V2">
            <summary>
            One of the vertex of the triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle2DF.Area">
            <summary>
            Get the area of this triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle2DF.Centeroid">
            <summary>
            Returns the centroid of this triangle
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Triangle3DF">
            <summary>
            A 3D triangle
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Triangle3DF.#ctor(Emgu.CV.Structure.MCvPoint3D32f,Emgu.CV.Structure.MCvPoint3D32f,Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Create a triangle using the specific vertices
            </summary>
            <param name="v0">The first vertex</param>
            <param name="v1">The second vertex</param>
            <param name="v2">The third vertex</param>
        </member>
        <member name="M:Emgu.CV.Structure.Triangle3DF.Equals(Emgu.CV.Structure.Triangle3DF)">
            <summary>
            Compare two triangles and return true if equal
            </summary>
            <param name="tri">the other triangles to compare with</param>
            <returns>true if the two triangles equals, false otherwise</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle3DF.V0">
            <summary>
            One of the vertex of the triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle3DF.V1">
            <summary>
            One of the vertex of the triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle3DF.V2">
            <summary>
            One of the vertex of the triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle3DF.Area">
            <summary>
            Get the area of this triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle3DF.Normal">
            <summary>
            Get the normal of this triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle3DF.Centeroid">
            <summary>
            Returns the centroid of this triangle
            </summary>
        </member>
        <member name="F:Emgu.CV.AlignExposures._alignExposuresPtr">
            <summary>
            The pointer to the native AlignExposures object
            </summary>
        </member>
        <member name="M:Emgu.CV.AlignExposures.DisposeObject">
            <summary>
            Reset the pointer that points to the CalibrateCRF object.
            </summary>
        </member>
        <member name="M:Emgu.CV.AlignMTB.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this AlignMTB object
            </summary>
        </member>
        <member name="T:Emgu.CV.CalibrateCRF">
            <summary>
            The base class for camera response calibration algorithms.
            </summary>
        </member>
        <member name="F:Emgu.CV.CalibrateCRF._calibrateCRFPtr">
            <summary>
            The pointer to the calibrateCRF object
            </summary>
        </member>
        <member name="M:Emgu.CV.CalibrateCRF.Process(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Recovers inverse camera response.
            </summary>
            <param name="src">Vector of input images</param>
            <param name="dst">256x1 matrix with inverse camera response function</param>
            <param name="times">Vector of exposure time values for each image</param>
        </member>
        <member name="M:Emgu.CV.CalibrateCRF.DisposeObject">
            <summary>
            Reset the pointer that points to the CalibrateCRF object.
            </summary>
        </member>
        <member name="T:Emgu.CV.CalibrateDebevec">
            <summary>
            Inverse camera response function is extracted for each brightness value by minimizing an objective function as linear system. Objective function is constructed using pixel values on the same position in all images, extra term is added to make the result smoother.
            </summary>
        </member>
        <member name="M:Emgu.CV.CalibrateDebevec.#ctor(System.Int32,System.Single,System.Boolean)">
            <summary>
            Creates CalibrateDebevec object.
            </summary>
            <param name="samples">Number of pixel locations to use</param>
            <param name="lambda">Smoothness term weight. Greater values produce smoother results, but can alter the response.</param>
            <param name="random">If true sample pixel locations are chosen at random, otherwise the form a rectangular grid.</param>
        </member>
        <member name="M:Emgu.CV.CalibrateDebevec.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this CalibrateCRF object
            </summary>
        </member>
        <member name="T:Emgu.CV.CalibrateRobertson">
            <summary>
            Inverse camera response function is extracted for each brightness value by minimizing an objective function as linear system. This algorithm uses all image pixels.
            </summary>
        </member>
        <member name="M:Emgu.CV.CalibrateRobertson.#ctor(System.Int32,System.Single)">
            <summary>
            Creates CalibrateRobertson object.
            </summary>
            <param name="maxIter">maximal number of Gauss-Seidel solver iterations.</param>
            <param name="threshold">get difference between results of two successive steps of the minimization.</param>
        </member>
        <member name="M:Emgu.CV.CalibrateRobertson.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this CalibrateCRF object
            </summary>
        </member>
        <member name="T:Emgu.CV.MergeExposures">
            <summary>
            The base class algorithms that can merge exposure sequence to a single image.
            </summary>
        </member>
        <member name="F:Emgu.CV.MergeExposures._mergeExposuresPtr">
            <summary>
            The pointer to the unmanaged MergeExposure object
            </summary>
        </member>
        <member name="M:Emgu.CV.MergeExposures.Process(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Merges images.
            </summary>
            <param name="src">Vector of input images</param>
            <param name="dst">Result image</param>
            <param name="times">Vector of exposure time values for each image</param>
            <param name="response">256x1 matrix with inverse camera response function for each pixel value, it should have the same number of channels as images.</param>
        </member>
        <member name="M:Emgu.CV.MergeExposures.DisposeObject">
            <summary>
            Reset the native pointer to the MergeExposure object
            </summary>
        </member>
        <member name="T:Emgu.CV.MergeDebevec">
            <summary>
            The resulting HDR image is calculated as weighted average of the exposures considering exposure values and camera response.
            </summary>
        </member>
        <member name="M:Emgu.CV.MergeDebevec.#ctor">
            <summary>
            Creates MergeDebevec object.
            </summary>
        </member>
        <member name="M:Emgu.CV.MergeDebevec.DisposeObject">
            <summary>
            Release the MergeDebevec object
            </summary>
        </member>
        <member name="T:Emgu.CV.MergeMertens">
            <summary>
            Pixels are weighted using contrast, saturation and well-exposedness measures, than images are combined using laplacian pyramids.
            The resulting image weight is constructed as weighted average of contrast, saturation and well-exposedness measures.
            The resulting image doesn't require tonemapping and can be converted to 8-bit image by multiplying by 255, but it's recommended to apply gamma correction and/or linear tonemapping.
            </summary>
        </member>
        <member name="M:Emgu.CV.MergeMertens.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Creates MergeMertens object.
            </summary>
            <param name="contrastWeight">contrast measure weight.</param>
            <param name="saturationWeight">saturation measure weight</param>
            <param name="exposureWeight">well-exposedness measure weight</param>
        </member>
        <member name="M:Emgu.CV.MergeMertens.Process(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Merges images.
            </summary>
            <param name="src">Vector of input images</param>
            <param name="dst">Result image</param>
        </member>
        <member name="M:Emgu.CV.MergeMertens.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this MergeMertens object
            </summary>
        </member>
        <member name="T:Emgu.CV.MergeRobertson">
            <summary>
            The resulting HDR image is calculated as weighted average of the exposures considering exposure values and camera response
            </summary>
        </member>
        <member name="M:Emgu.CV.MergeRobertson.#ctor">
            <summary>
            Creates MergeRobertson object.
            </summary>
        </member>
        <member name="M:Emgu.CV.MergeRobertson.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this MergeRobertson object
            </summary>
        </member>
        <member name="T:Emgu.CV.Tonemap">
            <summary>
            Base class for tonemapping algorithms - tools that are used to map HDR image to 8-bit range.
            </summary>
        </member>
        <member name="F:Emgu.CV.Tonemap._tonemapPtr">
            <summary>
            The pointer to the unmanaged Tonemap object
            </summary>
        </member>
        <member name="M:Emgu.CV.Tonemap.#ctor(System.IntPtr,System.IntPtr)">
            <summary>
            Default constructor that creates empty Tonemap
            </summary>
            <param name="ptr">The pointer to the unmanaged object</param>
            <param name="tonemapPtr">The pointer to the tonemap object</param>
        </member>
        <member name="M:Emgu.CV.Tonemap.#ctor(System.Single)">
            <summary>
            Creates simple linear mapper with gamma correction.
            </summary>
            <param name="gamma">positive value for gamma correction. Gamma value of 1.0 implies no correction, gamma equal to 2.2f is suitable for most displays. Generally gamma &gt; 1 brightens the image and gamma &lt; 1 darkens it.</param>
        </member>
        <member name="M:Emgu.CV.Tonemap.Process(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Tonemaps image.
            </summary>
            <param name="src">Source image - 32-bit 3-channel Mat</param>
            <param name="dst">destination image - 32-bit 3-channel Mat with values in [0, 1] range</param>
        </member>
        <member name="M:Emgu.CV.Tonemap.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this Tonemap
            </summary>
        </member>
        <member name="P:Emgu.CV.Tonemap.Gamma">
            <summary>
            Positive value for gamma correction. Gamma value of 1.0 implies no correction, gamma equal to 2.2f is suitable for most displays.
            </summary>
        </member>
        <member name="T:Emgu.CV.TonemapDrago">
            <summary>
            Adaptive logarithmic mapping is a fast global tonemapping algorithm that scales the image in logarithmic domain.
            Since it's a global operator the same function is applied to all the pixels, it is controlled by the bias parameter.
            </summary>
        </member>
        <member name="M:Emgu.CV.TonemapDrago.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Creates TonemapDrago object.
            </summary>
            <param name="gamma">gamma value for gamma correction.</param>
            <param name="saturation">positive saturation enhancement value. 1.0 preserves saturation, values greater than 1 increase saturation and values less than 1 decrease it.</param>
            <param name="bias">	value for bias function in [0, 1] range. Values from 0.7 to 0.9 usually give best results, default value is 0.85.</param>
        </member>
        <member name="M:Emgu.CV.TonemapDrago.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this TonemapDrago
            </summary>
        </member>
        <member name="P:Emgu.CV.TonemapDrago.Saturation">
            <summary>
            Positive saturation enhancement value. 1.0 preserves saturation, values greater than 1 increase saturation and values less than 1 decrease it.
            </summary>
        </member>
        <member name="P:Emgu.CV.TonemapDrago.Bias">
            <summary>
            Value for bias function in [0, 1] range. Values from 0.7 to 0.9 usually give best results, default value is 0.85.
            </summary>
        </member>
        <member name="T:Emgu.CV.TonemapDurand">
            <summary>
            This algorithm decomposes image into two layers: base layer and detail layer using bilateral filter and compresses contrast of the base layer thus preserving all the details.
            This implementation uses regular bilateral filter from opencv.
            </summary>
        </member>
        <member name="M:Emgu.CV.TonemapDurand.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates TonemapDurand object.
            </summary>
            <param name="gamma">gamma value for gamma correction. </param>
            <param name="contrast">resulting contrast on logarithmic scale, i. e. log(max / min), where max and min are maximum and minimum luminance values of the resulting image.</param>
            <param name="saturation">saturation enhancement value. </param>
            <param name="sigmaSpace">bilateral filter sigma in color space</param>
            <param name="sigmaColor">bilateral filter sigma in coordinate space</param>
        </member>
        <member name="M:Emgu.CV.TonemapDurand.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this TonemapDurand
            </summary>
        </member>
        <member name="P:Emgu.CV.TonemapDurand.Saturation">
            <summary>
            Positive saturation enhancement value. 1.0 preserves saturation, values greater than 1 increase saturation and values less than 1 decrease it.
            </summary>
        </member>
        <member name="P:Emgu.CV.TonemapDurand.Contrast">
            <summary>
            Resulting contrast on logarithmic scale, i. e. log(max / min), where max and min are maximum and minimum luminance values of the resulting image.
            </summary>
        </member>
        <member name="P:Emgu.CV.TonemapDurand.SigmaSpace">
            <summary>
            Bilateral filter sigma in color space
            </summary>
        </member>
        <member name="P:Emgu.CV.TonemapDurand.SigmaColor">
            <summary>
            bilateral filter sigma in coordinate space
            </summary>
        </member>
        <member name="T:Emgu.CV.TonemapReinhard">
            <summary>
            This is a global tonemapping operator that models human visual system.
            Mapping function is controlled by adaptation parameter, that is computed using light adaptation and color adaptation.
            </summary>
        </member>
        <member name="M:Emgu.CV.TonemapReinhard.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates TonemapReinhard object.
            </summary>
            <param name="gamma">gamma value for gamma correction</param>
            <param name="intensity">result intensity in [-8, 8] range. Greater intensity produces brighter results.</param>
            <param name="lightAdapt">light adaptation in [0, 1] range. If 1 adaptation is based only on pixel value, if 0 it's global, otherwise it's a weighted mean of this two cases.</param>
            <param name="colorAdapt">chromatic adaptation in [0, 1] range. If 1 channels are treated independently, if 0 adaptation level is the same for each channel.</param>
        </member>
        <member name="M:Emgu.CV.TonemapReinhard.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this TonemapReinhard
            </summary>
        </member>
        <member name="P:Emgu.CV.TonemapReinhard.Intensity">
            <summary>
            Result intensity in [-8, 8] range. Greater intensity produces brighter results.
            </summary>
        </member>
        <member name="P:Emgu.CV.TonemapReinhard.LightAdaptation">
            <summary>
            Light adaptation in [0, 1] range. If 1 adaptation is based only on pixel value, if 0 it is global, otherwise it is a weighted mean of this two cases.
            </summary>
        </member>
        <member name="P:Emgu.CV.TonemapReinhard.ColorAdaptation">
            <summary>
            chromatic adaptation in [0, 1] range. If 1 channels are treated independently, if 0 adaptation level is the same for each channel.
            </summary>
        </member>
        <member name="T:Emgu.CV.TonemapMantiuk">
            <summary>
            This algorithm transforms image to contrast using gradients on all levels of gaussian pyramid, transforms contrast values to HVS response and scales the response. After this the image is reconstructed from new contrast values.
            </summary>
        </member>
        <member name="M:Emgu.CV.TonemapMantiuk.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Creates TonemapMantiuk object
            </summary>
            <param name="gamma">gamma value for gamma correction.</param>
            <param name="scale">contrast scale factor. HVS response is multiplied by this parameter, thus compressing dynamic range. Values from 0.6 to 0.9 produce best results.</param>
            <param name="saturation">saturation enhancement value.</param>
        </member>
        <member name="M:Emgu.CV.TonemapMantiuk.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this TonemapMantiuk
            </summary>
        </member>
        <member name="P:Emgu.CV.TonemapMantiuk.Saturation">
            <summary>
            Saturation enhancement value.
            </summary>
        </member>
        <member name="P:Emgu.CV.TonemapMantiuk.Scale">
            <summary>
            Contrast scale factor. HVS response is multiplied by this parameter, thus compressing dynamic range. Values from 0.6 to 0.9 produce best results.
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.LineSegment2D">
            <summary> 
            A line segment 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.LineSegment2D._p1">
            <summary> A point on the line </summary>
        </member>
        <member name="F:Emgu.CV.Structure.LineSegment2D._p2">
            <summary> An other point on the line </summary>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2D.#ctor(System.Drawing.Point,System.Drawing.Point)">
            <summary> 
            Create a line segment with the specific starting point and end point 
            </summary>
            <param name="p1">The first point on the line segment</param>
            <param name="p2">The second point on the line segment</param>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2D.Side(System.Drawing.Point)">
            <summary>
            Determine which side of the line the 2D point is at
            </summary>
            <param name="point">the point</param>
            <returns>
            1 if on the right hand side;
            0 if on the line;
            -1 if on the left hand side;
            </returns>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2D.GetExteriorAngleDegree(Emgu.CV.Structure.LineSegment2D)">
            <summary>
            Get the exterior angle between this line and <paramref name="otherLine"/>
            </summary>
            <param name="otherLine">The other line</param>
            <returns>The exterior angle between this line and <paramref name="otherLine"/></returns>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2D.P1">
            <summary> A point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2D.P2">
            <summary> An other point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2D.Direction">
            <summary> The direction of the line, the norm of which is 1 </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2D.Length">
            <summary> 
            Get the length of the line segment 
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.LineSegment2DF">
            <summary> 
            A line segment 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.LineSegment2DF._p1">
            <summary> A point on the line </summary>
        </member>
        <member name="F:Emgu.CV.Structure.LineSegment2DF._p2">
            <summary> An other point on the line </summary>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2DF.#ctor(System.Drawing.PointF,System.Drawing.PointF)">
            <summary> 
            Create a line segment with the specific start point and end point 
            </summary>
            <param name="p1">The first point on the line segment</param>
            <param name="p2">The second point on the line segment</param>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2DF.YByX(System.Single)">
            <summary> Obtain the Y value from the X value using first degree interpolation</summary>
            <param name="x">The X value</param>
            <returns>The Y value</returns>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2DF.Side(System.Drawing.PointF)">
            <summary>
            Determin which side of the line the 2D point is at
            </summary>
            <param name="point">the point</param>
            <returns>
            1 if on the right hand side;
            0 if on the line;
            -1 if on the left hand side;
            </returns>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2DF.GetExteriorAngleDegree(Emgu.CV.Structure.LineSegment2DF)">
            <summary>
            Get the exterior angle between this line and <paramref name="otherLine"/>
            </summary>
            <param name="otherLine">The other line</param>
            <returns>The exterior angle between this line and <paramref name="otherLine"/></returns>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2DF.P1">
            <summary> A point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2DF.P2">
            <summary> An other point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2DF.Length">
            <summary> 
            Get the length of the line segment 
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2DF.Direction">
            <summary> 
            The direction of the line, the norm of which is 1 
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.LineSegment3DF">
            <summary>
            A 3D line segment
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.LineSegment3DF._p1">
            <summary> A point on the line </summary>
        </member>
        <member name="F:Emgu.CV.Structure.LineSegment3DF._p2">
            <summary> An other point on the line </summary>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment3DF.#ctor(Emgu.CV.Structure.MCvPoint3D32f,Emgu.CV.Structure.MCvPoint3D32f)">
            <summary> 
            Create a line segment with the specific start point and end point 
            </summary>
            <param name="p1">The first point on the line segment</param>
            <param name="p2">The second point on the line segment</param>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment3DF.P1">
            <summary> A point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment3DF.P2">
            <summary> An other point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment3DF.Length">
            <summary> 
            Get the length of the line segment 
            </summary>
        </member>
        <member name="T:Emgu.CV.PointCollection">
            <summary>
            A collection of points
            </summary>
        </member>
        <member name="M:Emgu.CV.PointCollection.EllipseLeastSquareFitting(System.Drawing.PointF[])">
            <summary>
            Fit an ellipse to the points collection
            </summary>
            <param name="points">The points to be fitted</param>
            <returns>An ellipse</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection.PolyLine(System.Drawing.PointF[],System.Boolean)">
            <summary>
            convert a series of points to LineSegment2D
            </summary>
            <param name="points">the array of points</param>
            <param name="closed">if true, the last line segment is defined by the last point of the array and the first point of the array</param>
            <returns>array of LineSegment2D</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection.PolyLine(System.Drawing.Point[],System.Boolean)">
            <summary>
            convert a series of System.Drawing.Point to LineSegment2D
            </summary>
            <param name="points">the array of points</param>
            <param name="closed">if true, the last line segment is defined by the last point of the array and the first point of the array</param>
            <returns>array of LineSegment2D</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection.BoundingRectangle(System.Drawing.PointF[])">
            <summary>
            Find the bounding rectangle for the specific array of points
            </summary>
            <param name="points">The collection of points</param>
            <returns>The bounding rectangle for the array of points</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection.ReprojectImageTo3D(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Re-project pixels on a 1-channel disparity map to array of 3D points.
            </summary>
            <param name="disparity">Disparity map</param>
            <param name="Q">The re-projection 4x4 matrix, can be arbitrary, e.g. the one, computed by cvStereoRectify</param>
            <returns>The reprojected 3D points</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection.GeneratePointCloud(Emgu.CV.Structure.Ellipse,System.Int32)">
            <summary>
            Generate a random point cloud around the ellipse. 
            </summary>
            <param name="e">The region where the point cloud will be generated. The axes of e corresponds to std of the random point cloud.</param>
            <param name="numberOfPoints">The number of points to be generated</param>
            <returns>A random point cloud around the ellipse</returns>
        </member>
        <member name="T:Emgu.CV.Reflection.ExposableMethodAttribute">
            <summary>
            Attribute used by ImageBox to generate Operation Menu
            </summary>
        </member>
        <member name="M:Emgu.CV.Reflection.ExposableMethodAttribute.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Emgu.CV.Reflection.ExposableMethodAttribute.Exposable">
            <summary>
            Get or Set the exposable value, if true, this function will be displayed in Operation Menu of ImageBox
            </summary>
        </member>
        <member name="P:Emgu.CV.Reflection.ExposableMethodAttribute.Category">
            <summary>
            The catefory of this function
            </summary>
        </member>
        <member name="P:Emgu.CV.Reflection.ExposableMethodAttribute.GenericParametersOptionSizes">
            <summary>
            The size for each generic parameter Options
            </summary>
        </member>
        <member name="P:Emgu.CV.Reflection.ExposableMethodAttribute.GenericParametersOptions">
            <summary>
            The options for generic parameters
            </summary>
        </member>
        <member name="T:Emgu.CV.Reflection.GenericParameter">
            <summary>
            A generic parameter for the Operation class
            </summary>
        </member>
        <member name="M:Emgu.CV.Reflection.GenericParameter.#ctor(System.Type,System.Type[])">
            <summary>
            Create a generic parameter for the Operation class
            </summary>
            <param name="selectedType">The selected generic parameter typ</param>
            <param name="availableType">The types that can be used</param>
        </member>
        <member name="P:Emgu.CV.Reflection.GenericParameter.SelectedType">
            <summary>
            The selected generic parameter type
            </summary>
        </member>
        <member name="P:Emgu.CV.Reflection.GenericParameter.AvailableTypes">
            <summary>
            The types that can be used
            </summary>
        </member>
        <member name="T:Emgu.CV.Reflection.ReflectColorType">
            <summary>
            A collection of reflection function that can be applied to ColorType object
            </summary>
        </member>
        <member name="M:Emgu.CV.Reflection.ReflectColorType.GetDisplayColorOfChannels(Emgu.CV.IColor)">
            <summary>
            Get the display color for each channel
            </summary>
            <param name="color">The color</param>
            <returns>The display color for each channel</returns>
        </member>
        <member name="M:Emgu.CV.Reflection.ReflectColorType.GetNamesOfChannels(Emgu.CV.IColor)">
            <summary>
            Get the names of the channels
            </summary>
            <param name="color">The color</param>
            <returns>The names of the channels</returns>
        </member>
        <member name="T:Emgu.CV.Reflection.ReflectIImage">
            <summary>
            A collection of reflection function that can be applied to IImage object
            </summary>
        </member>
        <member name="M:Emgu.CV.Reflection.ReflectIImage.GetImageMethods(Emgu.CV.IImage)">
            <summary>
            Get all the methods that belongs to the IImage and Image class with ExposableMethodAttribute set true.
            </summary>
            <param name="image">The IImage object to be refelected for methods marked with ExposableMethodAttribute</param>
            <returns>All the methods that belongs to the IImage and Image class with ExposableMethodAttribute set true</returns>
        </member>
        <member name="M:Emgu.CV.Reflection.ReflectIImage.GetTypeOfColor(Emgu.CV.IImage)">
            <summary>
            Get the color type of the image
            </summary>
            <param name="image">The image to apply reflection on</param>
            <returns>The color type of the image</returns>
        </member>
        <member name="M:Emgu.CV.Reflection.ReflectIImage.GetTypeOfDepth(Emgu.CV.IImage)">
            <summary>
            Get the depth type of the image
            </summary>
            <param name="image">The image to apply reflection on</param>
            <returns>The depth type of the image</returns>
        </member>
        <member name="M:Emgu.CV.Reflection.ReflectIImage.GetPixelColor(Emgu.CV.IImage,System.Drawing.Point)">
            <summary>
            Get the color at the specific location of the image
            </summary>
            <param name="image">The image to obtain pixel value from</param>
            <param name="location">The location to sample a pixel</param>
            <returns>The color at the specific location</returns>
        </member>
        <member name="T:Emgu.CV.Shape.HistogramCostExtractor">
            <summary>
            Abstract base class for histogram cost algorithms.
            </summary>
        </member>
        <member name="M:Emgu.CV.Shape.HistogramCostExtractor.DisposeObject">
            <summary>
            Release the histogram cost extractor
            </summary>
        </member>
        <member name="T:Emgu.CV.Shape.NormHistogramCostExtractor">
            <summary>
            A norm based cost extraction.
            </summary>
        </member>
        <member name="M:Emgu.CV.Shape.NormHistogramCostExtractor.#ctor(Emgu.CV.CvEnum.DistType,System.Int32,System.Single)">
            <summary>
            Create a norm based cost extraction.
            </summary>
            <param name="flag">Distance type</param>
            <param name="nDummies">Number of dummies</param>
            <param name="defaultCost">Default cost</param>
        </member>
        <member name="T:Emgu.CV.Shape.EMDHistogramCostExtractor">
            <summary>
            An EMD based cost extraction.
            </summary>
        </member>
        <member name="M:Emgu.CV.Shape.EMDHistogramCostExtractor.#ctor(Emgu.CV.CvEnum.DistType,System.Int32,System.Single)">
            <summary>
            Create an EMD based cost extraction.
            </summary>
            <param name="flag">Distance type</param>
            <param name="nDummies">Number of dummies</param>
            <param name="defaultCost">Default cost</param>
        </member>
        <member name="T:Emgu.CV.Shape.ChiHistogramCostExtractor">
            <summary>
            An Chi based cost extraction.
            </summary>
        </member>
        <member name="M:Emgu.CV.Shape.ChiHistogramCostExtractor.#ctor(System.Int32,System.Single)">
            <summary>
            Create an Chi based cost extraction.
            </summary>
            <param name="nDummies">Number of dummies</param>
            <param name="defaultCost">Default cost</param>
        </member>
        <member name="T:Emgu.CV.Shape.EMDL1HistogramCostExtractor">
            <summary>
            An EMD-L1 based cost extraction.
            </summary>
        </member>
        <member name="M:Emgu.CV.Shape.EMDL1HistogramCostExtractor.#ctor(System.Int32,System.Single)">
            <summary>
            Create an EMD-L1 based cost extraction.
            </summary>
            <param name="nDummies">Number of dummies</param>
            <param name="defaultCost">Default cost</param>
        </member>
        <member name="T:Emgu.CV.Shape.ShapeInvoke">
            <summary>
            Library to invoke functions that belongs to the shape module
            </summary>
        </member>
        <member name="T:Emgu.CV.Shape.ShapeContextDistanceExtractor">
            <summary>
            Implementation of the Shape Context descriptor and matching algorithm proposed by Belongie et al. in Shape Matching and Object Recognition Using Shape Contexts (PAMI 2002). 
            </summary>
        </member>
        <member name="T:Emgu.CV.Shape.ShapeDistanceExtractor">
            <summary>
            Abstract base class for shape distance algorithms.
            </summary>
        </member>
        <member name="F:Emgu.CV.Shape.ShapeDistanceExtractor._shapeDistanceExtractorPtr">
            <summary>
            Pointer to the unmanaged ShapeDistanceExtractor
            </summary>
        </member>
        <member name="M:Emgu.CV.Shape.ShapeDistanceExtractor.ComputeDistance(System.Drawing.Point[],System.Drawing.Point[])">
            <summary>
            Compute the shape distance between two shapes defined by its contours.
            </summary>
            <param name="contour1">Contour defining first shape</param>
            <param name="contour2">Contour defining second shape</param>
            <returns>The shape distance between two shapes defined by its contours.</returns>
        </member>
        <member name="M:Emgu.CV.Shape.ShapeDistanceExtractor.ComputeDistance(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Compute the shape distance between two shapes defined by its contours.
            </summary>
            <param name="contour1">Contour defining first shape</param>
            <param name="contour2">Contour defining second shape</param>
            <returns>The shape distance between two shapes defined by its contours.</returns>
        </member>
        <member name="M:Emgu.CV.Shape.ShapeDistanceExtractor.DisposeObject">
            <summary>
            Release all memory associated with this ShapeDistanceExtractor
            </summary>
        </member>
        <member name="M:Emgu.CV.Shape.ShapeContextDistanceExtractor.#ctor(Emgu.CV.Shape.HistogramCostExtractor,Emgu.CV.Shape.IShapeTransformer,System.Int32,System.Int32,System.Single,System.Single,System.Int32)">
            <summary>
            Create a shape context distance extractor
            </summary>
            <param name="comparer">The histogram cost extractor, use ChiHistogramCostExtractor as default</param>
            <param name="transformer">The shape transformer, use ThinPlateSplineSphapeTransformer as default</param>
            <param name="nAngularBins">Establish the number of angular bins for the Shape Context Descriptor used in the shape matching pipeline.</param>
            <param name="nRadialBins">Establish the number of radial bins for the Shape Context Descriptor used in the shape matching pipeline.</param>
            <param name="innerRadius">Set the inner radius of the shape context descriptor.</param>
            <param name="outerRadius">Set the outer radius of the shape context descriptor.</param>
            <param name="iterations">Iterations</param>
        </member>
        <member name="M:Emgu.CV.Shape.ShapeContextDistanceExtractor.DisposeObject">
            <summary>
            Release the memory associated with this shape context distance extractor
            </summary>
        </member>
        <member name="P:Emgu.CV.Shape.ShapeContextDistanceExtractor.Iterations">
            <summary>
            The number of iterations
            </summary>
        </member>
        <member name="P:Emgu.CV.Shape.ShapeContextDistanceExtractor.AngularBins">
            <summary>
            The number of angular bins in the shape context descriptor.
            </summary>
        </member>
        <member name="P:Emgu.CV.Shape.ShapeContextDistanceExtractor.RadialBins">
            <summary>
            The number of radial bins in the shape context descriptor.
            </summary>
        </member>
        <member name="P:Emgu.CV.Shape.ShapeContextDistanceExtractor.InnerRadius">
            <summary>
            The value of the inner radius.
            </summary>
        </member>
        <member name="P:Emgu.CV.Shape.ShapeContextDistanceExtractor.OuterRadius">
            <summary>
            The value of the outer radius.
            </summary>
        </member>
        <member name="P:Emgu.CV.Shape.ShapeContextDistanceExtractor.RotationInvariant">
            <summary>
            Rotation Invariant
            </summary>
        </member>
        <member name="P:Emgu.CV.Shape.ShapeContextDistanceExtractor.ShapeContextWeight">
            <summary>
            The weight of the shape context distance in the final distance value.
            </summary>
        </member>
        <member name="P:Emgu.CV.Shape.ShapeContextDistanceExtractor.ImageAppearanceWeight">
            <summary>
            The weight of the appearance cost in the final distance value.
            </summary>
        </member>
        <member name="P:Emgu.CV.Shape.ShapeContextDistanceExtractor.BendingEnergyWeight">
            <summary>
            The weight of the Bending Energy in the final distance value.
            </summary>
        </member>
        <member name="P:Emgu.CV.Shape.ShapeContextDistanceExtractor.StdDev">
            <summary>
            Standard Deviation.
            </summary>
        </member>
        <member name="T:Emgu.CV.Shape.HausdorffDistanceExtractor">
            <summary>
            A simple Hausdorff distance measure between shapes defined by contours, according to the paper Comparing Images using the Hausdorff distance. by D.P. Huttenlocher, G.A. Klanderman, and W.J. Rucklidge. (PAMI 1993).
            </summary>
        </member>
        <member name="M:Emgu.CV.Shape.HausdorffDistanceExtractor.#ctor(Emgu.CV.CvEnum.DistType,System.Single)">
            <summary>
            Create Hausdorff distance extractor
            </summary>
            <param name="distanceFlag">Rhe norm used to compute the Hausdorff value between two shapes. It can be L1 or L2 norm.</param>
            <param name="rankProp">The rank proportion (or fractional value) that establish the Kth ranked value of the partial Hausdorff distance. Experimentally had been shown that 0.6 is a good value to compare shapes.</param>
        </member>
        <member name="M:Emgu.CV.Shape.HausdorffDistanceExtractor.DisposeObject">
            <summary>
            Release the memory associated with this Hausdorff distance extrator
            </summary>
        </member>
        <member name="T:Emgu.CV.Shape.IShapeTransformer">
            <summary>
            Abstract base class for shape transformation algorithms.
            </summary>
        </member>
        <member name="P:Emgu.CV.Shape.IShapeTransformer.ShapeTransformerPtr">
            <summary>
            Get the pointer to the unmanaged shape transformer
            </summary>
        </member>
        <member name="T:Emgu.CV.Shape.ThinPlateSplineShapeTransformer">
            <summary>
            Definition of the transformation ocupied in the paper Principal Warps: Thin-Plate Splines and Decomposition of Deformations, by F.L. Bookstein (PAMI 1989).
            </summary>
        </member>
        <member name="M:Emgu.CV.Shape.ThinPlateSplineShapeTransformer.#ctor(System.Double)">
            <summary>
            Create a thin plate spline shape transformer
            </summary>
            <param name="regularizationParameter">The regularization parameter for relaxing the exact interpolation requirements of the TPS algorithm.</param>
        </member>
        <member name="M:Emgu.CV.Shape.ThinPlateSplineShapeTransformer.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this ShapeTransformer object
            </summary>
        </member>
        <member name="P:Emgu.CV.Shape.ThinPlateSplineShapeTransformer.ShapeTransformerPtr">
            <summary>
            Get the pointer the the native ShapeTransformer
            </summary>
        </member>
        <member name="T:Emgu.CV.Shape.AffineTransformer">
            <summary>
            Wrapper class for the OpenCV Affine Transformation algorithm.
            </summary>
        </member>
        <member name="M:Emgu.CV.Shape.AffineTransformer.#ctor(System.Boolean)">
            <summary>
            Create an affine transformer
            </summary>
            <param name="fullAffine">Full affine</param>
        </member>
        <member name="M:Emgu.CV.Shape.AffineTransformer.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this ShapeTransformer object
            </summary>
        </member>
        <member name="P:Emgu.CV.Shape.AffineTransformer.ShapeTransformerPtr">
            <summary>
            Get the pointer to the native ShapeTransformer
            </summary>
        </member>
        <member name="T:Emgu.CV.SparseMatrix`1">
            <summary>
            Create a sparse matrix
            </summary>
            <typeparam name="TDepth">The type of elements in this matrix</typeparam>
        </member>
        <member name="M:Emgu.CV.SparseMatrix`1.#ctor(System.Int32[])">
            <summary>
            Create a sparse matrix of the specific dimension
            </summary>
            <param name="dimension">The dimension of the sparse matrix</param>
        </member>
        <member name="M:Emgu.CV.SparseMatrix`1.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this sparse matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.SparseMatrix`1.Item(System.Int32,System.Int32)">
            <summary>
            Get or Set the value in the specific <paramref name="row"/> and <paramref name="col"/>
            </summary>
            <param name="row">the row of the element</param>
            <param name="col">the col of the element</param>
            <returns>The element on the specific <paramref name="row"/> and <paramref name="col"/></returns>
        </member>
        <member name="T:Emgu.CV.StereoBM">
            <summary>
            Class for computing stereo correspondence using the block matching algorithm, introduced and contributed to OpenCV by K. Konolige.
            </summary>
        </member>
        <member name="M:Emgu.CV.StereoBM.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a stereoBM object
            </summary>
            <param name="blockSize">the linear size of the blocks compared by the algorithm. The size should be odd (as the block is centered at the current pixel). Larger block size implies smoother, though less accurate disparity map. Smaller block size gives more detailed disparity map, but there is higher chance for algorithm to find a wrong correspondence.</param>
            <param name="numberOfDisparities">the disparity search range. For each pixel algorithm will find the best disparity from 0 (default minimum disparity) to <paramref name="numberOfDisparities"/>. The search range can then be shifted by changing the minimum disparity.</param>
        </member>
        <member name="M:Emgu.CV.StereoBM.DisposeObject">
            <summary>
            Release the stereo state and all the memory associate with it
            </summary>
        </member>
        <member name="P:Emgu.CV.StereoBM.StereoMatcherPtr">
            <summary>
            Pointer to the stereo matcher
            </summary>
        </member>
        <member name="T:Emgu.CV.StereoMatcherExtensions">
            <summary>
            Extension methods for StereoMather
            </summary>
        </member>
        <member name="M:Emgu.CV.StereoMatcherExtensions.Compute(Emgu.CV.IStereoMatcher,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Computes disparity map for the specified stereo pair
            </summary>
            <param name="matcher">The stereo matcher</param>
            <param name="left">Left 8-bit single-channel image.</param>
            <param name="right">Right image of the same size and the same type as the left one.</param>
            <param name="disparity">Output disparity map. It has the same size as the input images. Some algorithms, like StereoBM or StereoSGBM compute 16-bit fixed-point disparity map (where each disparity value has 4 fractional bits), whereas other algorithms output 32-bit floating-point disparity map</param>
        </member>
        <member name="T:Emgu.CV.StereoSGBM">
            <summary>
            This is a variation of
            "Stereo Processing by Semiglobal Matching and Mutual Information"
            by Heiko Hirschmuller.
            We match blocks rather than individual pixels, thus the algorithm is called
            SGBM (Semi-global block matching)
            </summary>
        </member>
        <member name="M:Emgu.CV.StereoSGBM.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Emgu.CV.StereoSGBM.Mode)">
            <summary>
            Create a stereo disparity solver using StereoSGBM algorithm (combination of H. Hirschmuller + K. Konolige approaches) 
            </summary>
            <param name="minDisparity">Minimum possible disparity value. Normally, it is zero but sometimes rectification algorithms can shift images, so this parameter needs to be adjusted accordingly.</param>
            <param name="numDisparities">Maximum disparity minus minimum disparity. The value is always greater than zero. In the current implementation, this parameter must be divisible by 16.</param>
            <param name="blockSize">Matched block size. It must be an odd number &gt;=1 . Normally, it should be somewhere in the 3..11 range. Use 0 for default. </param>
            <param name="p1">The first parameter controlling the disparity smoothness. It is the penalty on the disparity change by plus or minus 1 between neighbor pixels. Reasonably good value is 8*number_of_image_channels*SADWindowSize*SADWindowSize. Use 0 for default</param>
            <param name="p2">The second parameter controlling the disparity smoothness. It is the penalty on the disparity change by more than 1 between neighbor pixels. The algorithm requires <paramref name="p2"/> &gt; <paramref name="p1"/>. Reasonably good value is 32*number_of_image_channels*SADWindowSize*SADWindowSize. Use 0 for default</param>
            <param name="disp12MaxDiff">Maximum allowed difference (in integer pixel units) in the left-right disparity check. Set it to a non-positive value to disable the check.</param>
            <param name="preFilterCap">Truncation value for the prefiltered image pixels. The algorithm first computes x-derivative at each pixel and clips its value by [-preFilterCap, preFilterCap] interval. The result values are passed to the Birchfield-Tomasi pixel cost function.</param>
            <param name="uniquenessRatio">Margin in percentage by which the best (minimum) computed cost function value should win the second best value to consider the found match correct. Normally, a value within the 5-15 range is good enough.</param>
            <param name="speckleWindowSize">Maximum size of smooth disparity regions to consider their noise speckles and invalidate. Set it to 0 to disable speckle filtering. Otherwise, set it somewhere in the 50-200 range</param>
            <param name="speckleRange">Maximum disparity variation within each connected component. If you do speckle filtering, set the parameter to a positive value, it will be implicitly multiplied by 16. Normally, 1 or 2 is good enough.</param>
            <param name="mode">Set it to HH to run the full-scale two-pass dynamic programming algorithm. It will consume O(W*H*numDisparities) bytes, which is large for 640x480 stereo and huge for HD-size pictures. By default, it is set to false.</param>
        </member>
        <member name="M:Emgu.CV.StereoSGBM.DisposeObject">
            <summary>
            Release the unmanged memory associated with this stereo solver
            </summary>
        </member>
        <member name="P:Emgu.CV.StereoSGBM.StereoMatcherPtr">
            <summary>
            Pointer to the StereoMatcher 
            </summary>
        </member>
        <member name="T:Emgu.CV.StereoSGBM.Mode">
            <summary>
            The SGBM mode
            </summary>
        </member>
        <member name="F:Emgu.CV.StereoSGBM.Mode.SGBM">
            <summary>
            This is the default mode, the algorithm is single-pass, which means that you consider only 5 directions instead of 8
            </summary>
        </member>
        <member name="F:Emgu.CV.StereoSGBM.Mode.HH">
            <summary>
            Run the full-scale two-pass dynamic programming algorithm. It will consume O(W*H*numDisparities) bytes, which is large for 640x480 stereo and huge for HD-size pictures.
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.FeaturesFinder">
            <summary>
            Finds features in the given image.
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.FeaturesFinder._featuresFinderPtr">
            <summary>
            Pointer to the unmanaged FeaturesFinder object
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.FeaturesFinder.FeaturesFinderPtr">
            <summary>
            Get the pointer to the unmanaged FeaturesFinder object
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.OrbFeaturesFinder">
            <summary>
            ORB features finder.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.OrbFeaturesFinder.#ctor(System.Drawing.Size,System.Int32,System.Single,System.Int32)">
            <summary>
            Creates an ORB features finder
            </summary>
            <param name="gridSize">Use (3, 1) for default grid size </param>
            <param name="nFeature">The number of desired features. </param>
            <param name="scaleFactor">Coefficient by which we divide the dimensions from one scale pyramid level to the next.</param>
            <param name="nLevels">The number of levels in the scale pyramid. </param>
        </member>
        <member name="M:Emgu.CV.Stitching.OrbFeaturesFinder.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this FeaturesFinder
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.OrbFeaturesFinder.AKAZEFeaturesFinder">
            <summary>
            AKAZE features finder.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.OrbFeaturesFinder.AKAZEFeaturesFinder.#ctor(Emgu.CV.Features2D.AKAZE.DescriptorType,System.Int32,System.Int32,System.Single,System.Int32,System.Int32,Emgu.CV.Features2D.KAZE.Diffusivity)">
            <summary>
            Creates an AKAZE features finder
            </summary>
            <param name="descriptorType">Type of the extracted descriptor</param>
            <param name="descriptorSize">Size of the descriptor in bits. 0 -> Full size</param>
            <param name="descriptorChannels">Number of channels in the descriptor (1, 2, 3)</param>
            <param name="threshold">Detector response threshold to accept point</param>
            <param name="nOctaveLayers"> Default number of sublevels per scale level</param>
            <param name="nOctaves">Maximum octave evolution of the image</param>
            <param name="diffusivity">Diffusivity type</param>
        </member>
        <member name="M:Emgu.CV.Stitching.OrbFeaturesFinder.AKAZEFeaturesFinder.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this FeaturesFinder
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.OrbFeaturesFinder.StitchingInvoke">
            <summary>
            This class wraps the functional calls to the opencv_stitching module
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.Stitcher">
            <summary>
            Image Stitching.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.Stitcher.#ctor(System.Boolean)">
            <summary>
            Creates a stitcher with the default parameters.
            </summary>
            <param name="tryUseGpu">If true, the stitcher will try to use GPU for processing when available</param>
        </member>
        <member name="M:Emgu.CV.Stitching.Stitcher.#ctor(Emgu.CV.Stitching.Stitcher.Mode,System.Boolean)">
            <summary>
            Creates a Stitcher configured in one of the stitching modes.
            </summary>
            <param name="mode">Scenario for stitcher operation. This is usually determined by source of images to stitch and their transformation. </param>
            <param name="tryUseGpu">If true, the stitcher will try to use GPU for processing when available</param>
        </member>
        <member name="M:Emgu.CV.Stitching.Stitcher.Stitch(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Compute the panoramic images given the images
            </summary>
            <param name="images">The input images. This can be, for example, a VectorOfMat</param>
            <param name="pano">The panoramic image</param>
            <returns>The stitching status</returns>
        </member>
        <member name="M:Emgu.CV.Stitching.Stitcher.SetFeaturesFinder(Emgu.CV.Stitching.FeaturesFinder)">
            <summary>
            Set the features finder for this stitcher.
            </summary>
            <param name="finder">The features finder</param>
        </member>
        <member name="M:Emgu.CV.Stitching.Stitcher.SetWarper(Emgu.CV.Stitching.WarperCreator)">
            <summary>
            Set the warper creator for this stitcher.
            </summary>
            <param name="warperCreator">The warper creator</param>
        </member>
        <member name="M:Emgu.CV.Stitching.Stitcher.DisposeObject">
            <summary>
            Release memory associated with this stitcher
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.Stitcher.WaveCorrection">
            <summary>
            Get or Set a flag to indicate if the stitcher should apply wave correction
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.Stitcher.WaveCorrectionKind">
            <summary>
            The wave correction type.
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.Stitcher.PanoConfidenceThresh">
            <summary>
            Get or set the pano confidence threshold
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.Stitcher.CompositingResol">
            <summary>
            Get or Set the compositing resolution
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.Stitcher.SeamEstimationResol">
            <summary>
            Get or Set the seam estimation resolution
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.Stitcher.RegistrationResol">
            <summary>
            Get or set the registration resolution
            </summary>
        </member>
        <member name="P:Emgu.CV.Stitching.Stitcher.WorkScale">
            <summary>
            The work scale
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.Stitcher.Status">
            <summary>
            The stitcher statis
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.Stitcher.Status.Ok">
            <summary>
            Ok.
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.Stitcher.Status.ErrNeedMoreImgs">
            <summary>
            Error, need more images.
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.Stitcher.Status.ErrHomographyEstFail">
            <summary>
            Error, homography estimateion failed.
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.Stitcher.Status.ErrCameraParamsAdjustFail">
            <summary>
            Error, camera parameters adjustment failed.
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.Stitcher.WaveCorrectionType">
            <summary>
            Wave correction kind
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.Stitcher.WaveCorrectionType.Horiz">
            <summary>
            horizontal
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.Stitcher.WaveCorrectionType.Vert">
            <summary>
            Vertical
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.Stitcher.Mode">
            <summary>
            Stitch mode
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.Stitcher.Mode.Panorama">
            <summary>
            Mode for creating photo panoramas. Expects images under perspective transformation and projects resulting pano to sphere.
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.Stitcher.Mode.Scans">
            <summary>
            Mode for composing scans. Expects images under affine transformation does not compensate exposure by default.
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.StitchingInvoke">
            <summary>
            Entry points to the Open CV Stitching module.
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.WarperCreator">
            <summary>
            Finds features in the given image.
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.WarperCreator._warperCreatorPtr">
            <summary>
            Pointer to the unmanaged WarperCreator object
            </summary>
        </member>
        <member name="F:Emgu.CV.Stitching.WarperCreator._rotationWarper">
            <summary>
            Pointer to the unmanaged RotationWarper object
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.WarperCreator.DisposeObject">
            <summary>
            Reset the unmanaged pointer associated to this object
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.WarperCreator.BuildMaps(System.Drawing.Size,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray)">
            <summary>
            Builds the projection maps according to the given camera data.
            </summary>
            <param name="srcSize">Source image size</param>
            <param name="K">Camera intrinsic parameters</param>
            <param name="R">Camera rotation matrix</param>
            <param name="xmap">Projection map for the x axis</param>
            <param name="ymap">Projection map for the y axis</param>
            <returns>Projected image minimum bounding box</returns>
        </member>
        <member name="M:Emgu.CV.Stitching.WarperCreator.Warp(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.BorderType,Emgu.CV.IOutputArray)">
            <summary>
            Projects the image.
            </summary>
            <param name="src">Source image</param>
            <param name="K">Camera intrinsic parameters</param>
            <param name="R">Camera rotation matrix</param>
            <param name="interpMode">Interpolation mode</param>
            <param name="borderMode">Border extrapolation mode</param>
            <param name="dst">Projected image</param>
            <returns>Project image top-left corner</returns>
        </member>
        <member name="P:Emgu.CV.Stitching.WarperCreator.WarperCreatorPtr">
            <summary>
            Get a pointer to the unmanaged WarperCreator object
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.PlaneWarper">
            <summary>
            Warper that maps an image onto the z = 1 plane.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.PlaneWarper.#ctor(System.Single)">
            <summary>
            Construct an instance of the plane warper class.
            </summary>
            <param name="scale">Projected image scale multiplier</param>
        </member>
        <member name="M:Emgu.CV.Stitching.PlaneWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this wraper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.SphericalWarper">
            <summary>
            Warper that maps an image onto the unit sphere located at the origin.
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.SphericalWarper.#ctor(System.Single)">
            <summary>
            Construct an instance of the spherical warper class.
            </summary>
            <param name="scale">Radius of the projected sphere, in pixels. An image spanning the whole sphere will have a width of 2 * scale * PI pixels.</param>
        </member>
        <member name="M:Emgu.CV.Stitching.SphericalWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this wraper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.FisheyeWarper">
            <summary>
            Fisheye Warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.FisheyeWarper.#ctor(System.Single)">
            <summary>
            Create a fisheye warper
            </summary>
            <param name="scale">Projected image scale multiplier</param>
        </member>
        <member name="M:Emgu.CV.Stitching.FisheyeWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this wraper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.StereographicWarper">
            <summary>
            Stereographic Warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.StereographicWarper.#ctor(System.Single)">
            <summary>
            Create a stereographic warper
            </summary>
            <param name="scale">Projected image scale multiplier</param>
        </member>
        <member name="M:Emgu.CV.Stitching.StereographicWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this wraper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.CompressedRectilinearWarper">
            <summary>
            Compressed rectilinear warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.CompressedRectilinearWarper.#ctor(System.Single)">
            <summary>
            Create a compressed rectilinear warper
            </summary>
            <param name="scale">Projected image scale multiplier</param>
        </member>
        <member name="M:Emgu.CV.Stitching.CompressedRectilinearWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this wraper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.PaniniWarper">
            <summary>
            Panini warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.PaniniWarper.#ctor(System.Single)">
            <summary>
            Create a Panini warper
            </summary>
            <param name="scale">Projected image scale multiplier</param>
        </member>
        <member name="M:Emgu.CV.Stitching.PaniniWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this wraper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.PaniniPortraitWarper">
            <summary>
            Panini portrait warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.PaniniPortraitWarper.#ctor(System.Single)">
            <summary>
            Create a panini portrait warper
            </summary>
            <param name="scale">Projected image scale multiplier</param>
        </member>
        <member name="M:Emgu.CV.Stitching.PaniniPortraitWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this wraper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.MercatorWarper">
            <summary>
            Mercator warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.MercatorWarper.#ctor(System.Single)">
            <summary>
            Create a Mercator Warper
            </summary>
            <param name="scale">Projected image scale multiplier</param>
        </member>
        <member name="M:Emgu.CV.Stitching.MercatorWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this wraper
            </summary>
        </member>
        <member name="T:Emgu.CV.Stitching.TransverseMercatorWarper">
            <summary>
            Transverse mercator warper
            </summary>
        </member>
        <member name="M:Emgu.CV.Stitching.TransverseMercatorWarper.#ctor(System.Single)">
            <summary>
            Create a transverse mercator warper
            </summary>
            <param name="scale">Projected image scale multiplier</param>
        </member>
        <member name="M:Emgu.CV.Stitching.TransverseMercatorWarper.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this wraper
            </summary>
        </member>
        <member name="T:Emgu.CV.Subdiv2D">
            <summary>
            Planar Subdivision, can be use to compute Delaunnay's triangulation or Voroni diagram.
            </summary>
        </member>
        <member name="M:Emgu.CV.Subdiv2D.#ctor(System.Drawing.Rectangle)">
            <summary>
            Start the Delaunay's triangulation in the specific region of interest.
            </summary>
            <param name="roi">The region of interest of the triangulation</param>
        </member>
        <member name="M:Emgu.CV.Subdiv2D.#ctor(System.Drawing.PointF[],System.Boolean)">
            <summary>
            Create a planar subdivision from the given points. The ROI is computed as the minimum bounding Rectangle for the input points
            </summary>
            <param name="silent">If true, any exception during insert will be ignored</param>
            <param name="points">The points to be inserted to this planar subdivision</param>
        </member>
        <member name="M:Emgu.CV.Subdiv2D.Insert(System.Drawing.PointF[],System.Boolean)">
            <summary>
            Insert a collection of points to this planar subdivision
            </summary>
            <param name="points">The points to be inserted to this planar subdivision</param>
            <param name="silent">If true, any exception during insert will be ignored</param>
        </member>
        <member name="M:Emgu.CV.Subdiv2D.Insert(System.Drawing.PointF)">
            <summary>
            Insert a point to the triangulation. 
            </summary>
            <param name="point">The point to be inserted</param>
        </member>
        <member name="M:Emgu.CV.Subdiv2D.Locate(System.Drawing.PointF,System.Int32@,System.Int32@)">
            <summary>
            Locates input point within subdivision
            </summary>
            <param name="pt">The point to locate</param>
            <param name="subdiv2DEdge">The output edge the point falls onto or right to</param>
            <param name="subdiv2DPoint">Optional output vertex double pointer the input point coincides with</param>
            <returns>The type of location for the point</returns>
        </member>
        <member name="M:Emgu.CV.Subdiv2D.FindNearest(System.Drawing.PointF,System.Drawing.PointF@)">
            <summary>
            Finds subdivision vertex that is the closest to the input point. It is not necessarily one of vertices of the facet containing the input point, though the facet (located using cvSubdiv2DLocate) is used as a starting point.
            </summary>
            <param name="point">Input point</param>
            <param name="nearestPoint">The nearest subdivision vertex</param>
            <returns>The location type of the point</returns>
        </member>
        <member name="M:Emgu.CV.Subdiv2D.GetVoronoiFacets(System.Int32[])">
            <summary>
            Obtains the list of Voronoi Facets 
            </summary>
            <returns>The list of Voronoi Facets</returns>
        </member>
        <member name="M:Emgu.CV.Subdiv2D.GetDelaunayTriangles(System.Boolean)">
            <summary>
            Returns the triangles subdivision of the current planar subdivision. 
            </summary>
            <remarks>The triangles might contains virtual points that do not belongs to the inserted points, if you do not want those points, set <paramref name="includeVirtualPoints"> to false</paramref></remarks>
            <returns>The triangles subdivision in the current planar subdivision</returns>
        </member>
        <member name="M:Emgu.CV.Subdiv2D.DisposeObject">
            <summary>
            Release unmanaged resources
            </summary>
        </member>
        <member name="T:Emgu.CV.VoronoiFacet">
            <summary>
            A Voronoi Facet
            </summary>
        </member>
        <member name="M:Emgu.CV.VoronoiFacet.#ctor(System.Drawing.PointF,System.Drawing.PointF[])">
            <summary>
            Create a Voronoi facet using the specific <paramref name="point"/> and <paramref name="polyline"/>
            </summary>
            <param name="point">The point this facet associate with </param>
            <param name="polyline">The points that defines the contour of this facet</param>
        </member>
        <member name="P:Emgu.CV.VoronoiFacet.Point">
            <summary>
            The point this facet associates to
            </summary>
        </member>
        <member name="P:Emgu.CV.VoronoiFacet.Vertices">
            <summary>
            Get or set the vertices of this facet
            </summary>
        </member>
        <member name="T:Emgu.CV.Superres.FrameSource">
            <summary>
            Create a video frame source
            </summary>
        </member>
        <member name="F:Emgu.CV.Superres.FrameSource._frameSourcePtr">
            <summary>
            The pointer to the frame source
            </summary>
        </member>
        <member name="M:Emgu.CV.Superres.FrameSource.#ctor(System.String,System.Boolean)">
            <summary>
            Create video frame source from video file
            </summary>
            <param name="fileName">The name of the file</param>
            <param name="tryUseGpu">If true, it will try to create video frame source using gpu</param>
        </member>
        <member name="M:Emgu.CV.Superres.FrameSource.#ctor(System.Int32)">
            <summary> Create a framesource using the specific camera</summary>
            <param name="camIndex"> The index of the camera to create capture from, starting from 0</param>
        </member>
        <member name="M:Emgu.CV.Superres.FrameSource.NextFrame(Emgu.CV.IOutputArray)">
            <summary>
            Get the next frame
            </summary>
        </member>
        <member name="M:Emgu.CV.Superres.FrameSource.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this framesource
            </summary>
        </member>
        <member name="T:Emgu.CV.Superres.SuperResolution">
            <summary>
            Supper resolution
            </summary>
        </member>
        <member name="M:Emgu.CV.Superres.SuperResolution.#ctor(Emgu.CV.Superres.SuperResolution.OpticalFlowType,Emgu.CV.Superres.FrameSource)">
            <summary>
            Create a super resolution solver for the given frameSource
            </summary>
            <param name="type">The type of optical flow algorithm to use</param>
            <param name="frameSource">The frameSource</param>
        </member>
        <member name="M:Emgu.CV.Superres.SuperResolution.DisposeObject">
            <summary>
            Release all the unmanaged memory associated to this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Superres.SuperResolution.OpticalFlowType">
            <summary>
            The type of optical flow algorithms used for super resolution
            </summary>
        </member>
        <member name="F:Emgu.CV.Superres.SuperResolution.OpticalFlowType.Btvl">
            <summary>
            BTVL
            </summary>
        </member>
        <member name="F:Emgu.CV.Superres.SuperResolution.OpticalFlowType.Btvl1Gpu">
            <summary>
            BTVL using gpu
            </summary>
        </member>
        <member name="T:Emgu.CV.Tiff.TiffWriter`2">
            <summary>
            A class that can be used for writing geotiff
            </summary>
            <typeparam name="TColor">The color type of the image to be written</typeparam>
            <typeparam name="TDepth">The depth type of the image to be written</typeparam>
        </member>
        <member name="M:Emgu.CV.Tiff.TiffWriter`2.#ctor(System.String)">
            <summary>
            Create a tiff writer to save an image
            </summary>
            <param name="fileName">The file name to be saved</param>
        </member>
        <member name="M:Emgu.CV.Tiff.TiffWriter`2.WriteImage(Emgu.CV.Image{`0,`1})">
            <summary>
            Write the image to the tiff file
            </summary>
            <param name="image">The image to be written</param>
        </member>
        <member name="M:Emgu.CV.Tiff.TiffWriter`2.WriteGeoTag(System.Double[],System.Double[])">
            <summary>
            Write the geo information into the tiff file
            </summary>
            <param name="modelTiepoint">Model Tie Point, an array of size 6</param>
            <param name="modelPixelScale">Model pixel scale, an array of size 3</param>
        </member>
        <member name="M:Emgu.CV.Tiff.TiffWriter`2.DisposeObject">
            <summary>
            Release the writer and write all data on to disk.
            </summary>
        </member>
        <member name="T:Emgu.CV.Tiff.TileTiffWriter`2">
            <summary>
            A writer for writing GeoTiff
            </summary>
            <typeparam name="TColor">The color type of the image to be written</typeparam>
            <typeparam name="TDepth">The depth type of the image to be written</typeparam>
        </member>
        <member name="M:Emgu.CV.Tiff.TileTiffWriter`2.#ctor(System.String,System.Drawing.Size,System.Drawing.Size)">
            <summary>
            Create a TitleTiffWriter.
            </summary>
            <param name="fileName">The name of the file to be written to</param>
            <param name="imageSize">The size of the image</param>
            <param name="tileSize">The tile size in pixels</param>
        </member>
        <member name="M:Emgu.CV.Tiff.TileTiffWriter`2.WriteTile(System.Int32,System.Int32,Emgu.CV.Image{`0,`1})">
            <summary>
            Write a tile into the tile tiff
            </summary>
            <param name="rowNumber">The starting row for the tile</param>
            <param name="colNumber">The starting col for the tile</param>
            <param name="tile">The tile to be written</param>
        </member>
        <member name="M:Emgu.CV.Tiff.TileTiffWriter`2.WriteImage(Emgu.CV.Image{`0,`1})">
            <summary>
            Write the whole image as tile tiff
            </summary>
            <param name="image">The image to be written</param>
        </member>
        <member name="P:Emgu.CV.Tiff.TileTiffWriter`2.TileSizeInBytes">
            <summary>
            Get the equivalent size for a tile of data as it would be returned in a call to TIFFReadTile or as it would be expected in a call to TIFFWriteTile. 
            </summary>
        </member>
        <member name="P:Emgu.CV.Tiff.TileTiffWriter`2.TileRowSizeInBytes">
            <summary>
            Get the number of bytes of a row of data in a tile. 
            </summary>
        </member>
        <member name="P:Emgu.CV.Tiff.TileTiffWriter`2.TileSize">
            <summary>
            Get tile size in pixels.
            </summary>
        </member>
        <member name="T:Emgu.CV.TimedImage`2">
            <summary> 
            The Image which contains time stamp which specified what time this image is created 
            </summary>
        </member>
        <member name="M:Emgu.CV.TimedImage`2.#ctor">
            <summary>
            Create a empty Image 
            </summary>
        </member>
        <member name="M:Emgu.CV.TimedImage`2.#ctor(System.Int32,System.Int32,`0)">
            <summary>
            Create a blank Image of the specified width, height, depth and color.
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
            <param name="value">The initial color of the image</param>
        </member>
        <member name="M:Emgu.CV.TimedImage`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Create an empty Image of the specified width and height
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
        </member>
        <member name="P:Emgu.CV.TimedImage`2.Timestamp">
            <summary> 
            The time this image is captured
            </summary>
        </member>
        <member name="T:Emgu.CV.UMat">
            <summary>
            The equivalent of cv::Mat, should only be used if you know what you are doing.
            In most case you should use the Matrix class instead
            </summary>
        </member>
        <member name="M:Emgu.CV.UMat.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.UMat.DeserializeObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime deserailization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.UMat.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">streaming context</param>
        </member>
        <member name="M:Emgu.CV.UMat.#ctor">
            <summary>
            Create an empty cv::UMat
            </summary>
        </member>
        <member name="M:Emgu.CV.UMat.#ctor(System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32,Emgu.CV.UMat.Usage)">
            <summary>
            Create a umat of the specific type.
            </summary>
            <param name="rows">Number of rows in a 2D array.</param>
            <param name="cols">Number of columns in a 2D array.</param>
            <param name="type">Mat element type</param>
            <param name="channels">Number of channels</param>
            <param name="usage">Allocation Usage</param>
        </member>
        <member name="M:Emgu.CV.UMat.#ctor(System.Drawing.Size,Emgu.CV.CvEnum.DepthType,System.Int32,Emgu.CV.UMat.Usage)">
            <summary>
            Create a umat of the specific type.
            </summary>
            <param name="size">Size of the UMat</param>
            <param name="type">Mat element type</param>
            <param name="channels">Number of channels</param>
            <param name="usage">Allocation Usage</param>
        </member>
        <member name="M:Emgu.CV.UMat.#ctor(Emgu.CV.UMat,System.Drawing.Rectangle)">
            <summary>
            Get the Umat header for the specific roi of the parent
            </summary>
            <param name="parent">The parent Umat</param>
            <param name="roi">The region of interest</param>
        </member>
        <member name="M:Emgu.CV.UMat.#ctor(Emgu.CV.UMat,Emgu.CV.Structure.Range,Emgu.CV.Structure.Range)">
            <summary>
            Create a umat header for the specific ROI
            </summary>
            <param name="umat">The umat where the new UMat header will share data from</param>
            <param name="rowRange">The region of interest</param>
            <param name="colRange">The region of interest</param>
        </member>
        <member name="M:Emgu.CV.UMat.Create(System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32,Emgu.CV.UMat.Usage)">
            <summary>
            Allocates new array data if needed.
            </summary>
            <param name="rows">New number of rows.</param>
            <param name="cols">New number of columns.</param>
            <param name="type">New matrix element depth type.</param>
            <param name="channels">New matrix number of channels</param>
            <param name="usage">Allocation Usage</param>
        </member>
        <member name="M:Emgu.CV.UMat.#ctor(System.String,Emgu.CV.CvEnum.ImreadModes)">
            <summary>
            Read a UMat from file.
            </summary>
            <param name="fileName">The name of the file</param>
            <param name="loadType">The read mode</param>
        </member>
        <member name="M:Emgu.CV.UMat.CopyTo(Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Copy the data in this umat to the other mat
            </summary>
            <param name="mask">Operation mask. Its non-zero elements indicate which matrix elements need to be copied.</param>
            <param name="m">The input array to copy to</param>
        </member>
        <member name="M:Emgu.CV.UMat.SetTo(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Sets all or some of the array elements to the specified value.
            </summary>
            <param name="value">Assigned scalar converted to the actual array type.</param>
            <param name="mask">Operation mask of the same size as the umat.</param>
        </member>
        <member name="M:Emgu.CV.UMat.SetTo(Emgu.CV.Structure.MCvScalar,Emgu.CV.IInputArray)">
            <summary>
            Sets all or some of the array elements to the specified value.
            </summary>
            <param name="value">Assigned scalar value.</param>
            <param name="mask">Operation mask of the same size as the umat.</param>
        </member>
        <member name="M:Emgu.CV.UMat.GetMat(Emgu.CV.CvEnum.AccessType)">
            <summary>
            Return the Mat representation of the UMat
            </summary>
        </member>
        <member name="M:Emgu.CV.UMat.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this object.
            </summary>
        </member>
        <member name="M:Emgu.CV.UMat.GetInputArray">
            <summary>
            Pointer to the InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.UMat.GetOutputArray">
            <summary>
            Pointer to the OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.UMat.GetInputOutputArray">
            <summary>
            Pointer to the InputOutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.UMat.Reshape(System.Int32,System.Int32)">
            <summary>
            Changes the shape and/or the number of channels of a 2D matrix without copying the data.
            </summary>
            <param name="cn">New number of channels. If the parameter is 0, the number of channels remains the same.</param>
            <param name="rows">New number of rows. If the parameter is 0, the number of rows remains the same.</param>
            <returns>A new mat header that has different shape</returns>
        </member>
        <member name="M:Emgu.CV.UMat.ToImage``2">
            <summary>
            Convert this Mat to Image
            </summary>
            <typeparam name="TColor">The type of Color</typeparam>
            <typeparam name="TDepth">The type of Depth</typeparam>
            <returns>The image</returns>
        </member>
        <member name="M:Emgu.CV.UMat.MinMax(System.Double[]@,System.Double[]@,System.Drawing.Point[]@,System.Drawing.Point[]@)">
            <summary>
            Returns the min / max location and values for the image
            </summary>
            <param name="maxLocations">The maximum locations for each channel </param>
            <param name="maxValues">The maximum values for each channel</param>
            <param name="minLocations">The minimum locations for each channel</param>
            <param name="minValues">The minimum values for each channel</param>
        </member>
        <member name="M:Emgu.CV.UMat.ConvertTo(Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,System.Double,System.Double)">
            <summary>
            Converts an array to another data type with optional scaling.
            </summary>
            <param name="m">Output matrix; if it does not have a proper size or type before the operation, it is reallocated.</param>
            <param name="rtype">Desired output matrix type or, rather, the depth since the number of channels are the same as the input has; if rtype is negative, the output matrix will have the same type as the input.</param>
            <param name="alpha">Optional scale factor.</param>
            <param name="beta">Optional delta added to the scaled values.</param>
        </member>
        <member name="M:Emgu.CV.UMat.Split">
            <summary> 
            Split current Image into an array of gray scale images where each element 
            in the array represent a single color channel of the original image
            </summary>
            <returns> 
            An array of gray scale images where each element  
            in the array represent a single color channel of the original image 
            </returns>
        </member>
        <member name="M:Emgu.CV.UMat.Save(System.String)">
            <summary>
            Save this image to the specific file. 
            </summary>
            <param name="fileName">The name of the file to be saved to</param>
            <remarks>The image format is chosen depending on the filename extension, see cvLoadImage. Only 8-bit single-channel or 3-channel (with 'BGR' channel order) images can be saved using this function. If the format, depth or channel order is different, use cvCvtScale and cvCvtColor to convert it before saving, or use universal cvSave to save the image to XML or YAML format.</remarks>
        </member>
        <member name="M:Emgu.CV.UMat.Clone">
            <summary>
            Make a clone of the current UMat.
            </summary>
            <returns>A clone of the current UMat.</returns>
        </member>
        <member name="M:Emgu.CV.UMat.Equals(Emgu.CV.UMat)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:Emgu.CV.UMat.CopyTo``1(``0[])">
            <summary>
            Copy data from this Mat to the managed array
            </summary>
            <typeparam name="T">The type of managed data array</typeparam>
            <param name="data">The managed array where data will be copied to.</param>
        </member>
        <member name="M:Emgu.CV.UMat.SetTo``1(``0[])">
            <summary>
            Copy data from managed array to this Mat
            </summary>
            <typeparam name="T">The type of managed data array</typeparam>
            <param name="data">The managed array where data will be copied from</param>
        </member>
        <member name="M:Emgu.CV.UMat.Dot(Emgu.CV.IInputArray)">
            <summary>
            Computes the dot product of two mats
            </summary>
            <param name="mat">The matrix to compute dot product with</param>
            <returns>The dot product</returns>
        </member>
        <member name="M:Emgu.CV.UMat.Row(System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix row.
            </summary>
            <param name="y">A 0-based row index.</param>
            <returns>A matrix header for the specified matrix row.</returns>
        </member>
        <member name="M:Emgu.CV.UMat.Col(System.Int32)">
            <summary>
            Creates a matrix header for the specified matrix column.
            </summary>
            <param name="x">A 0-based column index.</param>
            <returns>A matrix header for the specified matrix column.</returns>
        </member>
        <member name="P:Emgu.CV.UMat.Bytes">
            <summary>
            Get or Set the raw image data
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.Size">
            <summary>
            The size of this matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.Rows">
            <summary>
            The number of rows
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.Cols">
            <summary>
            The number of columns
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.ElementSize">
            <summary>
            The size of the elements in this matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.Bitmap">
            <summary>
            The Get property provide a more efficient way to convert Image&lt;Gray, Byte&gt;, Image&lt;Bgr, Byte&gt; and Image&lt;Bgra, Byte&gt; into Bitmap
            such that the image data is <b>shared</b> with Bitmap. 
            If you change the pixel value on the Bitmap, you change the pixel values on the Image object as well!
            For other types of image this property has the same effect as ToBitmap()
            <b>Take extra caution not to use the Bitmap after the Image object is disposed</b>
            The Set property convert the bitmap to this Image type.
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.IsContinuous">
            <summary>
            True if the data is continues
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.IsSubmatrix">
            <summary>
            True if the matrix is a submatrix of another matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.Depth">
            <summary>
            Depth type
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.IsEmpty">
            <summary>
            True if the matrix is empty
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.NumberOfChannels">
            <summary>
            Number of channels
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.Total">
            <summary>
            The method returns the number of array elements (a number of pixels if the array represents an image)
            </summary>
        </member>
        <member name="P:Emgu.CV.UMat.Dims">
            <summary>
            The matrix dimensionality
            </summary>
        </member>
        <member name="T:Emgu.CV.UMat.Usage">
            <summary>
            Allocation usage.
            </summary>
        </member>
        <member name="F:Emgu.CV.UMat.Usage.Default">
            <summary>
            Default
            </summary>
        </member>
        <member name="F:Emgu.CV.UMat.Usage.AllocateHostMemory">
            <summary>
            Buffer allocation policy is platform and usage specific 
            </summary>
        </member>
        <member name="F:Emgu.CV.UMat.Usage.AllocateDeviceMemory">
            <summary>
            Buffer allocation policy is platform and usage specific 
            </summary>
        </member>
        <member name="F:Emgu.CV.UMat.Usage.AllocateSharedMemory">
            <summary>
            Buffer allocation policy is platform and usage specific 
            It is not equal to: AllocateHostMemory | AllocateDeviceMemory
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.BinaryFileStorage`1">
            <summary>
            A raw data storage
            </summary>
            <typeparam name="T">The type of elements in the storage</typeparam>
        </member>
        <member name="F:Emgu.CV.Util.BinaryFileStorage`1._fileInfo">
            <summary>
            The file info
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.BinaryFileStorage`1.#ctor(System.String)">
            <summary>
            Create a binary File Storage
            </summary>
            <param name="fileName">The file name of the storage</param>
        </member>
        <member name="M:Emgu.CV.Util.BinaryFileStorage`1.#ctor(System.String,System.Int32)">
            <summary>
            Create a binary File Storage
            </summary>
            <param name="fileName">The file name of the storage</param>
            <param name="trunkSize">The data will be read in trunk of this size internally. Can be use to seed up the file read. A good number will be 4096</param>
        </member>
        <member name="M:Emgu.CV.Util.BinaryFileStorage`1.#ctor(System.String,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Create a binary File Storage with the specific data
            </summary>
            <param name="fileName">The file name of the storage, all data in the existing file will be replaced</param>
            <param name="samples">The data which will be stored in the storage</param>
        </member>
        <member name="M:Emgu.CV.Util.BinaryFileStorage`1.Append(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Append the samples to the end of the storage
            </summary>
            <param name="samples">The samples to be appended to the storage</param>
        </member>
        <member name="M:Emgu.CV.Util.BinaryFileStorage`1.Clear">
            <summary>
            Delete all data in the existing storage, if there is any.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.BinaryFileStorage`1.EstimateSize">
            <summary>
            Estimate the number of elements in this storage as the size of the storage divided by the size of the elements
            </summary>
            <returns>An estimation of the number of elements in this storage</returns>
        </member>
        <member name="M:Emgu.CV.Util.BinaryFileStorage`1.Peek">
            <summary>
            Get a copy of the first element in the storage. If the storage is empty, a default value will be returned
            </summary>
            <returns>A copy of the first element in the storage. If the storage is empty, a default value will be returned</returns>
        </member>
        <member name="M:Emgu.CV.Util.BinaryFileStorage`1.GetSubsamples(System.Int32)">
            <summary>
            Get the subsampled data in this storage
            </summary>
            <param name="subsampleRate">The subsample rate</param>
            <returns>The sub-sampled data in this storage</returns>
        </member>
        <member name="M:Emgu.CV.Util.BinaryFileStorage`1.GetEnumerator">
            <summary>
            Get the data in this storage
            </summary>
            <returns>The data in this storage</returns>
        </member>
        <member name="P:Emgu.CV.Util.BinaryFileStorage`1.FileName">
            <summary>
            The file name of the storage
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.CvException">
            <summary>
            The default exception to be thrown when error encounter in Open CV 
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.CvException.#ctor(System.Int32,System.String,System.String,System.String,System.Int32)">
            <summary>
            The default exception to be thrown when error is encountered in Open CV 
            </summary>
            <param name="status">The numeric code for error status</param>
            <param name="funcName">The source file name where error is encountered</param>
            <param name="errMsg">A description of the error</param>
            <param name="fileName">The source file name where error is encountered</param>
            <param name="line">The line number in the souce where error is encountered</param>
        </member>
        <member name="P:Emgu.CV.Util.CvException.Status">
            <summary>
            The numeric code for error status
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.CvException.ErrorStr">
            <summary>
            The corresponding error string for the Status code
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.CvException.FunctionName">
            <summary>
            The name of the function the error is encountered
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.CvException.ErrorMessage">
            <summary>
            A description of the error
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.CvException.FileName">
            <summary>
            The source file name where error is encountered
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.CvException.Line">
            <summary>
            The line number in the souce where error is encountered
            </summary>
        </member>
        <member name="T:Emgu.CV.CvString">
            <summary>
            Wrapper for cv::String. This class support UTF-8 chars.
            </summary>
        </member>
        <member name="M:Emgu.CV.CvString.#ctor(System.String)">
            <summary>
            Create a CvString from System.String
            </summary>
            <param name="s">The System.String object to be converted to CvString</param>
        </member>
        <member name="M:Emgu.CV.CvString.#ctor">
            <summary>
            Create an empty CvString
            </summary>
        </member>
        <member name="M:Emgu.CV.CvString.ToString">
            <summary>
            Get the string representation of the CvString
            </summary>
            <returns>The string representation of the CvString</returns>
        </member>
        <member name="M:Emgu.CV.CvString.DisposeObject">
            <summary>
            Release all the unmanaged resource associated with this object.
            </summary>
        </member>
        <member name="P:Emgu.CV.CvString.Length">
            <summary>
            Gets the length of the string
            </summary>
            <value>
            The length of the string
            </value>
        </member>
        <member name="T:Emgu.CV.Util.CvToolbox">
            <summary>
            Utilities class
            </summary>
        </member>
        <member name="F:Emgu.CV.Util.CvToolbox.GrayscalePalette">
            <summary>
            The ColorPalette of Grayscale for Bitmap Format8bppIndexed
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.CvToolbox.ColorPaletteToLookupTable(System.Drawing.Imaging.ColorPalette,Emgu.CV.Matrix{System.Byte}@,Emgu.CV.Matrix{System.Byte}@,Emgu.CV.Matrix{System.Byte}@,Emgu.CV.Matrix{System.Byte}@)">
            <summary>
            Convert the color palette to four lookup tables
            </summary>
            <param name="palette">The color palette to transform</param>
            <param name="bTable">Lookup table for the B channel</param>
            <param name="gTable">Lookup table for the G channel</param>
            <param name="rTable">Lookup table for the R channel</param>
            <param name="aTable">Lookup table for the A channel</param>
        </member>
        <member name="M:Emgu.CV.Util.CvToolbox.GetMatrixFromArrays``1(``0[][])">
            <summary>
            Convert arrays of data to matrix
            </summary>
            <param name="data">Arrays of data</param>
            <returns>A two dimension matrix that represent the array</returns>
        </member>
        <member name="M:Emgu.CV.Util.CvToolbox.GetMatrixFromPoints(Emgu.CV.Structure.MCvPoint2D64f[][])">
            <summary>
            Convert arrays of points to matrix
            </summary>
            <param name="points">Arrays of points</param>
            <returns>A two dimension matrix that represent the points</returns>
        </member>
        <member name="M:Emgu.CV.Util.CvToolbox.GetMinMax(System.Collections.Generic.IEnumerable{Emgu.CV.Structure.MCvPoint3D64f},Emgu.CV.Structure.MCvPoint3D64f@,Emgu.CV.Structure.MCvPoint3D64f@)">
            <summary>
            Compute the minimum and maximum value from the points
            </summary>
            <param name="points">The points</param>
            <param name="min">The minimum x,y,z values</param>
            <param name="max">The maximum x,y,z values</param>
        </member>
        <member name="M:Emgu.CV.Util.CvToolbox.CopyVector``1(``0[],System.IntPtr,System.Int32)">
            <summary>
            Copy a generic vector to the unmanaged memory
            </summary>
            <typeparam name="TData">The data type of the vector</typeparam>
            <param name="src">The source vector</param>
            <param name="dest">Pointer to the destination unmanaged memory</param>
            <param name="bytesToCopy">Specify the number of bytes to copy. If this is -1, the number of bytes equals the number of bytes in the <paramref name="src"> array</paramref></param>
            <returns>The number of bytes copied</returns>
        </member>
        <member name="M:Emgu.CV.Util.CvToolbox.CopyMatrix``1(``0[][],System.IntPtr)">
            <summary>
            Copy a jagged two dimensional array to the unmanaged memory
            </summary>
            <typeparam name="TData">The data type of the jagged two dimensional</typeparam>
            <param name="source">The source array</param>
            <param name="dest">Pointer to the destination unmanaged memory</param>
        </member>
        <member name="M:Emgu.CV.Util.CvToolbox.CopyMatrix``1(System.IntPtr,``0[][])">
            <summary>
            Copy a jagged two dimensional array from the unmanaged memory
            </summary>
            <typeparam name="D">The data type of the jagged two dimensional</typeparam>
            <param name="src">The src array</param>
            <param name="dest">Pointer to the destination unmanaged memory</param>
        </member>
        <member name="M:Emgu.CV.Util.CvToolbox.Memcpy(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            memcpy function
            </summary>
            <param name="dest">the destination of memory copy</param>
            <param name="src">the source of memory copy</param>
            <param name="len">the number of bytes to be copied</param>
        </member>
        <member name="M:Emgu.CV.Util.CvToolbox.GetColorCvtCode(System.Type,System.Type)">
            <summary>
            Given the source and destination color type, compute the color conversion code for CvInvoke.cvCvtColor function
            </summary>
            <param name="srcColorType">The source color type. Must be a type inherited from IColor</param>
            <param name="destColorType">The dest color type. Must be a type inherited from IColor</param>
            <returns>The color conversion code for CvInvoke.cvCvtColor function</returns>
        </member>
        <member name="T:Emgu.CV.Util.DataLogger">
            <summary>
            A DataLogger for unmanaged code to log data back to managed code, using callback.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.DataLogger.#ctor(System.Int32)">
            <summary>
            Create a MessageLogger and register the callback function
            </summary>
            <param name="logLevel">The log level.</param>
        </member>
        <member name="M:Emgu.CV.Util.DataLogger.Log(System.IntPtr,System.Int32)">
            <summary>
            Log some data
            </summary>
            <param name="data">Pointer to some unmanaged data</param>
            <param name="logLevel">The logLevel. The Log function only logs when the <paramref name="logLevel"/> is greater or equals to the DataLogger's logLevel</param>
        </member>
        <member name="M:Emgu.CV.Util.DataLogger.DisposeObject">
            <summary>
            Release the DataLogger and all the unmanaged memory associated with it.
            </summary>
        </member>
        <member name="E:Emgu.CV.Util.DataLogger.OnDataReceived">
            <summary>
            The event that will be raised when the unmanaged code send over data
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.DataLogger`1">
            <summary>
            A generic version of the DataLogger
            </summary>
            <typeparam name="T">The supported type includes System.String and System.ValueType</typeparam>
        </member>
        <member name="M:Emgu.CV.Util.DataLogger`1.#ctor(System.Int32)">
            <summary>
            Create a new DataLogger
            </summary>
            <param name="logLevel">The log level.</param>
        </member>
        <member name="M:Emgu.CV.Util.DataLogger`1.Log(`0,System.Int32)">
            <summary>
            Log some data
            </summary>
            <param name="data">The data to be logged</param>
            <param name="logLevel">The logLevel. The Log function only logs when the <paramref name="logLevel"/> is greater or equals to the DataLogger's logLevel</param>
        </member>
        <member name="M:Emgu.CV.Util.DataLogger`1.op_Implicit(Emgu.CV.Util.DataLogger{`0})~System.IntPtr">
            <summary>
            Implicit operator for IntPtr
            </summary>
            <param name="obj">The DataLogger</param>
            <returns>The unmanaged pointer for this DataLogger</returns>
        </member>
        <member name="M:Emgu.CV.Util.DataLogger`1.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this DataLogger
            </summary>
        </member>
        <member name="E:Emgu.CV.Util.DataLogger`1.OnDataReceived">
            <summary>
            The event that will be raised when the unmanaged code send over data
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.DataLogger`1.Ptr">
            <summary>
            Pointer to the unmanaged object
            </summary>
        </member>
        <member name="E:Emgu.CV.Util.DataLoggerHelper.OnDataReceived">
            <summary>
            The event that will be raised when the unmanaged code send over data
            </summary>
        </member>
        <member name="T:Emgu.CV.AlgorithmExtensions">
            <summary>
            Extension methods to the IAlgorithm interface
            </summary>
        </member>
        <member name="M:Emgu.CV.AlgorithmExtensions.Read(Emgu.CV.IAlgorithm,Emgu.CV.FileNode)">
            <summary>
            Reads algorithm parameters from a file storage.
            </summary>
            <param name="algorithm">The algorithm.</param>
            <param name="node">The node from file storage.</param>
        </member>
        <member name="M:Emgu.CV.AlgorithmExtensions.Write(Emgu.CV.IAlgorithm,Emgu.CV.FileStorage)">
            <summary>
            Stores algorithm parameters in a file storage
            </summary>
            <param name="algorithm">The algorithm.</param>
            <param name="storage">The storage.</param>
        </member>
        <member name="T:Emgu.CV.IInputArrayExtensions">
            <summary>
            Extension methods for IInputArrays
            </summary>
        </member>
        <member name="M:Emgu.CV.IInputArrayExtensions.IsUmat(Emgu.CV.IInputArray)">
            <summary>
            Determines whether the specified input array is umat.
            </summary>
            <param name="arr">The array</param>
            <returns>True if it is a umat</returns>
        </member>
        <member name="T:Emgu.CV.InputArray">
            <summary>
            This is the proxy class for passing read-only input arrays into OpenCV functions.
            </summary>
            <summary>
            This is the proxy class for passing read-only input arrays into OpenCV functions.
            </summary>
        </member>
        <member name="M:Emgu.CV.InputArray.#ctor(System.IntPtr,System.Object)">
            <summary>
            Create a Input array from an existing unmanaged inputArray pointer
            </summary>
            <param name="inputArrayPtr">The unmanaged pointer the the InputArray</param>
            <param name="parent">The parent object to keep reference to</param>
        </member>
        <member name="M:Emgu.CV.InputArray.GetEmpty">
            <summary>
            Get an empty input array
            </summary>
            <returns>An empty input array</returns>
        </member>
        <member name="M:Emgu.CV.InputArray.GetMat(System.Int32)">
            <summary>
            Get the Mat from the input array
            </summary>
            <param name="idx">The index, in case if this is an VectorOfMat</param>
            <returns>The Mat</returns>
        </member>
        <member name="M:Emgu.CV.InputArray.GetUMat(System.Int32)">
            <summary>
            Get the UMat from the input array
            </summary>
            <param name="idx">The index, in case if this is an VectorOfUMat</param>
            <returns>The UMat</returns>
        </member>
        <member name="M:Emgu.CV.InputArray.GetSize(System.Int32)">
            <summary>
            Get the size of the input array
            </summary>
            <param name="idx">The optional index</param>
            <returns>The size of the input array</returns>
        </member>
        <member name="M:Emgu.CV.InputArray.IsEmpty">
            <summary>
            Return true if the input array is empty
            </summary>
            <returns>True if the input array is empty</returns>
        </member>
        <member name="M:Emgu.CV.InputArray.GetDepth(System.Int32)">
            <summary>
            Get the depth type
            </summary>
            <param name="idx">The optional index</param>
            <returns>The depth type</returns>
        </member>
        <member name="M:Emgu.CV.InputArray.GetDims(System.Int32)">
            <summary>
            Get the number of dimensions
            </summary>
            <param name="i">The optional index</param>
            <returns>The dimensions</returns>
        </member>
        <member name="M:Emgu.CV.InputArray.GetChannels(System.Int32)">
            <summary>
            Get the number of channels
            </summary>
            <param name="idx">The optional index</param>
            <returns>The number of channels</returns>
        </member>
        <member name="M:Emgu.CV.InputArray.CopyTo(Emgu.CV.IOutputArray,Emgu.CV.IInputArray)">
            <summary>
            Copy this Input array to another.
            </summary>
            <param name="arr">The destination array.</param>
            <param name="mask">The optional mask.</param>
        </member>
        <member name="M:Emgu.CV.InputArray.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.InputArray.GetGpuMat">
            <summary>
            Get the GpuMat from the input array
            </summary>
            <returns>The GpuMat</returns>
        </member>
        <member name="P:Emgu.CV.InputArray.IsMat">
            <summary>
            True if the input array is a Mat
            </summary>
        </member>
        <member name="P:Emgu.CV.InputArray.IsUMat">
            <summary>
            True if the input array is an UMat
            </summary>
        </member>
        <member name="P:Emgu.CV.InputArray.IsMatVector">
            <summary>
            True if the input array is a vector of Mat
            </summary>
        </member>
        <member name="P:Emgu.CV.InputArray.IsUMatVector">
            <summary>
            True if the input array is a vector of UMat
            </summary>
        </member>
        <member name="P:Emgu.CV.InputArray.IsMatx">
            <summary>
            True if the input array is a Matx
            </summary>
        </member>
        <member name="P:Emgu.CV.InputArray.Kind">
            <summary>
            The type of the input array
            </summary>
        </member>
        <member name="T:Emgu.CV.InputArray.Type">
            <summary>
            Input array type
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.KindShift">
            <summary>
            kind shift
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.FixedType">
            <summary>
            Fixed type
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.FixedSize">
            <summary>
            Fixed size
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.KindMask">
            <summary>
            Kind mask
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.Mat">
            <summary>
            Mat
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.Matx">
            <summary>
            Matx
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.StdVector">
            <summary>
            StdVector
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.StdVectorVector">
            <summary>
            StdVectorVector
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.StdVectorMat">
            <summary>
            StdVectorMat
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.Expr">
            <summary>
            Expr
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.OpenglBuffer">
            <summary>
            Opengl buffer
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.CudaHostMem">
            <summary>
            Cuda Host Mem
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.CudaGpuMat">
            <summary>
            Cuda GpuMat
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.UMat">
            <summary>
            UMat
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.StdVectorUMat">
            <summary>
            StdVectorUMat
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.StdBoolVector">
            <summary>
            StdBoolVector
            </summary>
        </member>
        <member name="F:Emgu.CV.InputArray.Type.StdVectorCudaGpuMat">
            <summary>
            StdVectorCudaGpuMat
            </summary>
        </member>
        <member name="T:Emgu.CV.InputOutputArray">
            <summary>
            This type is very similar to InputArray except that it is used for input/output function parameters.
            </summary>
        </member>
        <member name="T:Emgu.CV.OutputArray">
            <summary>
            This type is very similar to InputArray except that it is used for output function parameters. 
            </summary>
        </member>
        <member name="M:Emgu.CV.OutputArray.#ctor(System.IntPtr,System.Object)">
            <summary>
            Create an OutputArray from an existing unmanaged outputArray pointer
            </summary>
            <param name="outputArrayPtr">The pointer to the unmanaged outputArray</param>
            <param name="parent">The parent object to keep reference to</param>
        </member>
        <member name="M:Emgu.CV.OutputArray.GetEmpty">
            <summary>
            Get an empty output array
            </summary>
            <returns>An empty output array</returns>
        </member>
        <member name="M:Emgu.CV.OutputArray.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this output array.
            </summary>
        </member>
        <member name="P:Emgu.CV.OutputArray.FixedSize">
            <summary>
            True if the output array is fixed size
            </summary>
        </member>
        <member name="P:Emgu.CV.OutputArray.FixedType">
            <summary>
            True if the output array is fixed type
            </summary>
        </member>
        <member name="P:Emgu.CV.OutputArray.Needed">
            <summary>
            True if the output array is needed
            </summary>
        </member>
        <member name="M:Emgu.CV.InputOutputArray.#ctor(System.IntPtr,System.Object)">
            <summary>
            Create an InputOutputArray from an existing unmanaged inputOutputArray pointer
            </summary>
            <param name="inputOutputArrayPtr">The pointer to the existing inputOutputArray</param>
            <param name="parent">The parent object to keep reference to</param>
        </member>
        <member name="M:Emgu.CV.InputOutputArray.GetEmpty">
            <summary>
            Get an empty InputOutputArray
            </summary>
            <returns>An empty InputOutputArray</returns>
        </member>
        <member name="M:Emgu.CV.InputOutputArray.DisposeObject">
            <summary>
            Release all the memory associated with this InputOutputArry
            </summary>
        </member>
        <member name="T:Emgu.CV.ScalarArray">
            <summary>
            An implementation of IInputArray intented to convert data to IInputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.ScalarArray.#ctor(Emgu.CV.Structure.MCvScalar)">
            <summary>
            Create an InputArray from MCvScalar
            </summary>
            <param name="scalar">The MCvScalar to be converted to InputArray</param>
        </member>
        <member name="M:Emgu.CV.ScalarArray.#ctor(System.Double)">
            <summary>
            Create an InputArray from a double value
            </summary>
            <param name="scalar">The double value to be converted to InputArray</param>
        </member>
        <member name="M:Emgu.CV.ScalarArray.op_Explicit(System.Double)~Emgu.CV.ScalarArray">
            <summary>
            Convert double scalar to InputArray
            </summary>
            <param name="scalar">The double scalar</param>
            <returns>The InputArray</returns>
        </member>
        <member name="M:Emgu.CV.ScalarArray.op_Explicit(Emgu.CV.Structure.MCvScalar)~Emgu.CV.ScalarArray">
            <summary>
            Convert MCvSalar to InputArray
            </summary>
            <param name="scalar">The MCvScalar</param>
            <returns>The InputArray</returns>
        </member>
        <member name="M:Emgu.CV.ScalarArray.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.ScalarArray.GetInputArray">
            <summary>
            The pointer to the input array
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.StructSize">
            <summary>
            Cache the size of various header in bytes
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.StructSize.PointF">
            <summary>
            The size of PointF
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.StructSize.RangF">
            <summary>
            The size of RangF
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.StructSize.MCvPoint2D64f">
            <summary>
            The size of PointF
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.StructSize.MCvMat">
            <summary>
            The size of MCvMat
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.StructSize.MIplImage">
            <summary>
            The size of IplImage
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.StructSize.MCvPoint3D32f">
            <summary>
            The size of MCvPoint3D32f
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.StructSize.MCvMatND">
            <summary>
            The size of MCvMatND
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.TbbTaskScheduler">
            <summary>
            This class canbe used to initiate TBB. Only usefull if it is compiled with TBB support
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.TbbTaskScheduler.#ctor">
            <summary>
            Initialize the TBB task scheduler
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.TbbTaskScheduler.DisposeObject">
            <summary>
            Release the TBB task scheduler
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfByte">
            <summary>
            Wrapped class of the C++ standard vector of Byte.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.#ctor">
            <summary>
            Create an empty standard vector of Byte
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.#ctor(System.Int32)">
            <summary>
            Create an standard vector of Byte of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.#ctor(System.Byte[])">
            <summary>
            Create an standard vector of Byte with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.Push(System.Byte[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.Push(Emgu.CV.Util.VectorOfByte)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.ToArray">
            <summary>
            Convert the standard vector to an array of Byte
            </summary>
            <returns>An array of Byte</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfByte.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfByte.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfByte.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfByte.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfByte.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfColorPoint">
            <summary>
            Wrapped class of the C++ standard vector of ColorPoint.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.#ctor">
            <summary>
            Create an empty standard vector of ColorPoint
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.#ctor(System.Int32)">
            <summary>
            Create an standard vector of ColorPoint of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.#ctor(Emgu.CV.Structure.ColorPoint[])">
            <summary>
            Create an standard vector of ColorPoint with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.Push(Emgu.CV.Structure.ColorPoint[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.Push(Emgu.CV.Util.VectorOfColorPoint)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.ToArray">
            <summary>
            Convert the standard vector to an array of ColorPoint
            </summary>
            <returns>An array of ColorPoint</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfColorPoint.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfColorPoint.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfColorPoint.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfColorPoint.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfColorPoint.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfCvString">
            <summary>
            Wrapped class of the C++ standard vector of CvString.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.#ctor">
            <summary>
            Create an empty standard vector of CvString
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.#ctor(System.Int32)">
            <summary>
            Create an standard vector of CvString of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.#ctor(Emgu.CV.CvString[])">
            <summary>
            Create an standard vector of CvString with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.Push(Emgu.CV.CvString)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.Push(Emgu.CV.CvString[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.Push(Emgu.CV.Util.VectorOfCvString)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfCvString.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfCvString.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfCvString.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfCvString.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfDMatch">
            <summary>
            Wrapped class of the C++ standard vector of DMatch.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.#ctor">
            <summary>
            Create an empty standard vector of DMatch
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.#ctor(System.Int32)">
            <summary>
            Create an standard vector of DMatch of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.#ctor(Emgu.CV.Structure.MDMatch[])">
            <summary>
            Create an standard vector of DMatch with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.Push(Emgu.CV.Structure.MDMatch[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.Push(Emgu.CV.Util.VectorOfDMatch)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.ToArray">
            <summary>
            Convert the standard vector to an array of DMatch
            </summary>
            <returns>An array of DMatch</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDMatch.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfDMatch.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfDMatch.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfDMatch.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfDMatch.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfDouble">
            <summary>
            Wrapped class of the C++ standard vector of Double.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.#ctor">
            <summary>
            Create an empty standard vector of Double
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.#ctor(System.Int32)">
            <summary>
            Create an standard vector of Double of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.#ctor(System.Double[])">
            <summary>
            Create an standard vector of Double with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.Push(System.Double[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.Push(Emgu.CV.Util.VectorOfDouble)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.ToArray">
            <summary>
            Convert the standard vector to an array of Double
            </summary>
            <returns>An array of Double</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfDouble.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfDouble.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfDouble.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfDouble.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfDouble.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfFloat">
            <summary>
            Wrapped class of the C++ standard vector of Float.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.#ctor">
            <summary>
            Create an empty standard vector of Float
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.#ctor(System.Int32)">
            <summary>
            Create an standard vector of Float of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.#ctor(System.Single[])">
            <summary>
            Create an standard vector of Float with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.Push(System.Single[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.Push(Emgu.CV.Util.VectorOfFloat)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.ToArray">
            <summary>
            Convert the standard vector to an array of Float
            </summary>
            <returns>An array of Float</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfFloat.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfFloat.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfFloat.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfFloat.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfFloat.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfInt">
            <summary>
            Wrapped class of the C++ standard vector of Int.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.#ctor">
            <summary>
            Create an empty standard vector of Int
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.#ctor(System.Int32)">
            <summary>
            Create an standard vector of Int of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.#ctor(System.Int32[])">
            <summary>
            Create an standard vector of Int with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.Push(System.Int32[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.Push(Emgu.CV.Util.VectorOfInt)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.ToArray">
            <summary>
            Convert the standard vector to an array of Int
            </summary>
            <returns>An array of Int</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfInt.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfInt.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfInt.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfInt.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfInt.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfKeyPoint">
            <summary>
            Wrapped class of the C++ standard vector of KeyPoint.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.#ctor">
            <summary>
            Create an empty standard vector of KeyPoint
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.#ctor(System.Int32)">
            <summary>
            Create an standard vector of KeyPoint of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.#ctor(Emgu.CV.Structure.MKeyPoint[])">
            <summary>
            Create an standard vector of KeyPoint with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.Push(Emgu.CV.Structure.MKeyPoint[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.Push(Emgu.CV.Util.VectorOfKeyPoint)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.ToArray">
            <summary>
            Convert the standard vector to an array of KeyPoint
            </summary>
            <returns>An array of KeyPoint</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.FilterByImageBorder(System.Drawing.Size,System.Int32)">
            <summary>
            Remove keypoints within borderPixels of an image edge.
            </summary>
            <param name="imageSize">Image size</param>
            <param name="borderSize">Border size in pixel</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.FilterByKeypointSize(System.Single,System.Single)">
            <summary>
            Remove keypoints of sizes out of range.
            </summary>
            <param name="minSize">Minimum size</param>
            <param name="maxSize">Maximum size</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfKeyPoint.FilterByPixelsMask(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Remove keypoints from some image by mask for pixels of this image.
            </summary>
            <param name="mask">The mask</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfKeyPoint.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfKeyPoint.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfKeyPoint.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfKeyPoint.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfMat">
            <summary>
            Wrapped class of the C++ standard vector of Mat.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.#ctor">
            <summary>
            Create an empty standard vector of Mat
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.#ctor(System.Int32)">
            <summary>
            Create an standard vector of Mat of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.#ctor(Emgu.CV.Mat[])">
            <summary>
            Create an standard vector of Mat with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.Push(Emgu.CV.Mat)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.Push(Emgu.CV.Mat[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.Push(Emgu.CV.Util.VectorOfMat)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.Push``1(Emgu.CV.CvArray{``0})">
            <summary>
            Convert a CvArray to cv::Mat and push it into the vector
            </summary>
            <typeparam name="TDepth">The type of depth of the cvArray</typeparam>
            <param name="cvArray">The cvArray to be pushed into the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfMat.Push``1(Emgu.CV.CvArray{``0}[])">
            <summary>
            Convert a group of CvArray to cv::Mat and push them into the vector
            </summary>
            <typeparam name="TDepth">The type of depth of the cvArray</typeparam>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfMat.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfMat.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfMat.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfOclPlatformInfo">
            <summary>
            Wrapped class of the C++ standard vector of OclPlatformInfo.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.#ctor">
            <summary>
            Create an empty standard vector of OclPlatformInfo
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.#ctor(System.Int32)">
            <summary>
            Create an standard vector of OclPlatformInfo of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.#ctor(Emgu.CV.Ocl.PlatformInfo[])">
            <summary>
            Create an standard vector of OclPlatformInfo with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.Push(Emgu.CV.Ocl.PlatformInfo)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.Push(Emgu.CV.Ocl.PlatformInfo[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.Push(Emgu.CV.Util.VectorOfOclPlatformInfo)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfOclPlatformInfo.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfOclPlatformInfo.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfOclPlatformInfo.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfOclPlatformInfo.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfPoint">
            <summary>
            Wrapped class of the C++ standard vector of Point.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.#ctor">
            <summary>
            Create an empty standard vector of Point
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.#ctor(System.Int32)">
            <summary>
            Create an standard vector of Point of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.#ctor(System.Drawing.Point[])">
            <summary>
            Create an standard vector of Point with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.Push(System.Drawing.Point[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.Push(Emgu.CV.Util.VectorOfPoint)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.ToArray">
            <summary>
            Convert the standard vector to an array of Point
            </summary>
            <returns>An array of Point</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPoint.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPoint.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPoint.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPoint.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfPoint3D32F">
            <summary>
            Wrapped class of the C++ standard vector of Point3D32F.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.#ctor">
            <summary>
            Create an empty standard vector of Point3D32F
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.#ctor(System.Int32)">
            <summary>
            Create an standard vector of Point3D32F of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.#ctor(Emgu.CV.Structure.MCvPoint3D32f[])">
            <summary>
            Create an standard vector of Point3D32F with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.Push(Emgu.CV.Structure.MCvPoint3D32f[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.Push(Emgu.CV.Util.VectorOfPoint3D32F)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.ToArray">
            <summary>
            Convert the standard vector to an array of Point3D32F
            </summary>
            <returns>An array of Point3D32F</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPoint3D32F.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPoint3D32F.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPoint3D32F.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPoint3D32F.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPoint3D32F.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfPointF">
            <summary>
            Wrapped class of the C++ standard vector of PointF.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.#ctor">
            <summary>
            Create an empty standard vector of PointF
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.#ctor(System.Int32)">
            <summary>
            Create an standard vector of PointF of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.#ctor(System.Drawing.PointF[])">
            <summary>
            Create an standard vector of PointF with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.Push(System.Drawing.PointF[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.Push(Emgu.CV.Util.VectorOfPointF)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.ToArray">
            <summary>
            Convert the standard vector to an array of PointF
            </summary>
            <returns>An array of PointF</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfPointF.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPointF.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPointF.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPointF.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfPointF.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfRect">
            <summary>
            Wrapped class of the C++ standard vector of Rect.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.#ctor">
            <summary>
            Create an empty standard vector of Rect
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.#ctor(System.Int32)">
            <summary>
            Create an standard vector of Rect of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.#ctor(System.Drawing.Rectangle[])">
            <summary>
            Create an standard vector of Rect with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.Push(System.Drawing.Rectangle[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.Push(Emgu.CV.Util.VectorOfRect)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.ToArray">
            <summary>
            Convert the standard vector to an array of Rect
            </summary>
            <returns>An array of Rect</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfRect.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfRect.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfRect.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfRect.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfRect.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfTriangle2DF">
            <summary>
            Wrapped class of the C++ standard vector of Triangle2DF.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.#ctor">
            <summary>
            Create an empty standard vector of Triangle2DF
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.#ctor(System.Int32)">
            <summary>
            Create an standard vector of Triangle2DF of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.#ctor(Emgu.CV.Structure.Triangle2DF[])">
            <summary>
            Create an standard vector of Triangle2DF with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.Push(Emgu.CV.Structure.Triangle2DF[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.Push(Emgu.CV.Util.VectorOfTriangle2DF)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.ToArray">
            <summary>
            Convert the standard vector to an array of Triangle2DF
            </summary>
            <returns>An array of Triangle2DF</returns>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfTriangle2DF.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfTriangle2DF.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfTriangle2DF.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfTriangle2DF.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfTriangle2DF.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfUMat">
            <summary>
            Wrapped class of the C++ standard vector of UMat.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.#ctor">
            <summary>
            Create an empty standard vector of UMat
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.#ctor(System.Int32)">
            <summary>
            Create an standard vector of UMat of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.#ctor(Emgu.CV.UMat[])">
            <summary>
            Create an standard vector of UMat with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.Push(Emgu.CV.UMat)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.Push(Emgu.CV.UMat[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.Push(Emgu.CV.Util.VectorOfUMat)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfUMat.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfUMat.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfUMat.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfUMat.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfVectorOfDMatch">
            <summary>
            Wrapped class of the C++ standard vector of VectorOfDMatch.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.#ctor">
            <summary>
            Create an empty standard vector of VectorOfDMatch
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.#ctor(System.Int32)">
            <summary>
            Create an standard vector of VectorOfDMatch of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.#ctor(Emgu.CV.Util.VectorOfDMatch[])">
            <summary>
            Create an standard vector of VectorOfDMatch with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.Push(Emgu.CV.Util.VectorOfDMatch)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.Push(Emgu.CV.Util.VectorOfDMatch[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.Push(Emgu.CV.Util.VectorOfVectorOfDMatch)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.#ctor(Emgu.CV.Structure.MDMatch[][])">
            <summary>
            Create the standard vector of VectorOfDMatch 
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfDMatch.ToArrayOfArray">
            <summary>
            Convert the standard vector to arrays of int
            </summary>
            <returns>Arrays of int</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfDMatch.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfDMatch.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfDMatch.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfVectorOfInt">
            <summary>
            Wrapped class of the C++ standard vector of VectorOfInt.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.#ctor">
            <summary>
            Create an empty standard vector of VectorOfInt
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.#ctor(System.Int32)">
            <summary>
            Create an standard vector of VectorOfInt of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.#ctor(Emgu.CV.Util.VectorOfInt[])">
            <summary>
            Create an standard vector of VectorOfInt with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.Push(Emgu.CV.Util.VectorOfInt)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.Push(Emgu.CV.Util.VectorOfInt[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.Push(Emgu.CV.Util.VectorOfVectorOfInt)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.#ctor(System.Int32[][])">
            <summary>
            Create the standard vector of VectorOfInt 
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfInt.ToArrayOfArray">
            <summary>
            Convert the standard vector to arrays of int
            </summary>
            <returns>Arrays of int</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfInt.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfInt.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfInt.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfVectorOfPoint">
            <summary>
            Wrapped class of the C++ standard vector of VectorOfPoint.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.#ctor">
            <summary>
            Create an empty standard vector of VectorOfPoint
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.#ctor(System.Int32)">
            <summary>
            Create an standard vector of VectorOfPoint of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.#ctor(Emgu.CV.Util.VectorOfPoint[])">
            <summary>
            Create an standard vector of VectorOfPoint with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.Push(Emgu.CV.Util.VectorOfPoint)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.Push(Emgu.CV.Util.VectorOfPoint[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.Push(Emgu.CV.Util.VectorOfVectorOfPoint)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.#ctor(System.Drawing.Point[][])">
            <summary>
            Create the standard vector of VectorOfPoint 
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint.ToArrayOfArray">
            <summary>
            Convert the standard vector to arrays of int
            </summary>
            <returns>Arrays of int</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPoint.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPoint.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPoint.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfVectorOfPoint3D32F">
            <summary>
            Wrapped class of the C++ standard vector of VectorOfPoint3D32F.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.#ctor">
            <summary>
            Create an empty standard vector of VectorOfPoint3D32F
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.#ctor(System.Int32)">
            <summary>
            Create an standard vector of VectorOfPoint3D32F of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.#ctor(Emgu.CV.Util.VectorOfPoint3D32F[])">
            <summary>
            Create an standard vector of VectorOfPoint3D32F with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.Push(Emgu.CV.Util.VectorOfPoint3D32F)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.Push(Emgu.CV.Util.VectorOfPoint3D32F[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.Push(Emgu.CV.Util.VectorOfVectorOfPoint3D32F)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.#ctor(Emgu.CV.Structure.MCvPoint3D32f[][])">
            <summary>
            Create the standard vector of VectorOfPoint3D32F 
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.ToArrayOfArray">
            <summary>
            Convert the standard vector to arrays of int
            </summary>
            <returns>Arrays of int</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPoint3D32F.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.VectorOfVectorOfPointF">
            <summary>
            Wrapped class of the C++ standard vector of VectorOfPointF.
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.#ctor">
            <summary>
            Create an empty standard vector of VectorOfPointF
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.#ctor(System.Int32)">
            <summary>
            Create an standard vector of VectorOfPointF of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.#ctor(Emgu.CV.Util.VectorOfPointF[])">
            <summary>
            Create an standard vector of VectorOfPointF with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.Push(Emgu.CV.Util.VectorOfPointF)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.Push(Emgu.CV.Util.VectorOfPointF[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.Push(Emgu.CV.Util.VectorOfVectorOfPointF)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.#ctor(System.Drawing.PointF[][])">
            <summary>
            Create the standard vector of VectorOfPointF 
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.VectorOfVectorOfPointF.ToArrayOfArray">
            <summary>
            Convert the standard vector to arrays of int
            </summary>
            <returns>Arrays of int</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPointF.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPointF.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.Util.VectorOfVectorOfPointF.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Util.ZlibCompression">
            <summary>
            Use zlib included in OpenCV to perform in-memory binary compression and decompression
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.ZlibCompression.Compress(System.Byte[],System.Int32)">
            <summary>
            Compress the data using the specific compression level
            </summary>
            <param name="original">The data to be compressed</param>
            <param name="compressionLevel">The compression level, 0-9 where 0 mean no compression at all</param>
            <returns>The compressed bytes</returns>
        </member>
        <member name="M:Emgu.CV.Util.ZlibCompression.Uncompress(System.Byte[],System.Int32)">
            <summary>
            Uncompress the data 
            </summary>
            <param name="compressedData">The compressed data</param>
            <param name="estimatedUncompressedSize">The estimated size fo the uncompress data. Must be large enough to hold the decompressed data.</param>
            <returns>The decompressed data</returns>
        </member>
        <member name="T:Emgu.CV.DenseOpticalFlowExtensions">
            <summary>
            Extension methods for IDenseOpticalFlow
            </summary>
        </member>
        <member name="M:Emgu.CV.DenseOpticalFlowExtensions.Calc(Emgu.CV.IDenseOpticalFlow,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray)">
            <summary>
            Calculates an optical flow.
            </summary>
            <param name="i0">First 8-bit single-channel input image.</param>
            <param name="i1">Second input image of the same size and the same type as prev.</param>
            <param name="flow">Computed flow image that has the same size as prev and type CV_32FC2 </param>
            <param name="opticalFlow">The dense optical flow object</param>
        </member>
        <member name="T:Emgu.CV.DualTVL1OpticalFlow">
            <summary>
            Dual TV L1 Optical Flow Algorithm.
            </summary>
        </member>
        <member name="M:Emgu.CV.DualTVL1OpticalFlow.#ctor">
            <summary>
            Create Dual TV L1 Optical Flow.
            </summary>
        </member>
        <member name="M:Emgu.CV.DualTVL1OpticalFlow.DisposeObject">
            <summary>
            Release the unmanaged resources
            </summary>
        </member>
        <member name="P:Emgu.CV.DualTVL1OpticalFlow.DenseOpticalFlowPtr">
            <summary>
            Gets the dense optical flow pointer.
            </summary>
            <value>
            The pointer to the dense optical flow object.
            </value>
        </member>
        <member name="P:Emgu.CV.DualTVL1OpticalFlow.AlgorithmPtr">
            <summary>
            Return the pointer to the algorithm object
            </summary>
        </member>
        <member name="P:Emgu.CV.DualTVL1OpticalFlow.Tau">
            <summary>
            Time step of the numerical scheme
            </summary>
        </member>
        <member name="P:Emgu.CV.DualTVL1OpticalFlow.Lambda">
            <summary>
            Weight parameter for the data term, attachment parameter
            </summary>
        </member>
        <member name="P:Emgu.CV.DualTVL1OpticalFlow.Theta">
            <summary>
            Weight parameter for (u - v)^2, tightness parameter
            </summary>
        </member>
        <member name="P:Emgu.CV.DualTVL1OpticalFlow.Gamma">
            <summary>
            Coefficient for additional illumination variation term
            </summary>
        </member>
        <member name="P:Emgu.CV.DualTVL1OpticalFlow.ScalesNumber">
            <summary>
            Number of scales used to create the pyramid of images
            </summary>
        </member>
        <member name="P:Emgu.CV.DualTVL1OpticalFlow.WarpingsNumber">
            <summary>
            Number of warpings per scale
            </summary>
        </member>
        <member name="P:Emgu.CV.DualTVL1OpticalFlow.Epsilon">
            <summary>
            Stopping criterion threshold used in the numerical scheme, which is a trade-off between precision and running time
            </summary>
        </member>
        <member name="P:Emgu.CV.DualTVL1OpticalFlow.InnerIterations">
            <summary>
            Inner iterations (between outlier filtering) used in the numerical scheme
            </summary>
        </member>
        <member name="P:Emgu.CV.DualTVL1OpticalFlow.OuterIterations">
            <summary>
            Outer iterations (number of inner loops) used in the numerical scheme
            </summary>
        </member>
        <member name="P:Emgu.CV.DualTVL1OpticalFlow.UseInitialFlow">
            <summary>
            Use initial flow
            </summary>
        </member>
        <member name="P:Emgu.CV.DualTVL1OpticalFlow.ScaleStep">
            <summary>
            Step between scales (less than 1)
            </summary>
        </member>
        <member name="P:Emgu.CV.DualTVL1OpticalFlow.MedianFiltering">
            <summary>
            Median filter kernel size (1 = no filter) (3 or 5)
            </summary>
        </member>
        <member name="T:Emgu.CV.KalmanFilter">
            <summary>
            The class implements a standard Kalman filter. However, you can modify transitionMatrix, controlMatrix, and measurementMatrix to get
            an extended Kalman filter functionality.
            </summary>
        </member>
        <member name="M:Emgu.CV.KalmanFilter.#ctor(System.Int32,System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Initializes a new instance of the <see cref="T:Emgu.CV.KalmanFilter"/> class.
            </summary>
            <param name="dynamParams">Dimensionality of the state.</param>
            <param name="measureParams">Dimensionality of the measurement.</param>
            <param name="controlParams">Dimensionality of the control vector.</param>
            <param name="type">Type of the created matrices that should be Cv32F or Cv64F</param>
        </member>
        <member name="M:Emgu.CV.KalmanFilter.Predict(Emgu.CV.Mat)">
            <summary>
            Perform the predict operation using the option control input
            </summary>
            <param name="control">The control.</param>
            <returns>The predicted state. </returns>
        </member>
        <member name="M:Emgu.CV.KalmanFilter.Correct(Emgu.CV.Mat)">
            <summary>
            Updates the predicted state from the measurement.
            </summary>
            <param name="measurement">The measured system parameters</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.KalmanFilter.DisposeObject">
            <summary>
            Release the unmanaged resources
            </summary>
        </member>
        <member name="P:Emgu.CV.KalmanFilter.StatePre">
            <summary>
            Predicted state (x'(k)): x(k)=A*x(k-1)+B*u(k)
            </summary>
        </member>
        <member name="P:Emgu.CV.KalmanFilter.StatePost">
            <summary>
            Corrected state (x(k)): x(k)=x'(k)+K(k)*(z(k)-H*x'(k))
            </summary>
        </member>
        <member name="P:Emgu.CV.KalmanFilter.TransitionMatrix">
            <summary>
            State transition matrix (A)
            </summary>
        </member>
        <member name="P:Emgu.CV.KalmanFilter.ControlMatrix">
            <summary>
            Control matrix (B) (not used if there is no control)
            </summary>
        </member>
        <member name="P:Emgu.CV.KalmanFilter.MeasurementMatrix">
            <summary>
            Measurement matrix (H)
            </summary>
        </member>
        <member name="P:Emgu.CV.KalmanFilter.ProcessNoiseCov">
            <summary>
            Process noise covariance matrix (Q)
            </summary>
        </member>
        <member name="P:Emgu.CV.KalmanFilter.MeasurementNoiseCov">
            <summary>
            Measurement noise covariance matrix (R)
            </summary>
        </member>
        <member name="P:Emgu.CV.KalmanFilter.ErrorCovPre">
            <summary>
            priori error estimate covariance matrix (P'(k)): P'(k)=A*P(k-1)*At + Q)
            </summary>
        </member>
        <member name="P:Emgu.CV.KalmanFilter.Gain">
            <summary>
            Kalman gain matrix (K(k)): K(k)=P'(k)*Ht*inv(H*P'(k)*Ht+R)
            </summary>
        </member>
        <member name="P:Emgu.CV.KalmanFilter.ErrorCovPost">
            <summary>
            posteriori error estimate covariance matrix (P(k)): P(k)=(I-K(k)*H)*P'(k)
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoSurveillance.BackgroundSubtractor">
            <summary>
            An abstract class that can be use the perform background / foreground detection.
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BackgroundSubtractor.Apply(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double)">
            <summary>
            Update the background model
            </summary>
            <param name="image">The image that is used to update the background model</param>
            <param name="learningRate">Use -1 for default</param>
            <param name="fgMask">The output foreground mask</param>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BackgroundSubtractor.GetBackgroundImage(Emgu.CV.IOutputArray)">
            <summary>
            Computes a background image.
            </summary>
            <param name="backgroundImage">The output background image</param>
            <remarks> Sometimes the background image can be very blurry, as it contain the average background statistics.</remarks>
        </member>
        <member name="T:Emgu.CV.VideoSurveillance.BackgroundSubtractorKNN">
            <summary>
            K-nearest neighbors - based Background/Foreground Segmentation Algorithm.
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BackgroundSubtractorKNN.#ctor(System.Int32,System.Double,System.Boolean)">
            <summary>
            Create a K-nearest neighbors - based Background/Foreground Segmentation Algorithm.
            </summary>
            <param name="history">Length of the history.</param>
            <param name="dist2Threshold">Threshold on the squared distance between the pixel and the sample to decide whether a pixel is close to that sample. This parameter does not affect the background update.</param>
            <param name="detectShadows">If true, the algorithm will detect shadows and mark them. It decreases the speed a bit, so if you do not need this feature, set the parameter to false.</param>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BackgroundSubtractorKNN.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this background model.
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoSurveillance.BackgroundSubtractorMOG2">
            <summary>
            The class implements the following algorithm:
            "Improved adaptive Gaussian mixture model for background subtraction"
            Z.Zivkovic
            International Conference Pattern Recognition, UK, August, 2004.
            http://www.zoranz.net/Publications/zivkovic2004ICPR.pdf
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BackgroundSubtractorMOG2.#ctor(System.Int32,System.Single,System.Boolean)">
            <summary>
            Create an "Improved adaptive Gaussian mixture model for background subtraction".
            </summary>
            <param name="history">The length of the history.</param>
            <param name="varThreshold">The maximum allowed number of mixture components. Actual number is determined dynamically per pixel.</param>
            <param name="shadowDetection">If true, the algorithm will detect shadows and mark them. It decreases the speed a bit, so if you do not need this feature, set the parameter to false.</param>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BackgroundSubtractorMOG2.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this background model.
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoWriter">
            <summary>
            Create a video writer that write images to video format
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoWriter.#ctor(System.String,System.Int32,System.Drawing.Size,System.Boolean)">
            <summary>
            Create a video writer using the specific information.
            On windows, it will open a codec selection dialog.
            On linux, it will use the default codec for the specified filename
            </summary>
            <param name="fileName">The name of the video file to be written to </param>
            <param name="fps">frame rate per second</param>
            <param name="size">the size of the frame</param>
            <param name="isColor">true if this is a color video, false otherwise</param>
        </member>
        <member name="M:Emgu.CV.VideoWriter.#ctor(System.String,System.Int32,System.Double,System.Drawing.Size,System.Boolean)">
            <summary>
            Create a video writer using the specific information
            </summary>
            <param name="fileName">The name of the video file to be written to </param>
            <param name="compressionCode">Compression code. Usually computed using CvInvoke.CV_FOURCC. 
            On windows use -1 to open a codec selection dialog.
            On Linux, use CvInvoke.CV_FOURCC('I', 'Y', 'U', 'V') for default codec for the specific file name.
            </param>
            <param name="fps">frame rate per second</param>
            <param name="size">the size of the frame</param>
            <param name="isColor">true if this is a color video, false otherwise</param>
        </member>
        <member name="M:Emgu.CV.VideoWriter.Write(Emgu.CV.Mat)">
            <summary>
            Write a single frame to the video writer
            </summary>
            <param name="frame">The frame to be written to the video writer</param>
        </member>
        <member name="M:Emgu.CV.VideoWriter.Fourcc(System.Char,System.Char,System.Char,System.Char)">
            <summary>
            Generate 4-character code of codec used to compress the frames. For example, CV_FOURCC('P','I','M','1') is MPEG-1 codec, CV_FOURCC('M','J','P','G') is motion-jpeg codec etc.
            </summary>
            <param name="c1">C1</param>
            <param name="c2">C2</param>
            <param name="c3">C3</param>
            <param name="c4">C4</param>
            <returns>The integer value calculated from the four cc code</returns>
        </member>
        <member name="M:Emgu.CV.VideoWriter.DisposeObject">
            <summary>
            Release the video writer and all the memory associate with it
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoWriter.Set(Emgu.CV.VideoWriter.WriterProperty,System.Double)">
            <summary>
            Sets a property in the VideoWriter.
            </summary>
            <param name="prop">Property identifier</param>
            <param name="value">Value of the property.</param>
            <returns>The value of the specific property</returns>
        </member>
        <member name="M:Emgu.CV.VideoWriter.Get(Emgu.CV.VideoWriter.WriterProperty)">
            <summary>
            Returns the specified VideoWriter property.
            </summary>
            <param name="prop">Property identifier.</param>
            <returns></returns>
        </member>
        <member name="P:Emgu.CV.VideoWriter.IsOpened">
            <summary>
            Returns true if video writer has been successfully initialized.
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoWriter.WriterProperty">
            <summary>
            The VideoWriter property
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoWriter.WriterProperty.Quality">
            <summary>
            Current quality (0..100%) of the encoded videostream. Can be adjusted dynamically in some codecs.
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoWriter.WriterProperty.Framebytes">
            <summary>
            (Read-only): Size of just encoded video frame. Note that the encoding order may be different from representation order.
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoWriter.WriterProperty.NStripes">
            <summary>
            Number of stripes for parallel encoding. -1 for auto detection.
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoStab.CaptureFrameSource">
            <summary>
            Use the Capture class as a FrameSource
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoStab.FrameSource">
            <summary>
            A FrameSource that can be used by the Video Stabilizer
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoStab.FrameSource.FrameSourcePtr">
            <summary>
            The unmanaged pointer the the frameSource
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoStab.FrameSource.NextFrame">
            <summary>
            Retrieve the next frame from the FrameSoure
            </summary>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.VideoStab.FrameSource.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this FrameSource
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoStab.FrameSource.CaptureSource">
            <summary>
            Get or Set the capture type
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoStab.CaptureFrameSource.#ctor(Emgu.CV.VideoCapture)">
            <summary>
            Create a Capture frame source
            </summary>
            <param name="capture">The capture object that will be converted to a FrameSource</param>
        </member>
        <member name="M:Emgu.CV.VideoStab.CaptureFrameSource.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this CaptureFrameSource
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoStab.GaussianMotionFilter">
            <summary>
            Gaussian motion filter
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoStab.GaussianMotionFilter.#ctor(System.Int32,System.Single)">
            <summary>
            Create a Gaussian motion filter
            </summary>
            <param name="radius">The radius, use 15 for default.</param>
            <param name="stdev">The standard deviation, use -1.0f for default</param>
        </member>
        <member name="M:Emgu.CV.VideoStab.GaussianMotionFilter.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoStab.OnePassStabilizer">
            <summary>
            A one pass video stabilizer
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoStab.OnePassStabilizer.#ctor(Emgu.CV.VideoStab.FrameSource)">
            <summary>
            Create a one pass stabilizer
            </summary>
            <param name="baseFrameSource">The capture object to be stabalized</param>
        </member>
        <member name="M:Emgu.CV.VideoStab.OnePassStabilizer.SetMotionFilter(Emgu.CV.VideoStab.GaussianMotionFilter)">
            <summary>
            Set the Motion Filter
            </summary>
            <param name="motionFilter">The motion filter</param>
        </member>
        <member name="M:Emgu.CV.VideoStab.OnePassStabilizer.DisposeObject">
            <summary>
            Release the unmanaged memory associated with the stabilizer
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoStab.TwoPassStabilizer">
            <summary>
            A two pass video stabilizer
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoStab.TwoPassStabilizer.#ctor(Emgu.CV.VideoStab.FrameSource)">
            <summary>
            Create a two pass video stabilizer.
            </summary>
            <param name="baseFrameSource">The capture object to be stabilized. Should not be a camera stream.</param>
        </member>
        <member name="M:Emgu.CV.VideoStab.TwoPassStabilizer.DisposeObject">
            <summary>
            Release the unmanaged memory
            </summary>
        </member>
        <member name="T:Emgu.CV.IWidget">
            <summary>
            Interface for all widgets
            </summary>
        </member>
        <member name="P:Emgu.CV.IWidget.GetWidget">
            <summary>
            Get the pointer to the widget object
            </summary>
        </member>
        <member name="T:Emgu.CV.IWidget3D">
            <summary>
            Interface for all widget3D
            </summary>
        </member>
        <member name="P:Emgu.CV.IWidget3D.GetWidget3D">
            <summary>
            Get the pointer to the widget3D object
            </summary>
        </member>
        <member name="T:Emgu.CV.IWidget2D">
            <summary>
            Interface for all widget2D
            </summary>
        </member>
        <member name="P:Emgu.CV.IWidget2D.GetWidget2D">
            <summary>
            Get the pointer to the widget2D object
            </summary>
        </member>
        <member name="T:Emgu.CV.Viz3d">
            <summary>
            Represents a 3D visualizer window. 
            </summary>
        </member>
        <member name="M:Emgu.CV.Viz3d.#ctor(System.String)">
            <summary>
            Create a new 3D visualizer windows
            </summary>
            <param name="windowName">The name of the windows</param>
        </member>
        <member name="M:Emgu.CV.Viz3d.ShowWidget(System.String,Emgu.CV.IWidget,Emgu.CV.Affine3d)">
            <summary>
            Show a widget in the window
            </summary>
            <param name="id">A unique id for the widget.</param>
            <param name="widget">The widget to be displayed in the window.</param>
            <param name="pose">Pose of the widget.</param>
        </member>
        <member name="M:Emgu.CV.Viz3d.RemoveWidget(System.String)">
            <summary>
            Removes a widget from the window.
            </summary>
            <param name="id">The id of the widget that will be removed.</param>
        </member>
        <member name="M:Emgu.CV.Viz3d.SetWidgetPose(System.String,Emgu.CV.Affine3d)">
            <summary>
            Sets pose of a widget in the window.
            </summary>
            <param name="id">The id of the widget whose pose will be set.</param>
            <param name="pose">The new pose of the widget.</param>
        </member>
        <member name="M:Emgu.CV.Viz3d.Spin">
            <summary>
            The window renders and starts the event loop.
            </summary>
        </member>
        <member name="M:Emgu.CV.Viz3d.SpinOnce(System.Int32,System.Boolean)">
            <summary>
            Starts the event loop for a given time.
            </summary>
            <param name="time">	Amount of time in milliseconds for the event loop to keep running.</param>
            <param name="forceRedraw">If true, window renders.</param>
        </member>
        <member name="M:Emgu.CV.Viz3d.SetBackgroundMeshLab">
            <summary>
            Set the background color
            </summary>
        </member>
        <member name="M:Emgu.CV.Viz3d.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this Viz3d object
            </summary>
        </member>
        <member name="P:Emgu.CV.Viz3d.WasStopped">
            <summary>
            Returns whether the event loop has been stopped.
            </summary>
        </member>
        <member name="T:Emgu.CV.WArrow">
            <summary>
            This 3D Widget defines an arrow.
            </summary>
        </member>
        <member name="M:Emgu.CV.WArrow.#ctor(Emgu.CV.Structure.MCvPoint3D64f,Emgu.CV.Structure.MCvPoint3D64f,System.Double,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Constructs an WArrow.
            </summary>
            <param name="pt1">Start point of the arrow.</param>
            <param name="pt2">End point of the arrow.</param>
            <param name="thickness">Thickness of the arrow. Thickness of arrow head is also adjusted accordingly.</param>
            <param name="color">Color of the arrow.</param>
        </member>
        <member name="M:Emgu.CV.WArrow.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this WArrow object
            </summary>
        </member>
        <member name="P:Emgu.CV.WArrow.GetWidget3D">
            <summary>
            Get the pointer to the Widget3D obj
            </summary>
        </member>
        <member name="P:Emgu.CV.WArrow.GetWidget">
            <summary>
            Get the pointer to the Widget obj
            </summary>
        </member>
        <member name="T:Emgu.CV.WCircle">
            <summary>
            This 3D Widget defines a circle.
            </summary>
        </member>
        <member name="M:Emgu.CV.WCircle.#ctor(System.Double,System.Double,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Constructs default planar circle centred at origin with plane normal along z-axis.
            </summary>
            <param name="radius">Radius of the circle.</param>
            <param name="thickness">Thickness of the circle.</param>
            <param name="color">Color of the circle.</param>
        </member>
        <member name="M:Emgu.CV.WCircle.#ctor(System.Double,Emgu.CV.Structure.MCvPoint3D64f,Emgu.CV.Structure.MCvPoint3D64f,System.Double,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Constructs repositioned planar circle.
            </summary>
            <param name="radius">Radius of the circle.</param>
            <param name="center">Center of the circle.</param>
            <param name="normal">Normal of the plane in which the circle lies.</param>
            <param name="thickness">Thickness of the circle.</param>
            <param name="color">Color of the circle.</param>
        </member>
        <member name="M:Emgu.CV.WCircle.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this WCircle object
            </summary>
        </member>
        <member name="P:Emgu.CV.WCircle.GetWidget3D">
            <summary>
            Get the pointer to the Widget3D obj
            </summary>
        </member>
        <member name="P:Emgu.CV.WCircle.GetWidget">
            <summary>
            Get the pointer to the Widget obj
            </summary>
        </member>
        <member name="T:Emgu.CV.WCloud">
            <summary>
            This 3D Widget defines a point cloud.
            </summary>
        </member>
        <member name="M:Emgu.CV.WCloud.#ctor(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Constructs a WCloud.
            </summary>
            <param name="cloud">Set of points which can be of type: CV_32FC3, CV_32FC4, CV_64FC3, CV_64FC4.</param>
            <param name="color">Set of colors. It has to be of the same size with cloud.</param>
        </member>
        <member name="M:Emgu.CV.WCloud.#ctor(Emgu.CV.IInputArray,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Constructs a WCloud.
            </summary>
            <param name="cloud">Set of points which can be of type: CV_32FC3, CV_32FC4, CV_64FC3, CV_64FC4.</param>
            <param name="color">A single Color for the whole cloud.</param>
        </member>
        <member name="M:Emgu.CV.WCloud.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this WCloud
            </summary>
        </member>
        <member name="P:Emgu.CV.WCloud.GetWidget3D">
            <summary>
            Get the pointer to the Widget3D obj
            </summary>
        </member>
        <member name="P:Emgu.CV.WCloud.GetWidget">
            <summary>
            Get the pointer to the Widget obj
            </summary>
        </member>
        <member name="T:Emgu.CV.WCone">
            <summary>
            This 3D Widget defines a cone.
            </summary>
        </member>
        <member name="M:Emgu.CV.WCone.#ctor(System.Double,System.Double,System.Int32,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Constructs default cone oriented along x-axis with center of its base located at origin.
            </summary>
            <param name="length">Length of the cone.</param>
            <param name="radius">Radius of the cone.</param>
            <param name="resolution">Resolution of the cone.</param>
            <param name="color">Color of the cone.</param>
        </member>
        <member name="M:Emgu.CV.WCone.#ctor(System.Double,Emgu.CV.Structure.MCvPoint3D64f,Emgu.CV.Structure.MCvPoint3D64f,System.Int32,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Constructs repositioned planar cone.
            </summary>
            <param name="radius">Radius of the cone.</param>
            <param name="center">Center of the cone base.</param>
            <param name="tip">Tip of the cone.</param>
            <param name="resolution">Resolution of the cone.</param>
            <param name="color">Color of the cone.</param>
        </member>
        <member name="M:Emgu.CV.WCone.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this WCone object
            </summary>
        </member>
        <member name="P:Emgu.CV.WCone.GetWidget3D">
            <summary>
            Get the pointer to the Widget3D obj
            </summary>
        </member>
        <member name="P:Emgu.CV.WCone.GetWidget">
            <summary>
            Get the pointer to the Widget obj
            </summary>
        </member>
        <member name="T:Emgu.CV.WCoordinateSystem">
            <summary>
            This 3D Widget represents a coordinate system.
            </summary>
        </member>
        <member name="M:Emgu.CV.WCoordinateSystem.#ctor(System.Double)">
            <summary>
            Constructs a WCoordinateSystem.
            </summary>
            <param name="scale">Determines the size of the axes.</param>
        </member>
        <member name="M:Emgu.CV.WCoordinateSystem.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this WCoordinateSysyem object
            </summary>
        </member>
        <member name="P:Emgu.CV.WCoordinateSystem.GetWidget3D">
            <summary>
            Get the pointer to the Widget3D obj
            </summary>
        </member>
        <member name="P:Emgu.CV.WCoordinateSystem.GetWidget">
            <summary>
            Get the pointer to the Widget obj
            </summary>
        </member>
        <member name="T:Emgu.CV.WCube">
            <summary>
            This 3D Widget defines a cube.
            </summary>
        </member>
        <member name="M:Emgu.CV.WCube.#ctor(Emgu.CV.Structure.MCvPoint3D64f,Emgu.CV.Structure.MCvPoint3D64f,System.Boolean,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Constructs a WCube.
            </summary>
            <param name="minPoint">Specifies minimum point of the bounding box.</param>
            <param name="maxPoint">Specifies maximum point of the bounding box.</param>
            <param name="wireFrame">If true, cube is represented as wireframe.</param>
            <param name="color">Color of the cube.</param>
        </member>
        <member name="M:Emgu.CV.WCube.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this WCube object
            </summary>
        </member>
        <member name="P:Emgu.CV.WCube.GetWidget3D">
            <summary>
            Get the pointer to the Widget3D obj
            </summary>
        </member>
        <member name="P:Emgu.CV.WCube.GetWidget">
            <summary>
            Get the pointer to the Widget obj
            </summary>
        </member>
        <member name="T:Emgu.CV.WCylinder">
            <summary>
            This 3D Widget defines a cylinder.
            </summary>
        </member>
        <member name="M:Emgu.CV.WCylinder.#ctor(Emgu.CV.Structure.MCvPoint3D64f@,Emgu.CV.Structure.MCvPoint3D64f,System.Double,System.Int32,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Constructs a WCylinder.
            </summary>
            <param name="axisPoint1">A point1 on the axis of the cylinder.</param>
            <param name="axisPoint2">A point2 on the axis of the cylinder.</param>
            <param name="radius">Radius of the cylinder.</param>
            <param name="numsides">Resolution of the cylinder.</param>
            <param name="color">Color of the cylinder.</param>
        </member>
        <member name="M:Emgu.CV.WCylinder.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this WCylinder object
            </summary>
        </member>
        <member name="P:Emgu.CV.WCylinder.GetWidget3D">
            <summary>
            Get the pointer to the Widget3D obj
            </summary>
        </member>
        <member name="P:Emgu.CV.WCylinder.GetWidget">
            <summary>
            Get the pointer to the Widget obj
            </summary>
        </member>
        <member name="T:Emgu.CV.WText">
            <summary>
            This 2D Widget represents text overlay.
            </summary>
        </member>
        <member name="M:Emgu.CV.WText.#ctor(System.String,System.Drawing.Point,System.Int32,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Constructs a WText.
            </summary>
            <param name="text">Text content of the widget.</param>
            <param name="pos">Position of the text.</param>
            <param name="fontSize">Font size.</param>
            <param name="color">Color of the text.</param>
        </member>
        <member name="M:Emgu.CV.WText.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this Viz3d object
            </summary>
        </member>
        <member name="P:Emgu.CV.WText.GetWidget2D">
            <summary>
            Get the pointer to the widget2D object
            </summary>
        </member>
        <member name="P:Emgu.CV.WText.GetWidget">
            <summary>
            Get the pointer to the widget object.
            </summary>
        </member>
        <member name="T:Emgu.CV.OCR.OcrInvoke">
            <summary>
            Library to invoke Tesseract OCR functions
            </summary>
        </member>
        <member name="T:Emgu.CV.OCR.PageIterator">
            <summary>
            The tesseract page iterator
            </summary>
        </member>
        <member name="M:Emgu.CV.OCR.PageIterator.GetBaseLine(Emgu.CV.OCR.PageIteratorLevel)">
            <summary>
            Returns the baseline of the current object at the given level. The baseline is the line that passes through (x1, y1) and (x2, y2). WARNING: with vertical text, baselines may be vertical! Returns null if there is no baseline at the current position.
            </summary>
            <param name="level">Page iterator level</param>
            <returns>The baseline of the current object at the given level</returns>
        </member>
        <member name="M:Emgu.CV.OCR.PageIterator.DisposeObject">
            <summary>
            Release the page iterator
            </summary>
        </member>
        <member name="P:Emgu.CV.OCR.PageIterator.Orientation">
            <summary>
            Returns orientation for the block the iterator points to. 
            </summary>
        </member>
        <member name="T:Emgu.CV.OCR.Orientation">
            <summary>
            The orientation
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.Orientation.PageOrientation">
            <summary>
            Page orientation
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.Orientation.WritingDirection">
            <summary>
            Writing direction
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.Orientation.TextlineOrder">
            <summary>
            Textline order
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.Orientation.DeskewAngle">
            <summary>
            after rotating the block so the text orientation is upright, how many radians does one have to rotate the block anti-clockwise for it to be level? -Pi/4 &lt;= deskew_angle &lt;= Pi/4
            </summary>
        </member>
        <member name="T:Emgu.CV.OCR.PageOrientation">
            <summary>
            Page orientation
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.PageOrientation.Up">
            <summary>
            Up
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.PageOrientation.Right">
            <summary>
            Right
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.PageOrientation.Down">
            <summary>
            Down
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.PageOrientation.Left">
            <summary>
            Left
            </summary>
        </member>
        <member name="T:Emgu.CV.OCR.WritingDirection">
            <summary>
            Writing direction
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.WritingDirection.LeftToRight">
            <summary>
            Left to right
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.WritingDirection.RightToLeft">
            <summary>
            Right to left
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.WritingDirection.TopToBottom">
            <summary>
            Top to bottom
            </summary>
        </member>
        <member name="T:Emgu.CV.OCR.TextlineOrder">
            <summary>
            Textline order
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.TextlineOrder.LeftToRight">
            <summary>
            Left to right
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.TextlineOrder.RightToLeft">
            <summary>
            Right to left
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.TextlineOrder.TopToBottom">
            <summary>
            Top to bottom
            </summary>
        </member>
        <member name="T:Emgu.CV.OCR.PageIteratorLevel">
            <summary>
            Page iterator level
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.PageIteratorLevel.Block">
            <summary>
            Block of text/image/separator line.
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.PageIteratorLevel.Para">
            <summary>
            Paragraph within a block.
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.PageIteratorLevel.Textline">
            <summary>
            Line within a paragraph.
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.PageIteratorLevel.Word">
            <summary>
            Word within a textline.
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.PageIteratorLevel.Symbol">
            <summary>
            Symbol/character within a word.
            </summary>
        </member>
        <member name="T:Emgu.CV.OCR.Pix">
            <summary>
            Leptonica Pix image structure
            </summary>
        </member>
        <member name="M:Emgu.CV.OCR.Pix.#ctor(Emgu.CV.Mat)">
            <summary>
            Create a Pix object by coping data from Mat
            </summary>
            <param name="mat">The Mat to create the Pix object from</param>
        </member>
        <member name="M:Emgu.CV.OCR.Pix.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this Pix
            </summary>
        </member>
        <member name="T:Emgu.CV.OCR.ITessResultRenderer">
            <summary>
            Interface to the TesseractResultRender
            </summary>
        </member>
        <member name="P:Emgu.CV.OCR.ITessResultRenderer.TessResultRendererPtr">
            <summary>
            Pointer to the unmanaged TessResultRendered
            </summary>
        </member>
        <member name="T:Emgu.CV.OCR.PDFRenderer">
            <summary>
            Renders tesseract output into searchable PDF
            </summary>
        </member>
        <member name="M:Emgu.CV.OCR.PDFRenderer.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Create a PDF renderer
            </summary>
            <param name="outputBase"></param>
            <param name="dataDir">dataDir is the location of the TESSDATA. We need it because we load a custom PDF font from this location.</param>
            <param name="textOnly"></param>
        </member>
        <member name="M:Emgu.CV.OCR.PDFRenderer.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this Renderer
            </summary>
        </member>
        <member name="P:Emgu.CV.OCR.PDFRenderer.TessResultRendererPtr">
            <summary>
            Pointer to the unmanaged TessResultRendered
            </summary>
        </member>
        <member name="T:Emgu.CV.OCR.Tesseract">
            <summary>
            The tesseract OCR engine
            </summary>
        </member>
        <member name="M:Emgu.CV.OCR.Tesseract.#ctor">
            <summary>
            Create a default tesseract engine. Needed to Call Init function to load language files in a later stage.
            </summary>
        </member>
        <member name="M:Emgu.CV.OCR.Tesseract.GetOpenCLDevice(System.IntPtr@)">
            <summary>
            Get the OpenCL device pointer
            </summary>
            <param name="device">Pointer to the opencl device</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.OCR.Tesseract.#ctor(System.String,System.String,Emgu.CV.OCR.OcrEngineMode)">
            <summary>
            Create an tesseract OCR engine.
            </summary>
            <param name="dataPath">
            The datapath must be the name of the parent directory of tessdata and
            must end in / . Any name after the last / will be stripped.
            </param>
            <param name="language">
            The language is (usually) an ISO 639-3 string or NULL will default to eng.
            It is entirely safe (and eventually will be efficient too) to call
            Init multiple times on the same instance to change language, or just
            to reset the classifier.
            The language may be a string of the form [~]%lt;lang&gt;[+[~]&lt;lang&gt;]* indicating
            that multiple languages are to be loaded. Eg hin+eng will load Hindi and
            English. Languages may specify internally that they want to be loaded
            with one or more other languages, so the ~ sign is available to override
            that. Eg if hin were set to load eng by default, then hin+~eng would force
            loading only hin. The number of loaded languages is limited only by
            memory, with the caveat that loading additional languages will impact
            both speed and accuracy, as there is more work to do to decide on the
            applicable language, and there is more chance of hallucinating incorrect
            words.
            </param>
            <param name="mode">OCR engine mode</param>
        </member>
        <member name="M:Emgu.CV.OCR.Tesseract.#ctor(System.String,System.String,Emgu.CV.OCR.OcrEngineMode,System.String)">
            <summary>
            Create an tesseract OCR engine.
            </summary>
            <param name="dataPath">
            The datapath must be the name of the parent directory of tessdata and
            must end in / . Any name after the last / will be stripped.
            </param>
            <param name="language">
            The language is (usually) an ISO 639-3 string or NULL will default to eng.
            It is entirely safe (and eventually will be efficient too) to call
            Init multiple times on the same instance to change language, or just
            to reset the classifier.
            The language may be a string of the form [~]%lt;lang&gt;[+[~]&lt;lang&gt;]* indicating
            that multiple languages are to be loaded. Eg hin+eng will load Hindi and
            English. Languages may specify internally that they want to be loaded
            with one or more other languages, so the ~ sign is available to override
            that. Eg if hin were set to load eng by default, then hin+~eng would force
            loading only hin. The number of loaded languages is limited only by
            memory, with the caveat that loading additional languages will impact
            both speed and accuracy, as there is more work to do to decide on the
            applicable language, and there is more chance of hallucinating incorrect
            words.
            </param>
            <param name="mode">OCR engine mode</param>
            <param name="whiteList">This can be used to specify a white list for OCR. e.g. specify "1234567890" to recognize digits only. Note that the white list currently seems to only work with OcrEngineMode.OEM_TESSERACT_ONLY</param>
        </member>
        <member name="M:Emgu.CV.OCR.Tesseract.IsValidWord(System.String)">
            <summary>
            Check whether a word is valid according to Tesseract's language model
            </summary>
            <param name="word">The word to be checked.</param>
            <returns>0 if the word is invalid, non-zero if valid</returns>
        </member>
        <member name="M:Emgu.CV.OCR.Tesseract.Init(System.String,System.String,Emgu.CV.OCR.OcrEngineMode)">
            <summary>
            Initialize the OCR engine using the specific dataPath and language name.
            </summary>
            <param name="dataPath">
            The datapath must be the name of the parent directory of tessdata and
            must end in / . Any name after the last / will be stripped.
            </param>
            <param name="language">
            The language is (usually) an ISO 639-3 string or NULL will default to eng.
            It is entirely safe (and eventually will be efficient too) to call
            Init multiple times on the same instance to change language, or just
            to reset the classifier.
            The language may be a string of the form [~]%lt;lang&gt;[+[~]&lt;lang&gt;]* indicating
            that multiple languages are to be loaded. Eg hin+eng will load Hindi and
            English. Languages may specify internally that they want to be loaded
            with one or more other languages, so the ~ sign is available to override
            that. Eg if hin were set to load eng by default, then hin+~eng would force
            loading only hin. The number of loaded languages is limited only by
            memory, with the caveat that loading additional languages will impact
            both speed and accuracy, as there is more work to do to decide on the
            applicable language, and there is more chance of hallucinating incorrect
            words.
            </param>
            <param name="mode">OCR engine mode</param>
        </member>
        <member name="M:Emgu.CV.OCR.Tesseract.DisposeObject">
            <summary>
            Release the unmanaged resource associated with this class
            </summary>
        </member>
        <member name="M:Emgu.CV.OCR.Tesseract.SetImage(Emgu.CV.IInputArray)">
            <summary>
            Set the image for optical character recognition
            </summary>
            <param name="image">The image where detection took place</param>
        </member>
        <member name="M:Emgu.CV.OCR.Tesseract.SetImage(Emgu.CV.OCR.Pix)">
            <summary>
            Set the image for optical character recognition
            </summary>
            <param name="image">The image where detection took place</param>
        </member>
        <member name="M:Emgu.CV.OCR.Tesseract.Recognize">
            <summary>
            Recognize the image from SetAndThresholdImage, generating Tesseract
            internal structures.
            </summary>
            <returns>Returns 0 on success.</returns>
        </member>
        <member name="M:Emgu.CV.OCR.Tesseract.SetVariable(System.String,System.String)">
            <summary>
            Set the variable to the specific value.
            </summary>
            <param name="variableName">The name of the tesseract variable. e.g. use "tessedit_char_blacklist" to black list characters and ""tessedit_char_whitelist" to white list characters. The full list of options can be found in the Tesseract OCR source code "tesseractclass.h"</param>
            <param name="value">The value to be set</param>
        </member>
        <member name="M:Emgu.CV.OCR.Tesseract.GetUTF8Text">
            <summary>
            Get all the text in the image
            </summary>
            <returns>All the text in the image</returns>
        </member>
        <member name="M:Emgu.CV.OCR.Tesseract.GetTSVText(System.Int32)">
            <summary>
            Make a TSV-formatted string from the internal data structures.
            </summary>
            <param name="pageNumber">pageNumber is 0-based but will appear in the output as 1-based.</param>
            <returns>A TSV-formatted string from the internal data structures.</returns>
        </member>
        <member name="M:Emgu.CV.OCR.Tesseract.GetBoxText(System.Int32)">
            <summary>
            The recognized text is returned as coded in the same format as a box file used in training.
            </summary>
            <param name="pageNumber">pageNumber is 0-based but will appear in the output as 1-based.</param>
            <returns>The recognized text is returned as coded in the same format as a box file used in training.</returns>
        </member>
        <member name="M:Emgu.CV.OCR.Tesseract.GetUNLVText(System.Int32)">
            <summary>
            The recognized text is returned coded as UNLV format Latin-1 with specific reject and suspect codes
            </summary>
            <param name="pageNumber">pageNumber is 0-based but will appear in the output as 1-based.</param>
            <returns>The recognized text is returned coded as UNLV format Latin-1 with specific reject and suspect codes</returns>
        </member>
        <member name="M:Emgu.CV.OCR.Tesseract.GetOsdText(System.Int32)">
            <summary>
            The recognized text
            </summary>
            <param name="pageNumber">pageNumber is 0-based but will appear in the output as 1-based.</param>
            <returns>The recognized text</returns>
        </member>
        <member name="M:Emgu.CV.OCR.Tesseract.GetHOCRText(System.Int32)">
            <summary>
            Make a HTML-formatted string with hOCR markup from the internal data structures.
            </summary>
            <param name="pageNumber">pageNumber is 0-based but will appear in the output as 1-based.</param>
            <returns>A HTML-formatted string with hOCR markup from the internal data structures.</returns>
        </member>
        <member name="M:Emgu.CV.OCR.Tesseract.GetCharacters">
            <summary>
            Detect all the characters in the image.
            </summary>
            <returns>All the characters in the image</returns>
        </member>
        <member name="M:Emgu.CV.OCR.Tesseract.ProcessPage(Emgu.CV.OCR.Pix,System.Int32,System.String,System.String,System.Int32,Emgu.CV.OCR.ITessResultRenderer)">
            <summary>
            Turn a single image into symbolic text.
            </summary>
            <param name="pix">The pix is the image processed.</param>
            <param name="pageIndex">Metadata used by side-effect processes, such as reading a box file or formatting as hOCR.</param>
            <param name="filename">Metadata used by side-effect processes, such as reading a box file or formatting as hOCR.</param>
            <param name="retryConfig">retryConfig is useful for debugging. If not NULL, you can fall back to an alternate configuration if a page fails for some reason.</param>
            <param name="timeoutMillisec">terminates processing if any single page takes too long. Set to 0 for unlimited time.</param>
            <param name="renderer">Responible for creating the output. For example, use the TessTextRenderer if you want plaintext output, or the TessPDFRender to produce searchable PDF.</param>
            <returns>Returns true if successful, false on error.</returns>
        </member>
        <member name="M:Emgu.CV.OCR.Tesseract.AnalyseLayout(System.Boolean)">
            <summary>
            Runs page layout analysis in the mode set by SetPageSegMode. May optionally be called prior to Recognize to get access to just the page layout results. Returns an iterator to the results. Returns NULL on error or an empty page. The returned iterator must be deleted after use. WARNING! This class points to data held within the TessBaseAPI class, and therefore can only be used while the TessBaseAPI class still exists and has not been subjected to a call of Init, SetImage, Recognize, Clear, End DetectOS, or anything else that changes the internal PAGE_RES.
            </summary>
            <param name="mergeSimilarWords"></param>
            <returns></returns>
        </member>
        <member name="P:Emgu.CV.OCR.Tesseract.VersionString">
            <summary>
            Get the tesseract version as String
            </summary>
        </member>
        <member name="P:Emgu.CV.OCR.Tesseract.Version">
            <summary>
            Get the tesseract version
            </summary>
        </member>
        <member name="P:Emgu.CV.OCR.Tesseract.PageSegMode">
            <summary>
            Gets or sets the page seg mode.
            </summary>
            <value>
            The page seg mode.
            </value>
        </member>
        <member name="P:Emgu.CV.OCR.Tesseract.Oem">
            <summary>
            Get the OCR Engine Mode
            </summary>
        </member>
        <member name="T:Emgu.CV.OCR.Tesseract.Character">
            <summary>
            This represent a character that is detected by the OCR engine
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.Tesseract.Character.Text">
            <summary>
            The text
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.Tesseract.Character.Cost">
            <summary>
            The cost. The lower it is, the more confident is the result
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.Tesseract.Character.Region">
            <summary>
            The region where the character is detected.
            </summary>
        </member>
        <member name="T:Emgu.CV.OCR.OcrEngineMode">
            <summary>
            When Tesseract/LSTM is initialized we can choose to instantiate/load/run
            only the Tesseract part, only the Cube part or both along with the combiner.
            The preference of which engine to use is stored in tessedit_ocr_engine_mode.
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.OcrEngineMode.TesseractOnly">
            <summary>
            Run Tesseract only - fastest
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.OcrEngineMode.LstmOnly">
            <summary>
            Run just the LSTM line recognizer.
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.OcrEngineMode.TesseractLstmCombined">
            <summary>
            Run the LSTM recognizer, but allow fallback to Tesseract when things get difficult.
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.OcrEngineMode.Default">
            <summary>
            Specify this mode when calling init_*(),
            to indicate that any of the above modes
            should be automatically inferred from the
            variables in the language-specific config,
            command-line configs, or if not specified
            in any of the above should be set to the
            default OEM_TESSERACT_ONLY.
            </summary>
        </member>
        <member name="T:Emgu.CV.OCR.PageSegMode">
            <summary>
            Tesseract page segmentation mode
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.PageSegMode.OsdOnly">
            <summary>
            PageOrientation and script detection only.
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.PageSegMode.AutoOsd">
            <summary>
            Automatic page segmentation with orientation and script detection. (OSD)
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.PageSegMode.AutoOnly">
            <summary>
            Automatic page segmentation, but no OSD, or OCR.
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.PageSegMode.Auto">
            <summary>
            Fully automatic page segmentation, but no OSD.
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.PageSegMode.SingleColumn">
            <summary>
            Assume a single column of text of variable sizes.
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.PageSegMode.SingleBlockVertText">
            <summary>
            Assume a single uniform block of vertically aligned text.
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.PageSegMode.SingleBlock">
            <summary>
            Assume a single uniform block of text. (Default.)
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.PageSegMode.SingleLine">
            <summary>
            Treat the image as a single text line.
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.PageSegMode.SingleWord">
            <summary>
            Treat the image as a single word.
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.PageSegMode.CircleWord">
            <summary>
            Treat the image as a single word in a circle.
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.PageSegMode.SingleChar">
            <summary>
            Treat the image as a single character.
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.PageSegMode.SparseText">
            <summary>
            Find as much text as possible in no particular order.
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.PageSegMode.SparseTextOsd">
            <summary>
            Sparse text with orientation and script det.
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.PageSegMode.RawLine">
            <summary>
            Treat the image as a single text line, bypassing hacks that are Tesseract-specific.
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.PageSegMode.Count">
            <summary>
            Number of enum entries.
            </summary>
        </member>
        <member name="T:Emgu.CV.OCR.TesseractResult">
            <summary>
            This structure is primary used for PInvoke
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.TesseractResult.Length">
            <summary>
            The length
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.TesseractResult.Cost">
            <summary>
            The cost
            </summary>
        </member>
        <member name="F:Emgu.CV.OCR.TesseractResult.Region">
            <summary>
            The region
            </summary>
        </member>
        <member name="T:Emgu.CV.OCR.VectorOfTesseractResult">
            <summary>
            Wrapped class of the C++ standard vector of TesseractResult.
            </summary>
        </member>
        <member name="M:Emgu.CV.OCR.VectorOfTesseractResult.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.OCR.VectorOfTesseractResult.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.OCR.VectorOfTesseractResult.#ctor">
            <summary>
            Create an empty standard vector of TesseractResult
            </summary>
        </member>
        <member name="M:Emgu.CV.OCR.VectorOfTesseractResult.#ctor(System.Int32)">
            <summary>
            Create an standard vector of TesseractResult of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.OCR.VectorOfTesseractResult.#ctor(Emgu.CV.OCR.TesseractResult[])">
            <summary>
            Create an standard vector of TesseractResult with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.OCR.VectorOfTesseractResult.Push(Emgu.CV.OCR.TesseractResult[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.OCR.VectorOfTesseractResult.Push(Emgu.CV.OCR.VectorOfTesseractResult)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.OCR.VectorOfTesseractResult.ToArray">
            <summary>
            Convert the standard vector to an array of TesseractResult
            </summary>
            <returns>An array of TesseractResult</returns>
        </member>
        <member name="M:Emgu.CV.OCR.VectorOfTesseractResult.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.OCR.VectorOfTesseractResult.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.OCR.VectorOfTesseractResult.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.OCR.VectorOfTesseractResult.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.OCR.VectorOfTesseractResult.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.OCR.VectorOfTesseractResult.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.OCR.VectorOfTesseractResult.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.OCR.VectorOfTesseractResult.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.OCR.VectorOfTesseractResult.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaBackgroundSubtractorMOG">
            <summary>
            Gaussian Mixture-based Background/Foreground Segmentation Algorithm.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBackgroundSubtractorMOG.#ctor(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Create a Gaussian Mixture-based Background/Foreground Segmentation model
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBackgroundSubtractorMOG.Update(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,Emgu.CV.Cuda.Stream)">
            <summary>
            Updates the background model
            </summary>
            <param name="frame">Next video frame.</param>
            <param name="learningRate">The learning rate, use -1.0f for default value.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
            <param name="foregroundMask">The foregroundMask</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBackgroundSubtractorMOG.DisposeObject">
            <summary>
            Release all the unmanaged resource associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaInvoke">
            <summary>
            This class wraps the functional calls to the opencv_gpu module
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.cudaDeviceInfoComputeCapability(System.IntPtr,System.Int32@,System.Int32@)">
            <summary>
            Get the compute capability of the device
            </summary>
            <param name="device">The device</param>
            <param name="major">The major version of the compute capability</param>
            <param name="minor">The minor version of the compute capability</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.cudaDeviceInfoMultiProcessorCount(System.IntPtr)">
            <summary>
            Get the number of multiprocessors on device
            </summary>
            <param name="device">The device</param>
            <returns>The number of multiprocessors on device</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.cudaDeviceInfoDeviceName(System.IntPtr,System.Text.StringBuilder,System.Int32)">
            <summary>
            Get the device name
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.GetCudaDevicesSummary">
            <summary>
            Get the opencl platform summary as a string
            </summary>
            <returns>An opencl platfor summary</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.GetCudaEnabledDeviceCount">
            <summary>
            Get the number of Cuda enabled devices
            </summary>
            <returns>The number of Cuda enabled devices</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.SetDevice(System.Int32)">
            <summary>
            Set the current Gpu Device
            </summary>
            <param name="deviceId">The id of the device to be setted as current</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.GetDevice">
            <summary>
            Get the current Cuda device id
            </summary>
            <returns>The current Cuda device id</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.GetRegion(System.IntPtr,Emgu.CV.Structure.Range@,Emgu.CV.Structure.Range@)">
            <summary>
            Create a GpuMat from the specific region of <paramref name="gpuMat"/>. The data is shared between the two GpuMat.
            </summary>
            <param name="gpuMat">The gpuMat to extract regions from.</param>
            <param name="colRange">The column range. Use MCvSlice.WholeSeq for all columns.</param>
            <param name="rowRange">The row range. Use MCvSlice.WholeSeq for all rows.</param>
            <returns>Pointer to the GpuMat</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.GpuMatResize(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.Inter,System.IntPtr)">
            <summary>
            Resize the GpuMat
            </summary>
            <param name="src">The input GpuMat</param>
            <param name="dst">The resulting GpuMat</param>
            <param name="interpolation">The interpolation type</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>     
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.GpuMatReshape(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            gpuMatReshape the src GpuMat  
            </summary>
            <param name="src">The source GpuMat</param>
            <param name="dst">The resulting GpuMat, as input it should be an empty GpuMat.</param>
            <param name="cn">The new number of channels</param>
            <param name="rows">The new number of rows</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.GetSubRect(System.IntPtr,System.Drawing.Rectangle@)">
            <summary>
            Returns header, corresponding to a specified rectangle of the input GpuMat. In other words, it allows the user to treat a rectangular part of input array as a stand-alone array.
            </summary>
            <param name="mat">Input GpuMat</param>
            <param name="rect">Zero-based coordinates of the rectangle of interest.</param>
            <returns>Pointer to the resultant sub-array header.</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.LShift(System.IntPtr,Emgu.CV.Structure.MCvScalar@,System.IntPtr,System.IntPtr)">
            <summary>
            Shifts a matrix to the left (c = a &lt;&lt; scalar)
            </summary>
            <param name="a">The matrix to be shifted.</param>
            <param name="scalar">The scalar to shift by.</param>
            <param name="c">The result of the shift</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.RShift(System.IntPtr,Emgu.CV.Structure.MCvScalar@,System.IntPtr,System.IntPtr)">
            <summary>
            Shifts a matrix to the right (c = a >> scalar)
            </summary>
            <param name="a">The matrix to be shifted.</param>
            <param name="scalar">The scalar to shift by.</param>
            <param name="c">The result of the shift</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Add(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.DepthType,Emgu.CV.Cuda.Stream)">
            <summary>
            Adds one matrix to another (c = a + b).
            </summary>
            <param name="a">The first matrix to be added.</param>
            <param name="b">The second matrix to be added.</param>
            <param name="c">The sum of the two matrix</param>
            <param name="mask">The optional mask that is used to select a subarray. Use null if not needed</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
            <param name="depthType">Optional depth of the output array.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Subtract(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.DepthType,Emgu.CV.Cuda.Stream)">
            <summary>
            Subtracts one matrix from another (c = a - b).
            </summary>
            <param name="a">The matrix where subtraction take place</param>
            <param name="b">The matrix to be substracted</param>
            <param name="c">The result of a - b</param>
            <param name="mask">The optional mask that is used to select a subarray. Use null if not needed</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
            <param name="depthType">Optional depth of the output array.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Multiply(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,Emgu.CV.CvEnum.DepthType,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes element-wise product of the two GpuMat: c = scale * a * b.
            </summary>
            <param name="a">The first GpuMat to be element-wise multiplied.</param>
            <param name="b">The second GpuMat to be element-wise multiplied.</param>
            <param name="c">The element-wise multiplication of the two GpuMat</param>
            <param name="scale">The scale</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
            <param name="depthType">Optional depth of the output array.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Divide(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,Emgu.CV.CvEnum.DepthType,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes element-wise quotient of the two GpuMat (c = scale *  a / b).
            </summary>
            <param name="a">The first GpuMat</param>
            <param name="b">The second GpuMat</param>
            <param name="c">The element-wise quotient of the two GpuMat</param>
            <param name="scale">The scale</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
            <param name="depthType">Optional depth of the output array.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.AddWeighted(Emgu.CV.IInputArray,System.Double,Emgu.CV.IInputArray,System.Double,System.Double,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes the weighted sum of two arrays (dst = alpha*src1 + beta*src2 + gamma)
            </summary>
            <param name="src1">The first source GpuMat</param>
            <param name="alpha">The weight for <paramref name="src1"/></param>
            <param name="src2">The second source GpuMat</param>
            <param name="beta">The weight for <paramref name="src2"/></param>
            <param name="gamma">The constant to be added</param>
            <param name="dst">The result</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
            <param name="depthType">Optional depth of the output array.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Absdiff(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes element-wise absolute difference of two GpuMats (c = abs(a - b)).
            </summary>
            <param name="a">The first GpuMat</param>
            <param name="b">The second GpuMat</param>
            <param name="c">The result of the element-wise absolute difference.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Abs(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes absolute value of each pixel in an image
            </summary>
            <param name="src">The source GpuMat, support depth of Int16 and float.</param>
            <param name="dst">The resulting GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Sqr(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes square of each pixel in an image
            </summary>
            <param name="src">The source GpuMat, support depth of byte, UInt16, Int16 and float.</param>
            <param name="dst">The resulting GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Sqrt(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes square root of each pixel in an image
            </summary>
            <param name="src">The source GpuMat, support depth of byte, UInt16, Int16 and float.</param>
            <param name="dst">The resulting GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Transpose(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Transposes a matrix.
            </summary>
            <param name="src">Source matrix. 1-, 4-, 8-byte element sizes are supported for now.</param>
            <param name="dst">Destination matrix.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Compare(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.CmpType,Emgu.CV.Cuda.Stream)">
            <summary>
            Compares elements of two GpuMats (c = a &lt;cmpop&gt; b).
            Supports CV_8UC4, CV_32FC1 types
            </summary>
            <param name="a">The first GpuMat</param>
            <param name="b">The second GpuMat</param>
            <param name="c">The result of the comparison.</param>
            <param name="cmpop">The type of comparison</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Resize(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Drawing.Size,System.Double,System.Double,Emgu.CV.CvEnum.Inter,Emgu.CV.Cuda.Stream)">
            <summary>
            Resizes the image.
            </summary>
            <param name="src">The source image. Has to be GpuMat&lt;Byte&gt;. If stream is used, the GpuMat has to be either single channel or 4 channels.</param>
            <param name="dst">The destination image.</param>
            <param name="interpolation">The interpolation type. Supports INTER_NEAREST, INTER_LINEAR.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
            <param name="fx">Scale factor along the horizontal axis. If it is zero, it is computed as: (double)dsize.width/src.cols</param>
            <param name="fy">Scale factor along the vertical axis. If it is zero, it is computed as: (double)dsize.height/src.rows</param>
            <param name="dsize">Destination image size. If it is zero, it is computed as: dsize = Size(round(fx* src.cols), round(fy* src.rows)). Either dsize or both fx and fy must be non-zero.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Split(Emgu.CV.IInputArray,Emgu.CV.Cuda.VectorOfGpuMat,Emgu.CV.Cuda.Stream)">
            <summary>
            Copies each plane of a multi-channel GpuMat to a dedicated GpuMat
            </summary>
            <param name="src">The multi-channel gpuMat</param>
            <param name="dstArray">Pointer to an array of single channel GpuMat pointers</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Merge(Emgu.CV.Cuda.VectorOfGpuMat,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Makes multi-channel GpuMat out of several single-channel GpuMats
            </summary>
            <param name="srcArr">Pointer to an array of single channel GpuMat pointers</param>
            <param name="dst">The multi-channel gpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Exp(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes exponent of each matrix element (b = exp(a))
            </summary>
            <param name="src">The source GpuMat. Supports Byte, UInt16, Int16 and float type.</param>
            <param name="dst">The resulting GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Pow(Emgu.CV.IInputArray,System.Double,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes power of each matrix element:
              (dst(i,j) = pow(     src(i,j) , power), if src.type() is integer;
              (dst(i,j) = pow(fabs(src(i,j)), power), otherwise.
            supports all, except depth == CV_64F
            </summary>
            <param name="src">The source GpuMat</param>
            <param name="power">The power</param>
            <param name="dst">The resulting GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Log(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes natural logarithm of absolute value of each matrix element: b = log(abs(a))
            </summary>
            <param name="src">The source GpuMat. Supports Byte, UInt16, Int16 and float type.</param>
            <param name="dst">The resulting GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Magnitude(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes magnitude of each (x(i), y(i)) vector
            </summary>
            <param name="x">The source GpuMat. Supports only floating-point type</param>
            <param name="y">The source GpuMat. Supports only floating-point type</param>
            <param name="magnitude">The destination GpuMat. Supports only floating-point type</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.MagnitudeSqr(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes squared magnitude of each (x(i), y(i)) vector
            </summary>
            <param name="x">The source GpuMat. Supports only floating-point type</param>
            <param name="y">The source GpuMat. Supports only floating-point type</param>
            <param name="magnitude">The destination GpuMat. Supports only floating-point type</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Phase(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Boolean,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes angle (angle(i)) of each (x(i), y(i)) vector
            </summary>
            <param name="x">The source GpuMat. Supports only floating-point type</param>
            <param name="y">The source GpuMat. Supports only floating-point type</param>
            <param name="angle">The destination GpuMat. Supports only floating-point type</param>
            <param name="angleInDegrees">If true, the output angle is in degrees, otherwise in radian</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.CartToPolar(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Boolean,Emgu.CV.Cuda.Stream)">
            <summary>
            Converts Cartesian coordinates to polar
            </summary>
            <param name="x">The source GpuMat. Supports only floating-point type</param>
            <param name="y">The source GpuMat. Supports only floating-point type</param>
            <param name="magnitude">The destination GpuMat. Supports only floating-point type</param>
            <param name="angle">The destination GpuMat. Supports only floating-point type</param>
            <param name="angleInDegrees">If true, the output angle is in degrees, otherwise in radian</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.PolarToCart(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Boolean,Emgu.CV.Cuda.Stream)">
            <summary>
            Converts polar coordinates to Cartesian
            </summary>
            <param name="magnitude">The source GpuMat. Supports only floating-point type</param>
            <param name="angle">The source GpuMat. Supports only floating-point type</param>
            <param name="x">The destination GpuMat. Supports only floating-point type</param>
            <param name="y">The destination GpuMat. Supports only floating-point type</param>
            <param name="angleInDegrees">If true, the input angle is in degrees, otherwise in radian</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.MinMaxLoc(Emgu.CV.IInputArray,System.Double@,System.Double@,System.Drawing.Point@,System.Drawing.Point@,Emgu.CV.IInputArray)">
            <summary>
            Finds minimum and maximum element values and their positions. The extremums are searched over the whole GpuMat or, if mask is not IntPtr.Zero, in the specified GpuMat region.
            </summary>
            <param name="gpuMat">The source GpuMat, single-channel</param>
            <param name="minVal">Pointer to returned minimum value</param>
            <param name="maxVal">Pointer to returned maximum value</param>
            <param name="minLoc">Pointer to returned minimum location</param>
            <param name="maxLoc">Pointer to returned maximum location</param>
            <param name="mask">The optional mask that is used to select a subarray. Use null if not needed</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.FindMinMaxLoc(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Finds global minimum and maximum matrix elements and returns their values with locations.
            </summary>
            <param name="src">Single-channel source image.</param>
            <param name="minMaxVals">The output min and max values</param>
            <param name="loc">The ouput min and max locations</param>
            <param name="mask">Optional mask to select a sub-matrix.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.PyrDown(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Performs downsampling step of Gaussian pyramid decomposition. 
            </summary>
            <param name="src">The source CudaImage.</param>
            <param name="dst">The destination CudaImage, should have 2x smaller width and height than the source.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.PyrUp(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Performs up-sampling step of Gaussian pyramid decomposition.
            </summary>
            <param name="src">The source CudaImage.</param>
            <param name="dst">The destination image, should have 2x smaller width and height than the source.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.MeanStdDev(Emgu.CV.IInputArray,Emgu.CV.Structure.MCvScalar@,Emgu.CV.Structure.MCvScalar@)">
            <summary>
            Computes mean value and standard deviation
            </summary>
            <param name="mtx">The GpuMat. Supports only CV_8UC1 type</param>
            <param name="mean">The mean value</param>
            <param name="stddev">The standard deviation</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Norm(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.NormType)">
            <summary>
            Computes norm of the difference between two GpuMats
            </summary>
            <param name="src1">The GpuMat. Supports only CV_8UC1 type</param>
            <param name="src2">If IntPtr.Zero, norm operation is apply to <paramref name="src1"/> only. Otherwise, this is the GpuMat of type CV_8UC1</param>
            <param name="normType">The norm type. Supports NORM_INF, NORM_L1, NORM_L2.</param>
            <returns>The norm of the <paramref name="src1"/> if <paramref name="src2"/> is IntPtr.Zero. Otherwise the norm of the difference between two GpuMats.</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Norm(Emgu.CV.IInputArray,Emgu.CV.CvEnum.NormType,Emgu.CV.IInputArray)">
            <summary>
            Returns the norm of a matrix.
            </summary>
            <param name="src">Source matrix. Any matrices except 64F are supported.</param>
            <param name="normType">Norm type. NORM_L1 , NORM_L2 , and NORM_INF are supported for now.</param>
            <param name="mask">optional operation mask; it must have the same size as src1 and CV_8UC1 type.</param>
            <returns>The norm of a matrix</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.CalcNorm(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.NormType,Emgu.CV.IInputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Returns the norm of a matrix.
            </summary>
            <param name="src">Source matrix. Any matrices except 64F are supported.</param>
            <param name="dst">The GpuMat to store the result</param>
            <param name="normType">Norm type. NORM_L1 , NORM_L2 , and NORM_INF are supported for now.</param>
            <param name="mask">optional operation mask; it must have the same size as src1 and CV_8UC1 type.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.CalcNormDiff(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.NormType,Emgu.CV.Cuda.Stream)">
            <summary>
            Returns the difference of two matrices.
            </summary>
            <param name="src1">Source matrix. Any matrices except 64F are supported.</param>
            <param name="src2">Second source matrix (if any) with the same size and type as src1.</param>
            <param name="dst">The GpuMat where the result will be stored in</param>
            <param name="normType">Norm type. NORM_L1 , NORM_L2 , and NORM_INF are supported for now.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.AbsSum(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Returns the sum of absolute values for matrix elements.
            </summary>
            <param name="src">Source image of any depth except for CV_64F.</param>
            <param name="mask">optional operation mask; it must have the same size as src and CV_8UC1 type.</param>
            <returns>The sum of absolute values for matrix elements.</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.CalcAbsSum(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Returns the sum of absolute values for matrix elements.
            </summary>
            <param name="src">Source image of any depth except for CV_64F.</param>
            <param name="dst">The GpuMat where the result will be stored.</param>
            <param name="mask">optional operation mask; it must have the same size as src1 and CV_8UC1 type.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.SqrSum(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Returns the squared sum of matrix elements.
            </summary>
            <param name="src">Source image of any depth except for CV_64F.</param>
            <param name="mask">optional operation mask; it must have the same size as src1 and CV_8UC1 type.</param>
            <returns>The squared sum of matrix elements.</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.CalcSqrSum(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Returns the squared sum of matrix elements.
            </summary>
            <param name="src">Source image of any depth except for CV_64F.</param>
            <param name="dst">The GpuMat where the result will be stored</param>
            <param name="mask">optional operation mask; it must have the same size as src1 and CV_8UC1 type.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.CountNonZero(Emgu.CV.IInputArray)">
            <summary>
            Counts non-zero array elements
            </summary>
            <param name="src">Single-channel source image.</param>
            <returns>The number of non-zero GpuMat elements</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.CountNonZero(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Counts non-zero array elements
            </summary>
            <param name="src">Single-channel source image.</param>
            <param name="dst">A Gpu mat to hold the result</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Normalize(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,Emgu.CV.CvEnum.NormType,Emgu.CV.CvEnum.DepthType,Emgu.CV.IInputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Normalizes the norm or value range of an array.
            </summary>
            <param name="src">Input array.</param>
            <param name="dst">Output array of the same size as src .</param>
            <param name="alpha">Norm value to normalize to or the lower range boundary in case of the range normalization.</param>
            <param name="beta">Upper range boundary in case of the range normalization; it is not used for the norm normalization.</param>
            <param name="normType">Normalization type ( NORM_MINMAX , NORM_L2 , NORM_L1 or NORM_INF ).</param>
            <param name="depthType">Optional depth of the output array.</param>
            <param name="mask">Optional operation mask.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Reduce(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.ReduceDimension,Emgu.CV.CvEnum.ReduceType,Emgu.CV.CvEnum.DepthType,Emgu.CV.Cuda.Stream)">
            <summary>
            Reduces GpuMat to a vector by treating the GpuMat rows/columns as a set of 1D vectors and performing the specified operation on the vectors until a single row/column is obtained. 
            </summary>
            <param name="mtx">The input GpuMat</param>
            <param name="vec">Destination vector. Its size and type is defined by dim and dtype parameters</param>
            <param name="dim">Dimension index along which the matrix is reduced. 0 means that the matrix is reduced to a single row. 1 means that the matrix is reduced to a single column.</param>
            <param name="reduceOp">The reduction operation type</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>      
            <param name="dType">Optional depth of the output array.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.cudaFlip(System.IntPtr,System.IntPtr,System.Int32,System.IntPtr)">
             <summary>
             Flips the GpuMat in one of different 3 ways (row and column indices are 0-based):
             dst(i,j)=src(rows(src)-i-1,j) if flip_mode = 0
             dst(i,j)=src(i,cols(src1)-j-1) if flip_mode &gt; 0
             dst(i,j)=src(rows(src)-i-1,cols(src)-j-1) if flip_mode &lt; 0
             </summary>
             <param name="src">Source GpuMat.</param>
             <param name="dst">Destination GpuMat.</param>
             <param name="flipMode">
             Specifies how to flip the GpuMat.
             flip_mode = 0 means flipping around x-axis, 
             flip_mode &gt; 0 (e.g. 1) means flipping around y-axis and 
             flip_mode &lt; 0 (e.g. -1) means flipping around both axises. 
            </param>
             <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>      
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Flip(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.FlipType,Emgu.CV.Cuda.Stream)">
            <summary>
            Flips the GpuMat&lt;Byte&gt; in one of different 3 ways (row and column indices are 0-based). 
            </summary>
            <param name="src">The source GpuMat. supports 1, 3 and 4 channels GpuMat with Byte, UInt16, int or float depth</param>
            <param name="dst">Destination GpuMat. The same source and type as <paramref name="src"/></param>
            <param name="flipType">Specifies how to flip the GpuMat.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>      
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.BitwiseXor(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Calculates per-element bit-wise logical conjunction of two GpuMats:
            dst(I)=src1(I)^src2(I) if mask(I)!=0
            In the case of floating-point GpuMats their bit representations are used for the operation. All the GpuMats must have the same type, except the mask, and the same size
            </summary>
            <param name="src1">The first source GpuMat</param>
            <param name="src2">The second source GpuMat</param>
            <param name="dst">The destination GpuMat</param>
            <param name="mask">Mask, 8-bit single channel GpuMat; specifies elements of destination GpuMat to be changed. Use IntPtr.Zero if not needed.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.BitwiseOr(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Calculates per-element bit-wise logical or of two GpuMats:
            dst(I)=src1(I) | src2(I) if mask(I)!=0
            In the case of floating-point GpuMats their bit representations are used for the operation. All the GpuMats must have the same type, except the mask, and the same size
            </summary>
            <param name="src1">The first source GpuMat</param>
            <param name="src2">The second source GpuMat</param>
            <param name="dst">The destination GpuMat</param>
            <param name="mask">Mask, 8-bit single channel GpuMat; specifies elements of destination GpuMat to be changed. Use IntPtr.Zero if not needed.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.BitwiseAnd(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Calculates per-element bit-wise logical and of two GpuMats:
            dst(I)=src1(I) &amp; src2(I) if mask(I)!=0
            In the case of floating-point GpuMats their bit representations are used for the operation. All the GpuMats must have the same type, except the mask, and the same size
            </summary>
            <param name="src1">The first source GpuMat</param>
            <param name="src2">The second source GpuMat</param>
            <param name="dst">The destination GpuMat</param>
            <param name="mask">Mask, 8-bit single channel GpuMat; specifies elements of destination GpuMat to be changed. Use IntPtr.Zero if not needed.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.BitwiseNot(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Calculates per-element bit-wise logical not
            dst(I)=~src(I) if mask(I)!=0
            In the case of floating-point GpuMats their bit representations are used for the operation. All the GpuMats must have the same type, except the mask, and the same size
            </summary>
            <param name="src">The source GpuMat</param>
            <param name="dst">The destination GpuMat</param>
            <param name="mask">Mask, 8-bit single channel GpuMat; specifies elements of destination GpuMat to be changed. Use IntPtr.Zero if not needed.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Min(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes per-element minimum of two GpuMats (dst = min(src1, src2))
            </summary>
            <param name="src1">The first GpuMat</param>
            <param name="src2">The second GpuMat</param>
            <param name="dst">The result GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Max(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes per-element maximum of two GpuMats (dst = max(src1, src2))
            </summary>
            <param name="src1">The first GpuMat</param>
            <param name="src2">The second GpuMat</param>
            <param name="dst">The result GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Threshold(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,Emgu.CV.CvEnum.ThresholdType,Emgu.CV.Cuda.Stream)">
            <summary>
            Applies fixed-level thresholding to single-channel array. The function is typically used to get bi-level (binary) image out of grayscale image or for removing a noise, i.e. filtering out pixels with too small or too large values. There are several types of thresholding the function supports that are determined by thresholdType
            </summary>
            <param name="src">Source array (single-channel, 8-bit of 32-bit floating point). </param>
            <param name="dst">Destination array; must be either the same type as src or 8-bit. </param>
            <param name="threshold">Threshold value</param>
            <param name="maxValue">Maximum value to use with CV_THRESH_BINARY and CV_THRESH_BINARY_INV thresholding types</param>
            <param name="thresholdType">Thresholding type</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Gemm(Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Double,Emgu.CV.IInputArray,System.Double,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.GemmType,Emgu.CV.Cuda.Stream)">
            <summary>
            Performs generalized matrix multiplication:
            dst = alpha*op(src1)*op(src2) + beta*op(src3), where op(X) is X or XT
            </summary>
            <param name="src1">The first source array. </param>
            <param name="src2">The second source array. </param>
            <param name="alpha">The scalar</param>
            <param name="src3">The third source array (shift). Can be IntPtr.Zero, if there is no shift.</param>
            <param name="beta">The scalar</param>
            <param name="dst">The destination array.</param>
            <param name="tABC">The gemm operation type</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.WarpAffine(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar,Emgu.CV.Cuda.Stream)">
            <summary>
            Warps the image using affine transformation
            </summary>
            <param name="src">The source GpuMat</param>
            <param name="dst">The destination GpuMat</param>
            <param name="M">The 2x3 transformation matrix (pointer to CvArr)</param>
            <param name="flags">Supports NN, LINEAR, CUBIC</param>
            <param name="borderMode">The border mode, use BORDER_TYPE.CONSTANT for default.</param>
            <param name="borderValue">The border value, use new MCvScalar() for default.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
            <param name="dSize">The size of the destination image</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.WarpPerspective(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,System.Drawing.Size,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar,Emgu.CV.Cuda.Stream)">
            <summary>
            Warps the image using perspective transformation
            </summary>
            <param name="src">The source GpuMat</param>
            <param name="dst">The destination GpuMat</param>
            <param name="M">The 2x3 transformation matrix (pointer to CvArr)</param>
            <param name="flags">Supports NN, LINEAR, CUBIC</param>
            <param name="borderMode">The border mode, use BORDER_TYPE.CONSTANT for default.</param>
            <param name="borderValue">The border value, use new MCvScalar() for default.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
            <param name="dSize">The size of the destination image</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Remap(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.CvEnum.Inter,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar,Emgu.CV.Cuda.Stream)">
            <summary>
            DST[x,y] = SRC[xmap[x,y],ymap[x,y]] with bilinear interpolation.
            </summary>
            <param name="src">The source GpuMat. Supports CV_8UC1, CV_8UC3 source types. </param>
            <param name="dst">The dstination GpuMat. Supports CV_8UC1, CV_8UC3 source types. </param>
            <param name="xmap">The xmap. Supports CV_32FC1 map type.</param>
            <param name="ymap">The ymap. Supports CV_32FC1 map type.</param>
            <param name="interpolation">Interpolation type.</param>
            <param name="borderMode">Border mode. Use BORDER_CONSTANT for default.</param>
            <param name="borderValue">The value of the border.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Rotate(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Drawing.Size,System.Double,System.Double,System.Double,Emgu.CV.CvEnum.Inter,Emgu.CV.Cuda.Stream)">
            <summary>
            Rotates an image around the origin (0,0) and then shifts it.
            </summary>
            <param name="src">Source image. Supports 1, 3 or 4 channels images with Byte, UInt16 or float depth</param>
            <param name="dst">Destination image with the same type as src. Must be pre-allocated</param>
            <param name="angle">Angle of rotation in degrees</param>
            <param name="xShift">Shift along the horizontal axis</param>
            <param name="yShift">Shift along the verticle axis</param>
            <param name="dSize">The size of the destination image</param>
            <param name="interpolation">Interpolation method. Only INTER_NEAREST, INTER_LINEAR, and INTER_CUBIC are supported.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.CopyMakeBorder(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Int32,System.Int32,System.Int32,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar,Emgu.CV.Cuda.Stream)">
            <summary>
            Copies a 2D array to a larger destination array and pads borders with the given constant.
            </summary>
            <param name="src">Source image.</param>
            <param name="dst">Destination image with the same type as src. The size is Size(src.cols+left+right, src.rows+top+bottom).</param>
            <param name="top">Number of pixels in each direction from the source image rectangle to extrapolate.</param>
            <param name="bottom">Number of pixels in each direction from the source image rectangle to extrapolate.</param>
            <param name="left">Number of pixels in each direction from the source image rectangle to extrapolate.</param>
            <param name="right">Number of pixels in each direction from the source image rectangle to extrapolate.</param>
            <param name="borderType">Border Type</param>
            <param name="value">Border value.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Integral(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes the integral image and integral for the squared image
            </summary>
            <param name="src">The source GpuMat, supports only CV_8UC1 source type</param>
            <param name="sum">The sum GpuMat, supports only CV_32S source type, but will contain unsigned int values</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.SqrIntegral(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes squared integral image 
            </summary>
            <param name="src">The source GpuMat, supports only CV_8UC1 source type</param>
            <param name="sqsum">The sqsum GpuMat, supports only CV32F source type.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Dft(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Drawing.Size,Emgu.CV.CvEnum.DxtType,Emgu.CV.Cuda.Stream)">
             <summary>
             Performs a forward or inverse discrete Fourier transform (1D or 2D) of floating point matrix.
             Param dft_size is the size of DFT transform.
             
             If the source matrix is not continous, then additional copy will be done,
             so to avoid copying ensure the source matrix is continous one. If you want to use
             preallocated output ensure it is continuous too, otherwise it will be reallocated.
            
             Being implemented via CUFFT real-to-complex transform result contains only non-redundant values
             in CUFFT's format. Result as full complex matrix for such kind of transform cannot be retrieved.
            
             For complex-to-real transform it is assumed that the source matrix is packed in CUFFT's format.
             </summary>
             <param name="src">The source GpuMat</param>
             <param name="dst">The resulting GpuMat of the DST, must be pre-allocated and continious. If single channel, the result is real. If double channel, the result is complex</param>
             <param name="dftSize">Size of a discrete Fourier transform.</param>
             <param name="flags">DFT flags</param>
             <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.MulAndScaleSpectrums(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Single,System.Boolean,Emgu.CV.Cuda.Stream)">
            <summary>
            Performs a per-element multiplication of two Fourier spectrums and scales the result.
            </summary>
            <param name="src1">First spectrum.</param>
            <param name="src2">Second spectrum with the same size and type.</param>
            <param name="dst">Destination spectrum.</param>
            <param name="flags">Mock parameter used for CPU/CUDA interfaces similarity, simply add a 0 value.</param>
            <param name="scale">Scale constant.</param>
            <param name="conjB">Optional flag to specify if the second spectrum needs to be conjugated before the multiplication.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.MulSpectrums(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Boolean,Emgu.CV.Cuda.Stream)">
            <summary>
            Performs a per-element multiplication of two Fourier spectrums.
            </summary>
            <param name="src1">First spectrum.</param>
            <param name="src2">Second spectrum with the same size and type.</param>
            <param name="dst">Destination spectrum.</param>
            <param name="flags">Mock parameter used for CPU/CUDA interfaces similarity.</param>
            <param name="conjB">Optional flag to specify if the second spectrum needs to be conjugated before the multiplication.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.gpuMatRelease(System.IntPtr@)">
            <summary>
            Release the GpuMat
            </summary>
            <param name="mat">Pointer to the GpuMat</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.gpuMatCreateDefault">
            <summary>
            Create an empty GpuMat 
            </summary>
            <returns>Pointer to an empty GpuMat</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.gpuMatCreateFromInputArray(System.IntPtr)">
            <summary>
            Convert a CvArr to a GpuMat
            </summary>
            <param name="arr">Pointer to a CvArr</param>
            <returns>Pointer to the GpuMat</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.gpuMatGetSize(System.IntPtr,System.Drawing.Size@)">
            <summary>
            Get the GpuMat size:
            width == number of columns, height == number of rows
            </summary>
            <param name="gpuMat">The GpuMat</param>
            <param name="size">The size of the matrix</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.gpuMatGetType(System.IntPtr)">
            <summary>
            Get the GpuMat type
            </summary>
            <param name="gpuMat">The GpuMat</param>
            <returns>The GpuMat type</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.gpuMatCreate(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a GpuMat of the specified size
            </summary>
            <param name="mat">Pointer to the native cv::Mat</param>
            <param name="rows">The number of rows (height)</param>
            <param name="cols">The number of columns (width)</param>
            <param name="type">The type of GpuMat</param>
            <returns>Pointer to the GpuMat</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.gpuMatCreateContinuous(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a GpuMat of the specified size. The allocated data is continuous within this GpuMat.
            </summary>
            <param name="rows">The number of rows (height)</param>
            <param name="cols">The number of columns (width)</param>
            <param name="type">The type of GpuMat</param>
            <returns>Pointer to the GpuMat</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.gpuMatUpload(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Performs blocking upload data to GpuMat.
            </summary>
            <param name="gpuMat">The destination gpuMat</param>
            <param name="arr">The CvArray to be uploaded to GPU</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.gpuMatDownload(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Downloads data from device to host memory. Blocking calls.
            </summary>
            <param name="gpuMat">The source GpuMat</param>
            <param name="arr">The CvArray where data will be downloaded to</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.gpuMatCopyTo(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Copy the source GpuMat to destination GpuMat, using an optional mask.
            </summary>
            <param name="src">The GpuMat to be copied from</param>
            <param name="dst">The GpuMat to be copied to</param>
            <param name="mask">The optional mask, use IntPtr.Zero if not needed.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.gpuMatConvertTo(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.DepthType,System.Double,System.Double,System.IntPtr)">
            <summary>
            This function has several different purposes and thus has several synonyms. It copies one GpuMat to another with optional scaling, which is performed first, and/or optional type conversion, performed after:
            dst(I)=src(I)*scale + (shift,shift,...)
            All the channels of multi-channel GpuMats are processed independently.
            The type conversion is done with rounding and saturation, that is if a result of scaling + conversion can not be represented exactly by a value of destination GpuMat element type, it is set to the nearest representable value on the real axis.
            In case of scale=1, shift=0 no prescaling is done. This is a specially optimized case and it has the appropriate convertTo synonym.
            </summary>
            <param name="src">Source GpuMat</param>
            <param name="dst">Destination GpuMat</param>
            <param name="rtype">The depth type of the destination GpuMat</param>
            <param name="scale">Scale factor</param>
            <param name="shift">Value added to the scaled source GpuMat elements</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>      
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.gpuMatReshape(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Changes shape of GpuMat without copying data.
            </summary>
            <param name="src">The GpuMat to be reshaped.</param>
            <param name="dst">The result GpuMat.</param>
            <param name="newCn">New number of channels. newCn = 0 means that the number of channels remains unchanged.</param>
            <param name="newRows">New number of rows. newRows = 0 means that the number of rows remains unchanged unless it needs to be changed according to newCn value.</param>
            <returns>A GpuMat of different shape</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.CvtColor(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.ColorConversion,System.Int32,Emgu.CV.Cuda.Stream)">
            <summary>
            Converts image from one color space to another
            </summary>
            <param name="src">The source GpuMat</param>
            <param name="dst">The destination GpuMat</param>
            <param name="code">The color conversion code</param>
            <param name="dcn">Number of channels in the destination image. If the parameter is 0, the number of the channels is derived automatically from src and the code .</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Demosaicing(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.DemosaicTypes,System.Int32,Emgu.CV.Cuda.Stream)">
            <summary>
            Converts an image from Bayer pattern to RGB or grayscale.
            </summary>
            <param name="src">Source image (8-bit or 16-bit single channel).</param>
            <param name="dst">Destination image.</param>
            <param name="code">Color space conversion code (see the description below).</param>
            <param name="dcn">Number of channels in the destination image. If the parameter is 0, the number of the channels is derived automatically from src and the code .</param>
            <param name="stream">Stream for the asynchronous version.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.SwapChannels(Emgu.CV.IInputOutputArray,System.Int32[],Emgu.CV.Cuda.Stream)">
            <summary>
            Swap channels.
            </summary>
            <param name="src">The image where the channels will be swapped</param>
            <param name="dstOrder">
            Integer array describing how channel values are permutated. The n-th entry
            of the array contains the number of the channel that is stored in the n-th channel of
            the output image. E.g. Given an RGBA image, aDstOrder = [3,2,1,0] converts this to ABGR
            channel order.
            </param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.GammaCorrection(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Boolean,Emgu.CV.Cuda.Stream)">
            <summary>
            Routines for correcting image color gamma
            </summary>
            <param name="src">Source image (3- or 4-channel 8 bit).</param>
            <param name="dst">Destination image.</param>
            <param name="forward">True for forward gamma correction or false for inverse gamma correction.</param>
            <param name="stream">Stream for the asynchronous version.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.AlphaComp(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.AlphaCompTypes,Emgu.CV.Cuda.Stream)">
            <summary>
            Composites two images using alpha opacity values contained in each image.
            </summary>
            <param name="img1">First image. Supports CV_8UC4 , CV_16UC4 , CV_32SC4 and CV_32FC4 types.</param>
            <param name="img2">Second image. Must have the same size and the same type as img1 .</param>
            <param name="dst">Destination image</param>
            <param name="alphaOp">Flag specifying the alpha-blending operation</param>
            <param name="stream">Stream for the asynchronous version</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.CalcHist(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Calculates histogram for one channel 8-bit image.
            </summary>
            <param name="src">Source image with CV_8UC1 type.</param>
            <param name="hist">Destination histogram with one row, 256 columns, and the CV_32SC1 type.</param>
            <param name="stream">tream for the asynchronous version.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.EqualizeHist(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Equalizes the histogram of a grayscale image.
            </summary>
            <param name="src">Source image with CV_8UC1 type.</param>
            <param name="dst">Destination image.</param>
            <param name="stream">Stream for the asynchronous version.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.HistEven(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Int32,System.Int32,Emgu.CV.Cuda.Stream)">
            <summary>
            Calculates histogram with evenly distributed bins for single channel source.
            </summary>
            <param name="src">The source GpuMat. Supports CV_8UC1, CV_16UC1 and CV_16SC1 types.</param>
            <param name="hist">Histogram with evenly distributed bins. A GpuMat&lt;int&gt; type.</param>
            <param name="histSize">The size of histogram (number of levels)</param>                                                                                                                                                                                                                                                             
            <param name="lowerLevel">The lower level</param>
            <param name="upperLevel">The upper level</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
            <returns>Histogram with evenly distributed bins</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.HistRange(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Calculates a histogram with bins determined by the levels array
            </summary>
            <param name="src">Source image. CV_8U , CV_16U , or CV_16S depth and 1 or 4 channels are supported. For a four-channel image, all channels are processed separately.</param>
            <param name="hist">Destination histogram with one row, (levels.cols-1) columns, and the CV_32SC1 type.</param>
            <param name="levels">Number of levels in the histogram.</param>
            <param name="stream">Stream for the asynchronous version.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.BlendLinear(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Performs linear blending of two images.
            </summary>
            <param name="img1">First image. Supports only CV_8U and CV_32F depth.</param>
            <param name="img2">Second image. Must have the same size and the same type as img1 .</param>
            <param name="weights1">Weights for first image. Must have tha same size as img1. Supports only CV_32F type.</param>
            <param name="weights2">Weights for second image. Must have tha same size as img2. Supports only CV_32F type.</param>
            <param name="result">Destination image.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.BilateralFilter(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Single,System.Single,Emgu.CV.CvEnum.BorderType,Emgu.CV.Cuda.Stream)">
            <summary>
            Applies bilateral filter to the image.
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image; should have the same size and the same type as src</param>
            <param name="kernelSize">The diameter of each pixel neighborhood, that is used during filtering.</param>
            <param name="sigmaColor">Filter sigma in the color space. Larger value of the parameter means that farther colors within the pixel neighborhood (see sigmaSpace) will be mixed together, resulting in larger areas of semi-equal color</param>
            <param name="sigmaSpatial">Filter sigma in the coordinate space. Larger value of the parameter means that farther pixels will influence each other (as long as their colors are close enough; see sigmaColor). Then d&gt;0, it specifies the neighborhood size regardless of sigmaSpace, otherwise d is proportional to sigmaSpace.</param>
            <param name="borderType">Pixel extrapolation method, use DEFAULT for default</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.MeanShiftFiltering(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Int32,Emgu.CV.Structure.MCvTermCriteria,Emgu.CV.Cuda.Stream)">
            <summary>
            Performs mean-shift filtering for each point of the source image. It maps each point of the source
            image into another point, and as the result we have new color and new position of each point.
            </summary>
            <param name="src">Source CudaImage. Only CV 8UC4 images are supported for now.</param>
            <param name="dst">Destination CudaImage, containing color of mapped points. Will have the same size and type as src.</param>
            <param name="sp">Spatial window radius.</param>
            <param name="sr">Color window radius.</param>
            <param name="criteria">Termination criteria.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.MeanShiftProc(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Int32,System.Int32,Emgu.CV.Structure.MCvTermCriteria,Emgu.CV.Cuda.Stream)">
            <summary>
            Performs mean-shift procedure and stores information about processed points (i.e. their colors
            and positions) into two images.
            </summary>
            <param name="src">Source CudaImage. Only CV 8UC4 images are supported for now.</param>
            <param name="dstr">Destination CudaImage, containing color of mapped points. Will have the same size and type as src.</param>
            <param name="dstsp">Destination CudaImage, containing position of mapped points. Will have the same size as src and CV 16SC2 type.</param>
            <param name="sp">Spatial window radius.</param>
            <param name="sr">Color window radius.</param>
            <param name="criteria">Termination criteria.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.MeanShiftSegmentation(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Int32,System.Int32,Emgu.CV.Structure.MCvTermCriteria,Emgu.CV.Cuda.Stream)">
            <summary>
            Performs mean-shift segmentation of the source image and eleminates small segments.
            </summary>
            <param name="src">Source CudaImage. Only CV 8UC4 images are supported for now.</param>
            <param name="dst">Segmented Image. Will have the same size and type as src. Note that this is an Image type and not CudaImage type</param>
            <param name="sp">Spatial window radius.</param>
            <param name="sr">Color window radius.</param>
            <param name="minSize">Minimum segment size. Smaller segements will be merged.</param>
            <param name="criteria">Termination criteria.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.cudaTemplateMatchingMatch(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            This function is similiar to cvCalcBackProjectPatch. It slids through image, compares overlapped patches of size wxh with templ using the specified method and stores the comparison results to result
            </summary>
            <param name="image">Image where the search is running. It should be 8-bit or 32-bit floating-point</param>
            <param name="templ">Searched template; must be not greater than the source image and the same data type as the image</param>
            <param name="result">A map of comparison results; single-channel 32-bit floating-point. If image is WxH and templ is wxh then result must be W-w+1xH-h+1.</param>
            <param name="tm">Pointer to cv::gpu::TemplateMatching</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Calc(Emgu.CV.Cuda.ICudaDenseOpticalFlow,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Calculates a dense optical flow.
            </summary>
            <param name="denseFlow">The dense optical flow object</param>
            <param name="i0">first input image.</param>
            <param name="i1">second input image of the same size and the same type as <paramref name="i0"/>.</param>
            <param name="flow">computed flow image that has the same size as I0 and type CV_32FC2.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaInvoke.Calc(Emgu.CV.Cuda.ICudaSparseOpticalFlow,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Calculates a sparse optical flow.
            </summary>
            <param name="sparseFlow">The sparse optical flow</param>
            <param name="prevImg">First input image.</param>
            <param name="nextImg">Second input image of the same size and the same type as <paramref name="prevImg"/>.</param>
            <param name="prevPts">Vector of 2D points for which the flow needs to be found.</param>
            <param name="nextPts">Output vector of 2D points containing the calculated new positions of input features in the second image.</param>
            <param name="status">Output status vector. Each element of the vector is set to 1 if the flow for the corresponding features has been found. Otherwise, it is set to 0.</param>
            <param name="err">Optional output vector that contains error response for each point (inverse confidence).</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaInvoke.HasCuda">
            <summary>
            Return true if Cuda is found on the system
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaBackgroundSubtractorMOG2">
            <summary>
            Gaussian Mixture-based Background/Foreground Segmentation Algorithm.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBackgroundSubtractorMOG2.#ctor(System.Int32,System.Double,System.Boolean)">
            <summary>
            Create a Gaussian Mixture-based Background/Foreground Segmentation model
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBackgroundSubtractorMOG2.Update(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,Emgu.CV.Cuda.Stream)">
            <summary>
            Updates the background model
            </summary>
            <param name="frame">Next video frame.</param>
            <param name="fgmask">The output forground mask</param>
            <param name="learningRate">The learning rate, use -1.0f for default value.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBackgroundSubtractorMOG2.DisposeObject">
            <summary>
            Release all the unmanaged resource associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaClahe">
            <summary>
            Contrast Limited Adaptive Histogram Equalization
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaClahe.#ctor(System.Double,System.Drawing.Size)">
            <summary>
            Create the Contrast Limited Adaptive Histogram Equalization
            </summary>
            <param name="clipLimit">Threshold for contrast limiting. Use 40.0 for default</param>
            <param name="tileGridSize">Size of grid for histogram equalization. Input image will be divided into equally sized rectangular tiles. This parameter defines the number of tiles in row and column. Use (8, 8) for default</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaClahe.Apply(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Equalizes the histogram of a grayscale image using Contrast Limited Adaptive Histogram Equalization.
            </summary>
            <param name="source">Source image</param>
            <param name="dst">Destination image</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaClahe.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaDeviceInfo">
            <summary>
            The Cuda device information
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaDeviceInfo.#ctor">
            <summary>
            Query the information of the gpu device that is currently in use.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaDeviceInfo.#ctor(System.Int32)">
            <summary>
            Query the information of the cuda device with the specific id.
            </summary>
            <param name="deviceId">The device id</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaDeviceInfo.Supports(Emgu.CV.Cuda.CudaDeviceInfo.GpuFeature)">
            <summary>
            Indicates if the decive has the specific feature
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaDeviceInfo.DisposeObject">
            <summary>
            Release the unmanaged resource related to the GpuDevice
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaDeviceInfo.ID">
            <summary>
            The id of the device
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaDeviceInfo.Name">
            <summary>
            The name of the device
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaDeviceInfo.CudaComputeCapability">
            <summary>
            The compute capability
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaDeviceInfo.MultiProcessorCount">
            <summary>
            The number of single multi processors
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaDeviceInfo.FreeMemory">
            <summary>
            Get the amount of free memory at the moment
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaDeviceInfo.TotalMemory">
            <summary>
            Get the amount of total memory
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaDeviceInfo.IsCompatible">
            <summary>
            Checks whether the Cuda module can be run on the given device
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaDeviceInfo.GpuFeature">
            <summary>
            GPU feature
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.CudaDeviceInfo.GpuFeature.Compute10">
            <summary>
            Cuda compute 1.0
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.CudaDeviceInfo.GpuFeature.Compute11">
            <summary>
            Cuda compute 1.1
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.CudaDeviceInfo.GpuFeature.Compute12">
            <summary>
            Cuda compute 1.2
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.CudaDeviceInfo.GpuFeature.Compute13">
            <summary>
            Cuda compute 1.3
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.CudaDeviceInfo.GpuFeature.Compute20">
            <summary>
            Cuda compute 2.0
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.CudaDeviceInfo.GpuFeature.Compute21">
            <summary>
            Cuda compute 2.1
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.CudaDeviceInfo.GpuFeature.GlobalAtomics">
            <summary>
            Global Atomic
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.CudaDeviceInfo.GpuFeature.SharedAtomics">
            <summary>
            Shared Atomic
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.CudaDeviceInfo.GpuFeature.NativeDouble">
            <summary>
            Native double
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaImage`2">
            <summary>
            An CudaImage is very similar to the Emgu.CV.Image except that it is being used for GPU processing
            </summary>
            <typeparam name="TColor">Color type of this image (either Gray, Bgr, Bgra, Hsv, Hls, Lab, Luv, Xyz, Ycc, Rgb or Rbga)</typeparam>
            <typeparam name="TDepth">Depth of this image (either Byte, SByte, Single, double, UInt16, Int16 or Int32)</typeparam>
        </member>
        <member name="T:Emgu.CV.Cuda.GpuMat`1">
            <summary>
            Similar to CvArray but use GPU for processing
            </summary>
            <typeparam name="TDepth">The type of element in the matrix</typeparam>
        </member>
        <member name="T:Emgu.CV.Cuda.GpuMat">
            <summary>
            A GpuMat, use the generic version if possible. The non generic version is good for use as buffer in stream calls.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.#ctor">
            <summary>
            Create an empty GpuMat
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.#ctor(System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32,System.Boolean)">
            <summary>
            Create a GpuMat of the specified size
            </summary>
            <param name="rows">The number of rows (height)</param>
            <param name="cols">The number of columns (width)</param>
            <param name="channels">The number of channels</param>
            <param name="depthType">The type of depth</param>
            <param name="continuous">Indicates if the data should be continuous</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.Create(System.Int32,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32)">
            <summary>
            allocates new GpuMat data unless the GpuMat already has specified size and type
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of cols</param>
            <param name="depthType">The depth type</param>
            <param name="channels">The number of channels.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Create a GpuMat from the specific pointer
            </summary>
            <param name="ptr">Pointer to the unmanaged gpuMat</param>
            <param name="needDispose">True if we need to call Release function to <paramref name="ptr"/> during object disposal</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.#ctor(Emgu.CV.IInputArray)">
            <summary>
            Create a GpuMat from an CvArray of the same depth type
            </summary>
            <param name="arr">The CvArry to be converted to GpuMat</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.#ctor(Emgu.CV.Cuda.GpuMat,Emgu.CV.Structure.Range,Emgu.CV.Structure.Range)">
            <summary>
            Create a GpuMat from the specific region of <paramref name="mat"/>. The data is shared between the two GpuMat
            </summary>
            <param name="mat">The matrix where the region is extracted from</param>
            <param name="colRange">The column range.</param>
            <param name="rowRange">The row range.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this GpuMat
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.GetInputArray">
            <summary>
            Pointer to the InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.GetOutputArray">
            <summary>
            Pointer to the OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.GetInputOutputArray">
            <summary>
            Pointer to the InputOutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.Upload(Emgu.CV.IInputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Upload data to GpuMat
            </summary>
            <param name="arr">The CvArray to be uploaded to GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>     
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.Download(Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Downloads data from device to host memory. 
            </summary>
            <param name="arr">The destination CvArray where the GpuMat data will be downloaded to.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>     
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.ToMat">
            <summary>
            Convert the GpuMat to Mat
            </summary>
            <returns>The Mat that contains the same data as this GpuMat</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.SetTo(Emgu.CV.Structure.MCvScalar,Emgu.CV.IInputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Copies scalar value to every selected element of the destination GpuMat:
            arr(I)=value if mask(I)!=0
            </summary>
            <param name="value">Fill value</param>
            <param name="mask">Operation mask, 8-bit single channel GpuMat; specifies elements of destination GpuMat to be changed. Can be IntPtr.Zero if not used</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>     
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.CopyTo(Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Copy the source GpuMat to destination GpuMat, using an optional mask.
            </summary>
            <param name="dst">The output array to be copied to</param>
            <param name="mask">The optional mask, use IntPtr.Zero if not needed.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.ConvertTo(Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType,System.Double,System.Double,Emgu.CV.Cuda.Stream)">
            <summary>
            This function has several different purposes and thus has several synonyms. It copies one GpuMat to another with optional scaling, which is performed first, and/or optional type conversion, performed after:
            dst(I)=src(I)*scale + (shift,shift,...)
            All the channels of multi-channel GpuMats are processed independently.
            The type conversion is done with rounding and saturation, that is if a result of scaling + conversion can not be represented exactly by a value of destination GpuMat element type, it is set to the nearest representable value on the real axis.
            In case of scale=1, shift=0 no prescaling is done. This is a specially optimized case and it has the appropriate convertTo synonym.
            </summary>
            <param name="dst">Destination GpuMat</param>
            <param name="rtype">Result type</param>
            <param name="scale">Scale factor</param>
            <param name="shift">Value added to the scaled source GpuMat elements</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>      
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.Reshape(System.Int32,System.Int32)">
            <summary>
            Changes shape of GpuMat without copying data.
            </summary>
            <param name="newCn">New number of channels. newCn = 0 means that the number of channels remains unchanged.</param>
            <param name="newRows">New number of rows. newRows = 0 means that the number of rows remains unchanged unless it needs to be changed according to newCn value.</param>
            <returns>A GpuMat of different shape</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.Row(System.Int32)">
            <summary>
            Returns a GpuMat corresponding to the ith row of the GpuMat. The data is shared with the current GpuMat. 
            </summary>
            <param name="i">The row to be extracted</param>
            <returns>The ith row of the GpuMat</returns>
            <remarks>The parent GpuMat should never be released before the returned GpuMat that represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.RowRange(System.Int32,System.Int32)">
            <summary>
            Returns a GpuMat corresponding to the [<paramref name="start"/> <paramref name="end"/>) rows of the GpuMat. The data is shared with the current GpuMat. 
            </summary>
            <param name="start">The inclusive stating row to be extracted</param>
            <param name="end">The exclusive ending row to be extracted</param>
            <returns>The [<paramref name="start"/> <paramref name="end"/>) rows of the GpuMat</returns>
            <remarks>The parent GpuMat should never be released before the returned GpuMat that represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.Col(System.Int32)">
            <summary>
            Returns a GpuMat corresponding to the ith column of the GpuMat. The data is shared with the current GpuMat. 
            </summary>
            <param name="i">The column to be extracted</param>
            <returns>The ith column of the GpuMat</returns>
            <remarks>The parent GpuMat should never be released before the returned GpuMat that represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.ColRange(System.Int32,System.Int32)">
            <summary>
            Returns a GpuMat corresponding to the [<paramref name="start"/> <paramref name="end"/>) columns of the GpuMat. The data is shared with the current GpuMat. 
            </summary>
            <param name="start">The inclusive stating column to be extracted</param>
            <param name="end">The exclusive ending column to be extracted</param>
            <returns>The [<paramref name="start"/> <paramref name="end"/>) columns of the GpuMat</returns>
            <remarks>The parent GpuMat should never be released before the returned GpuMat that represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.Equals(Emgu.CV.Cuda.GpuMat)">
            <summary>
            Returns true if the two GpuMat equals
            </summary>
            <param name="other">The other GpuMat to be compares with</param>
            <returns>True if the two GpuMat equals</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.MergeFrom(Emgu.CV.Cuda.GpuMat[],Emgu.CV.Cuda.Stream)">
             <summary>
             Makes multi-channel array out of several single-channel arrays
             </summary>
            <param name="gpuMats"> 
            An array of single channel GpuMat where each item
            in the array represent a single channel of the GpuMat 
            </param>
             <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.SplitInto(Emgu.CV.Cuda.GpuMat[],Emgu.CV.Cuda.Stream)">
            <summary> 
            Split current Image into an array of gray scale images where each element 
            in the array represent a single color channel of the original image
            </summary>
            <param name="gpuMats"> 
            An array of single channel GpuMat where each item
            in the array represent a single channel of the original GpuMat 
            </param>
             <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.Split(Emgu.CV.Cuda.Stream)">
            <summary> 
            Split current GpuMat into an array of single channel GpuMat where each element 
            in the array represent a single channel of the original GpuMat
            </summary>
             <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
            <returns> 
            An array of single channel GpuMat where each element  
            in the array represent a single channel of the original GpuMat 
            </returns>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.MinMax(System.Double[]@,System.Double[]@,System.Drawing.Point[]@,System.Drawing.Point[]@)">
            <summary>
            Returns the min / max location and values for the image
            </summary>
            <param name="maxLocations">The maximum locations for each channel </param>
            <param name="maxValues">The maximum values for each channel</param>
            <param name="minLocations">The minimum locations for each channel</param>
            <param name="minValues">The minimum values for each channel</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.Save(System.String)">
            <summary>
            Save the GpuMat to a file
            </summary>
            <param name="fileName">The file name</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat.Clone">
            <summary>
            Make a clone of the GpuMat
            </summary>
            <returns>A clone of the GPU Mat</returns>
        </member>
        <member name="P:Emgu.CV.Cuda.GpuMat.Size">
            <summary>
            Get the GpuMat size:
            width == number of columns, height == number of rows
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.GpuMat.Type">
            <summary>
            Get the type of the GpuMat
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.GpuMat.Bitmap">
            <summary>
            Get the Bitmap from this GpuMat
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.GpuMat.IsContinuous">
            <summary>
            True if the data is continues
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.GpuMat.Depth">
            <summary>
            Depth type
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.GpuMat.IsEmpty">
            <summary>
            True if the matrix is empty
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.GpuMat.NumberOfChannels">
            <summary>
            Number of channels
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat`1.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Create a GpuMat from the unmanaged pointer
            </summary>
            <param name="ptr">The unmanaged pointer to the GpuMat</param>
            <param name="needDispose">If true, will call the release function on the <paramref name="ptr"/></param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat`1.#ctor">
            <summary>
            Create an empty GpuMat
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat`1.#ctor(Emgu.CV.IInputArray)">
            <summary>
            Create a GpuMat from an CvArray of the same depth type
            </summary>
            <param name="arr">The CvArry to be converted to GpuMat</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat`1.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create a GpuMat of the specified size
            </summary>
            <param name="rows">The number of rows (height)</param>
            <param name="cols">The number of columns (width)</param>
            <param name="channels">The number of channels</param>
            <param name="continuous">Indicates if the data should be continuous</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat`1.#ctor(System.Drawing.Size,System.Int32)">
            <summary>
            Create a GpuMat of the specified size
            </summary>
            <param name="size">The size of the GpuMat</param>
            <param name="channels">The number of channels</param>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat`1.ToMatrix">
            <summary>
            Convert this GpuMat to a Matrix
            </summary>
            <returns>The matrix that contains the same values as this GpuMat</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.GpuMat`1.GetSubRect(System.Drawing.Rectangle)">
            <summary>
            Returns a GpuMat corresponding to a specified rectangle of the current GpuMat. The data is shared with the current matrix. In other words, it allows the user to treat a rectangular part of input array as a stand-alone array.
            </summary>
            <param name="region">Zero-based coordinates of the rectangle of interest.</param>
            <returns>A GpuMat that represent the region of the current matrix.</returns>
            <remarks>The parent GpuMat should never be released before the returned GpuMat the represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.#ctor">
            <summary>
            Create an empty CudaImage
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Create the CudaImage from the unmanaged pointer.
            </summary>
            <param name="ptr">The unmanaged pointer to the GpuMat. It is the user's responsibility that the Color type and depth matches between the managed class and unmanaged pointer.</param>
            <param name="needDispose">if true, unpon object disposal, we will cann the release function on the unmanaged <paramref name="ptr"/></param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.#ctor(Emgu.CV.IInputArray)">
            <summary>
            Create a GPU image from a regular image
            </summary>
            <param name="img">The image to be converted to GPU image</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.#ctor(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create a CudaImage of the specific size
            </summary>
            <param name="rows">The number of rows (height)</param>
            <param name="cols">The number of columns (width)</param>
            <param name="continuous">Indicates if the data should be continuous</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a CudaImage of the specific size
            </summary>
            <param name="rows">The number of rows (height)</param>
            <param name="cols">The number of columns (width)</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.#ctor(System.Drawing.Size)">
            <summary>
            Create a CudaImage of the specific size
            </summary>
            <param name="size">The size of the image</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.#ctor(Emgu.CV.Cuda.CudaImage{`0,`1},Emgu.CV.Structure.Range,Emgu.CV.Structure.Range)">
            <summary>
            Create a CudaImage from the specific region of <paramref name="image"/>. The data is shared between the two CudaImage
            </summary>
            <param name="image">The CudaImage where the region is extracted from</param>
            <param name="colRange">The column range. Use MCvSlice.WholeSeq for all columns.</param>
            <param name="rowRange">The row range. Use MCvSlice.WholeSeq for all rows.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.ToImage">
            <summary>
            Convert the current CudaImage to a regular Image.
            </summary>
            <returns>A regular image</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.Convert``2">
            <summary> Convert the current CudaImage to the specific color and depth </summary>
            <typeparam name="TOtherColor"> The type of color to be converted to </typeparam>
            <typeparam name="TOtherDepth"> The type of pixel depth to be converted to </typeparam>
            <returns>CudaImage of the specific color and depth </returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.ConvertFrom``2(Emgu.CV.Cuda.CudaImage{``0,``1})">
            <summary>
            Convert the source image to the current image, if the size are different, the current image will be a resized version of the srcImage. 
            </summary>
            <typeparam name="TSrcColor">The color type of the source image</typeparam>
            <typeparam name="TSrcDepth">The color depth of the source image</typeparam>
            <param name="srcImage">The sourceImage</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.Clone(Emgu.CV.Cuda.Stream)">
            <summary>
            Create a clone of this CudaImage
            </summary>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
            <returns>A clone of this CudaImage</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.Resize(System.Drawing.Size,Emgu.CV.CvEnum.Inter,Emgu.CV.Cuda.Stream)">
            <summary>
            Resize the CudaImage. The calling GpuMat be GpuMat%lt;Byte&gt;. If stream is specified, it has to be either 1 or 4 channels.
            </summary>
            <param name="size">The new size</param>
            <param name="interpolationType">The interpolation type</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
            <returns>A CudaImage of the new size</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.GetSubRect(System.Drawing.Rectangle)">
            <summary>
            Returns a CudaImage corresponding to a specified rectangle of the current CudaImage. The data is shared with the current matrix. In other words, it allows the user to treat a rectangular part of input array as a stand-alone array.
            </summary>
            <param name="region">Zero-based coordinates of the rectangle of interest.</param>
            <returns>A CudaImage that represent the region of the current CudaImage.</returns>
            <remarks>The parent CudaImage should never be released before the returned CudaImage that represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.Row(System.Int32)">
            <summary>
            Returns a CudaImage corresponding to the ith row of the CudaImage. The data is shared with the current Image. 
            </summary>
            <param name="i">The row to be extracted</param>
            <returns>The ith row of the CudaImage</returns>
            <remarks>The parent CudaImage should never be released before the returned CudaImage that represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.RowRange(System.Int32,System.Int32)">
            <summary>
            Returns a CudaImage corresponding to the [<paramref name="start"/> <paramref name="end"/>) rows of the CudaImage. The data is shared with the current Image. 
            </summary>
            <param name="start">The inclusive stating row to be extracted</param>
            <param name="end">The exclusive ending row to be extracted</param>
            <returns>The [<paramref name="start"/> <paramref name="end"/>) rows of the CudaImage</returns>
            <remarks>The parent CudaImage should never be released before the returned CudaImage that represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.Col(System.Int32)">
            <summary>
            Returns a CudaImage corresponding to the ith column of the CudaImage. The data is shared with the current Image. 
            </summary>
            <param name="i">The column to be extracted</param>
            <returns>The ith column of the CudaImage</returns>
            <remarks>The parent CudaImage should never be released before the returned CudaImage that represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaImage`2.ColRange(System.Int32,System.Int32)">
            <summary>
            Returns a CudaImage corresponding to the [<paramref name="start"/> <paramref name="end"/>) columns of the CudaImage. The data is shared with the current Image. 
            </summary>
            <param name="start">The inclusive stating column to be extracted</param>
            <param name="end">The exclusive ending column to be extracted</param>
            <returns>The [<paramref name="start"/> <paramref name="end"/>) columns of the CudaImage</returns>
            <remarks>The parent CudaImage should never be released before the returned CudaImage that represent the subregion</remarks>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaImage`2.Bitmap">
            <summary>
            convert the current CudaImage to its equivalent Bitmap representation
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaLookUpTable">
            <summary>
            Gpu look up table
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaLookUpTable.#ctor(Emgu.CV.IInputArray)">
            <summary>
            Create the look up table
            </summary>
            <param name="lookUpTable">It should be either 1 or 3 channel matrix of 1x256</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaLookUpTable.Transform(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Transform the image using the lookup table
            </summary>
            <param name="image">The image to be transformed</param>
            <param name="dst">The transformation result</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaLookUpTable.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this look up table
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.DescriptorMatcher">
            <summary>
            Descriptor matcher
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.DescriptorMatcher._algorithmPtr">
            <summary>
            Pointer to the native cv::Algorithm
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.DescriptorMatcher.KnnMatch(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfVectorOfDMatch,System.Int32,Emgu.CV.IInputArray,System.Boolean)">
            <summary>
            Find the k-nearest match
            </summary>
            <param name="queryDescriptors">An n x m matrix of descriptors to be query for nearest neighbors. n is the number of descriptor and m is the size of the descriptor</param>
            <param name="k">Number of nearest neighbors to search for</param>
            <param name="mask">Can be null if not needed. An n x 1 matrix. If 0, the query descriptor in the corresponding row will be ignored.</param>
            <param name="matches">Matches. Each matches[i] is k or less matches for the same query descriptor.</param>
            <param name="compactResult">Parameter used when the mask (or masks) is not empty. If compactResult is false, the matches vector has the same size as queryDescriptors rows. If compactResult is true, the matches vector does not contain matches for fully masked-out query descriptors.</param>
            <param name="trainDescriptors">Train set of descriptors. This set is not added to the train descriptors collection stored in the class object.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.DescriptorMatcher.Add(Emgu.CV.IInputArray)">
            <summary>
            Add the model descriptors
            </summary>
            <param name="modelDescriptors">The model descriptors</param>
        </member>
        <member name="M:Emgu.CV.Cuda.DescriptorMatcher.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this matcher
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaBFMatcher">
            <summary>
            A Brute force matcher using Cuda
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBFMatcher.#ctor(Emgu.CV.Features2D.DistanceType)">
            <summary>
            Create a CudaBruteForceMatcher using the specific distance type
            </summary>
            <param name="distanceType">The distance type</param>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaFastFeatureDetector">
            <summary>
            A FAST detector using Cuda
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.IFeature2DAsync">
            <summary>
            The feature 2D base class
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.IFeature2DAsync.Feature2DAsyncPtr">
            <summary>
            Get the pointer to the Feature2DAsync object
            </summary>
            <returns>The pointer to the Feature2DAsync object</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaFastFeatureDetector.#ctor(System.Int32,System.Boolean,Emgu.CV.Features2D.FastDetector.DetectorType,System.Int32)">
            <summary>
            Create a fast detector with the specific parameters
            </summary>
            <param name="threshold">Threshold on difference between intensity of center pixel and pixels on circle around
            this pixel. Use 10 for default.</param>
            <param name="nonmaxSupression">Specifiy if non-maximum supression should be used.</param>
            <param name="maxNKeypoints">The maximum number of keypoints to be extracted.</param>
            <param name="type">The detector type</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaFastFeatureDetector.DisposeObject">
            <summary>
            Release the unmanaged resource associate to the Detector
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaORBDetector">
            <summary>
            An ORB detector using Cuda
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaORBDetector.#ctor(System.Int32,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,Emgu.CV.Features2D.ORBDetector.ScoreType,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create a ORBDetector using the specific values
            </summary>
            <param name="numberOfFeatures">The number of desired features.</param>
            <param name="scaleFactor">Coefficient by which we divide the dimensions from one scale pyramid level to the next.</param>
            <param name="nLevels">The number of levels in the scale pyramid.</param>
            <param name="firstLevel">The level at which the image is given. If 1, that means we will also look at the image.<paramref name="scaleFactor"/> times bigger</param>
            <param name="edgeThreshold">How far from the boundary the points should be.</param>
            <param name="WTK_A">How many random points are used to produce each cell of the descriptor (2, 3, 4 ...).</param>
            <param name="scoreType">Type of the score to use.</param>
            <param name="patchSize">Patch size.</param>
            <param name="blurForDescriptor">Blur for descriptor</param>
            <param name="fastThreshold">Fast threshold</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaORBDetector.DisposeObject">
            <summary>
            Release the unmanaged resource associate to the Detector
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.Feature2DAsyncExtension">
            <summary>
            Class that contains extension methods for Feature2DAsync
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.Feature2DAsyncExtension.DetectAndComputeAsync(Emgu.CV.Cuda.IFeature2DAsync,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,System.Boolean,Emgu.CV.Cuda.Stream)">
            <summary>
            Detect keypoints in an image and compute the descriptors on the image from the keypoint locations.
            </summary>
            <param name="feature2DAsync">The Feature2DAsync object</param>
            <param name="image">The image</param>
            <param name="mask">The optional mask, can be null if not needed</param>
            <param name="keyPoints">The detected keypoints will be stored in this vector</param>
            <param name="descriptors">The descriptors from the keypoints</param>
            <param name="useProvidedKeyPoints">If true, the method will skip the detection phase and will compute descriptors for the provided keypoints</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.Feature2DAsyncExtension.DetectAsync(Emgu.CV.Cuda.IFeature2DAsync,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Detect the features in the image
            </summary>
            <param name="feature2DAsync">The Feature2DAsync object</param>
            <param name="keypoints">The result vector of keypoints</param>
            <param name="image">The image from which the features will be detected from</param>
            <param name="mask">The optional mask.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.Feature2DAsyncExtension.ComputeAsync(Emgu.CV.Cuda.IFeature2DAsync,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Compute the descriptors on the image from the given keypoint locations.
            </summary>
            <param name="feature2DAsync">The Feature2DAsync object</param>
            <param name="image">The image to compute descriptors from</param>
            <param name="keypoints">The keypoints where the descriptor computation is perfromed</param>
            <param name="descriptors">The descriptors from the given keypoints</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.Feature2DAsyncExtension.Convert(Emgu.CV.Cuda.IFeature2DAsync,Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfKeyPoint)">
            <summary>
            Converts keypoints array from internal representation to standard vector.
            </summary>
            <param name="feature2DAsync">The Feature2DAsync object</param>
            <param name="gpuKeypoints">GpuMat representation of the keypoints.</param>
            <param name="keypoints">Vector of keypoints</param>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaBoxFilter">
            <summary>
            Box filter
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaFilter">
            <summary>
            Base Cuda filter class
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaFilter.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this gpu filter
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaFilter.Apply(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Apply the cuda filter
            </summary>
            <param name="image">The source CudaImage where the filter will be applied to</param>
            <param name="dst">The destination CudaImage</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBoxFilter.#ctor(Emgu.CV.CvEnum.DepthType,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32,System.Drawing.Size,System.Drawing.Point,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Create a BoxMax filter.
            </summary>
            <param name="ksize">Size of the kernel</param>
            <param name="anchor">The center of the kernel. User (-1, -1) for the default kernel center.</param>
            <param name="borderType">The border type.</param>
            <param name="borderValue">The border value.</param>
            <param name="srcDepth">The source image depth type</param>
            <param name="srcChannels">The number of channels in the source image</param>
            <param name="dstDepth">The destination image depth type</param>
            <param name="dstChannels">The number of channels in the destination image</param>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaBoxMaxFilter">
            <summary>
            BoxMax filter
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBoxMaxFilter.#ctor(Emgu.CV.CvEnum.DepthType,System.Int32,System.Drawing.Size,System.Drawing.Point,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Create a BoxMax filter.
            </summary>
            <param name="ksize">Size of the kernel</param>
            <param name="anchor">The center of the kernel. User (-1, -1) for the default kernel center.</param>
            <param name="borderType">The border type.</param>
            <param name="borderValue">The border value.</param>
            <param name="srcDepth">The depth type of the source image</param>
            <param name="srcChannels">The number of channels of the source image</param>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaBoxMinFilter">
            <summary>
            BoxMin filter
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBoxMinFilter.#ctor(Emgu.CV.CvEnum.DepthType,System.Int32,System.Drawing.Size,System.Drawing.Point,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Create a BoxMin filter.
            </summary>
            <param name="ksize">Size of the kernel</param>
            <param name="anchor">The center of the kernel. User (-1, -1) for the default kernel center.</param>
            <param name="borderType">The border type.</param>
            <param name="borderValue">The border value.</param>
            <param name="srcDepth">The depth of the source image</param>
            <param name="srcChannels">The number of channels in the source image</param>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaGaussianFilter">
            <summary>
            Gaussian filter
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaGaussianFilter.#ctor(Emgu.CV.CvEnum.DepthType,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32,System.Drawing.Size,System.Double,System.Double,Emgu.CV.CvEnum.BorderType,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Create a Gaussian filter.
            </summary>
            <param name="ksize">The size of the kernel</param>
            <param name="sigma1">This parameter may specify Gaussian sigma (standard deviation). If it is zero, it is calculated from the kernel size.</param>
            <param name="sigma2">In case of non-square Gaussian kernel the parameter may be used to specify a different (from param3) sigma in the vertical direction. Use 0 for default</param>
            <param name="rowBorderType">The row border type.</param>
            <param name="columnBorderType">The column border type.</param>
            <param name="srcDepth">The depth type of the source image</param>
            <param name="srcChannels">The number of channels in the source image</param>
            <param name="dstDepth">The depth type of the destination image</param>
            <param name="dstChannels">The number of channels in the destination image</param>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaLaplacianFilter">
            <summary>
            Laplacian filter
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaLaplacianFilter.#ctor(Emgu.CV.CvEnum.DepthType,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32,System.Int32,System.Double,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Create a Laplacian filter.
            </summary>
            <param name="ksize">Either 1 or 3</param>
            <param name="scale">Optional scale. Use 1.0 for default</param>
            <param name="borderType">The border type.</param>
            <param name="borderValue">The border value.</param>
            <param name="srcDepth">The depth type of the source image</param>
            <param name="srcChannels">The number of channels in the source image</param>
            <param name="dstDepth">The depth type of the destination image</param>
            <param name="dstChannels">The number of channels in the destination image</param>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaLinearFilter">
            <summary>
            Applies arbitrary linear filter to the image. In-place operation is supported. When the aperture is partially outside the image, the function interpolates outlier pixel values from the nearest pixels that is inside the image
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaLinearFilter.#ctor(Emgu.CV.CvEnum.DepthType,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32,Emgu.CV.IInputArray,System.Drawing.Point,Emgu.CV.CvEnum.BorderType,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Create a Gpu LinearFilter
            </summary>
            <param name="kernel">Convolution kernel, single-channel floating point matrix (e.g. Emgu.CV.Matrix). If you want to apply different kernels to different channels, split the gpu image into separate color planes and process them individually</param>
            <param name="anchor">The anchor of the kernel that indicates the relative position of a filtered point within the kernel. The anchor shoud lie within the kernel. The special default value (-1,-1) means that it is at the kernel center</param>
            <param name="borderType">Border type. Use REFLECT101 as default.</param>
            <param name="borderValue">The border value</param>
            <param name="srcDepth">The depth type of the source image</param>
            <param name="srcChannels">The number of channels in the source image</param>
            <param name="dstDepth">The depth type of the dest image</param>
            <param name="dstChannels">The number of channels in the dest image</param>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaMorphologyFilter">
            <summary>
            Morphology filter
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaMorphologyFilter.#ctor(Emgu.CV.CvEnum.MorphOp,Emgu.CV.CvEnum.DepthType,System.Int32,Emgu.CV.IInputArray,System.Drawing.Point,System.Int32)">
            <summary>
            Create a Morphology filter.
            </summary>
            <param name="op">Type of morphological operation</param>
            <param name="kernel">2D 8-bit structuring element for the morphological operation.</param>
            <param name="anchor">Anchor position within the structuring element. Negative values mean that the anchor is at the center.</param>
            <param name="iterations">Number of times erosion and dilation to be applied.</param>
            <param name="srcDepth">The depth type of the source image</param>
            <param name="srcChannels">The number of channels in the source image</param>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaSobelFilter">
            <summary>
            Sobel filter
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaSobelFilter.#ctor(Emgu.CV.CvEnum.DepthType,System.Int32,Emgu.CV.CvEnum.DepthType,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,Emgu.CV.CvEnum.BorderType,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Create a Sobel filter.
            </summary>
            <param name="srcDepth">The depth of the source image</param>
            <param name="srcChannels">The number of channels of the source image</param>
            <param name="dstDepth">The depth of the destination image</param>
            <param name="dstChannels">The number of channels of the the destination image</param>
            <param name="dx">Order of the derivative x</param>
            <param name="dy">Order of the derivative y</param>
            <param name="ksize">Size of the extended Sobel kernel</param>
            <param name="scale">Optional scale, use 1 for default.</param>
            <param name="rowBorderType">The row border type.</param>
            <param name="columnBorderType">The column border type.</param>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaCannyEdgeDetector">
            <summary>
            Cascade Classifier for object detection using Cuda
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaCannyEdgeDetector.#ctor(System.Double,System.Double,System.Int32,System.Boolean)">
            <summary>
            Canny edge detector using Cuda.
            </summary>
            <param name="lowThreshold">The first threshold, used for edge linking</param>
            <param name="highThreshold">The second threshold, used to find initial segments of strong edges</param>
            <param name="apertureSize">Aperture parameter for Sobel operator, use 3 for default</param>
            <param name="L2gradient">Use false for default</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaCannyEdgeDetector.Detect(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Finds the edges on the input <paramref name="src"/> and marks them in the output image edges using the Canny algorithm. 
            </summary>
            <param name="src">Input image</param>
            <param name="edges">Image to store the edges found by the function</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaCannyEdgeDetector.DisposeObject">
            <summary>
            Release all the unmanaged memory associate with this Canny edge detector.
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaCornernessCriteria">
            <summary>
            Base CornernessCriteria class
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaCornernessCriteria.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this gpu filter
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaCornernessCriteria.Apply(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Apply the cuda filter
            </summary>
            <param name="image">The source CudaImage where the filter will be applied to</param>
            <param name="dst">The destination CudaImage</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaGoodFeaturesToTrackDetector">
            <summary>
            Cuda implementation of GoodFeaturesToTrackDetector
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaGoodFeaturesToTrackDetector.#ctor(Emgu.CV.CvEnum.DepthType,System.Int32,System.Int32,System.Double,System.Double,System.Int32,System.Boolean,System.Double)">
            <summary>
            Create the Cuda implementation of GoodFeaturesToTrackDetector
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaGoodFeaturesToTrackDetector.Detect(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.IInputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Find the good features to track
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaGoodFeaturesToTrackDetector.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this detector
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaHarrisCorner">
            <summary>
            Runs the Harris edge detector on image. Similarly to cvCornerMinEigenVal and cvCornerEigenValsAndVecs, for each pixel it calculates 2x2 gradient covariation matrix M over block_size x block_size neighborhood. Then, it stores
            det(M) - k*trace(M)^2
            to the destination image. Corners in the image can be found as local maxima of the destination image.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHarrisCorner.#ctor(Emgu.CV.CvEnum.DepthType,System.Int32,System.Int32,System.Int32,System.Double,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Create a Cuda Harris Corner detector
            </summary>
            <param name="srcDepth">The depth of the source image</param>
            <param name="srcChannels">The number of channels in the source image</param>
            <param name="blockSize">Neighborhood size </param>
            <param name="kSize"></param>
            <param name="k">Harris detector free parameter.</param>
            <param name="borderType">Boreder type, use REFLECT101 for default</param>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaHoughCirclesDetector">
            <summary>
            Base class for circles detector algorithm.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHoughCirclesDetector.#ctor(System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create hough circles detector
            </summary>
            <param name="dp">Inverse ratio of the accumulator resolution to the image resolution. For example, if dp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has half as big width and height.</param>
            <param name="minDist">Minimum distance between the centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed.</param>
            <param name="cannyThreshold">The higher threshold of the two passed to Canny edge detector (the lower one is twice smaller).</param>
            <param name="votesThreshold">The accumulator threshold for the circle centers at the detection stage. The smaller it is, the more false circles may be detected.</param>
            <param name="minRadius">Minimum circle radius.</param>
            <param name="maxRadius">Maximum circle radius.</param>
            <param name="maxCircles">Maximum number of output circles.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHoughCirclesDetector.Detect(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Finds circles in a grayscale image using the Hough transform.
            </summary>
            <param name="image">8-bit, single-channel grayscale input image.</param>
            <param name="circles">Output vector of found circles. Each vector is encoded as a 3-element floating-point vector.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHoughCirclesDetector.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this circle detector.
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaHoughLinesDetector">
            <summary>
            Base class for lines detector algorithm.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHoughLinesDetector.#ctor(System.Single,System.Single,System.Int32,System.Boolean,System.Int32)">
            <summary>
            Create a hough lines detector
            </summary>
            <param name="rho">Distance resolution of the accumulator in pixels.</param>
            <param name="theta">Angle resolution of the accumulator in radians.</param>
            <param name="threshold">Accumulator threshold parameter. Only those lines are returned that get enough votes (&gt; threshold).</param>
            <param name="doSort">Performs lines sort by votes.</param>
            <param name="maxLines">Maximum number of output lines.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHoughLinesDetector.Detect(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Finds line segments in a binary image using the probabilistic Hough transform.
            </summary>
            <param name="image">8-bit, single-channel binary source image</param>
            <param name="lines">Output vector of lines.Output vector of lines. Each line is represented by a two-element vector. 
            The first element is the distance from the coordinate origin (top-left corner of the image). 
            The second element is the line rotation angle in radians.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHoughLinesDetector.DisposeObject">
            <summary>
            Release the unmanaged memory associated to this line detector.
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaHoughSegmentDetector">
            <summary>
            Base class for line segments detector algorithm.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHoughSegmentDetector.#ctor(System.Single,System.Single,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a hough segment detector
            </summary>
            <param name="rho">Distance resolution of the accumulator in pixels.</param>
            <param name="theta">Angle resolution of the accumulator in radians.</param>
            <param name="minLineLength"> Minimum line length. Line segments shorter than that are rejected.</param>
            <param name="maxLineGap">Maximum allowed gap between points on the same line to link them.</param>
            <param name="maxLines">Maximum number of output lines.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHoughSegmentDetector.Detect(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Finds line segments in a binary image using the probabilistic Hough transform.
            </summary>
            <param name="image">8-bit, single-channel binary source image</param>
            <param name="lines">Output vector of lines. Each line is represented by a 4-element vector (x1, y1, x2, y2) , where (x1, y1) and (x2, y2) are the ending points of each detected line segment.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHoughSegmentDetector.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this segment detector
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.DemosaicTypes">
            <summary>
            Bayer Demosaicing (Malvar, He, and Cutler)
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.DemosaicTypes.BayerBG2BGR_MHT">
            <summary>
            BayerBG2BGR_MHT
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.DemosaicTypes.BayerGB2BGR_MHT">
            <summary>
            BayerGB2BGR_MHT
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.DemosaicTypes.BayerRG2BGR_MHT">
            <summary>
            BayerRG2BGR_MHT
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.DemosaicTypes.BayerGR2BGR_MHT">
            <summary>
            BayerGR2BGR_MHT
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.DemosaicTypes.BayerBG2RGB_MHT">
            <summary>
            BayerBG2RGB_MHT
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.DemosaicTypes.BayerGB2RGB_MHT">
            <summary>
            BayerGB2RGB_MHT
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.DemosaicTypes.BayerRG2RGB_MHT">
            <summary>
            BayerRG2RGB_MHT
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.DemosaicTypes.BayerGR2RGB_MHT">
            <summary>
            BayerGR2RGB_MHT
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.DemosaicTypes.BayerBG2GRAY_MHT">
            <summary>
            BayerBG2GRAY_MHT
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.DemosaicTypes.BayerGB2GRAY_MHT">
            <summary>
            BayerGB2GRAY_MHT
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.DemosaicTypes.BayerRG2GRAY_MHT">
            <summary>
            BayerRG2GRAY_MHT
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.DemosaicTypes.BayerGR2GRAY_MHT">
            <summary>
            BayerGR2GRAY_MHT
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.AlphaCompTypes">
            <summary>
            Alpha composite types
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.AlphaCompTypes.Over">
            <summary>
            Over
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.AlphaCompTypes.In">
            <summary>
            In
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.AlphaCompTypes.Out">
            <summary>
            Out
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.AlphaCompTypes.Atop">
            <summary>
            Atop
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.AlphaCompTypes.Xor">
            <summary>
            Xor
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.AlphaCompTypes.Plus">
            <summary>
            Plus
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.AlphaCompTypes.OverPremul">
            <summary>
            Over Premul
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.AlphaCompTypes.InPremul">
            <summary>
            In Premul
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.AlphaCompTypes.OutPremul">
            <summary>
            Out Premul
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.AlphaCompTypes.AtopPremul">
            <summary>
            Atop Premul
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.AlphaCompTypes.XorPremul">
            <summary>
            Xor Premul
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.AlphaCompTypes.PlusPremul">
            <summary>
            Plus Premul
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.AlphaCompTypes.Premul">
            <summary>
            Premul
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaTemplateMatching">
            <summary>
            Cuda template matching filter.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaTemplateMatching.#ctor(Emgu.CV.CvEnum.DepthType,System.Int32,Emgu.CV.CvEnum.TemplateMatchingType,System.Drawing.Size)">
            <summary>
            Create a Cuda template matching filter
            </summary>
            <param name="method">Specifies the way the template must be compared with image regions </param>
            <param name="blockSize">The block size</param>
            <param name="depthType">The depth type of the image that will be used in the template matching</param>
            <param name="channels">The number of channels of the image that will be used in the template matching</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaTemplateMatching.Match(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
             This function is similiar to cvCalcBackProjectPatch. It slids through image, compares overlapped patches of size wxh with templ using the specified method and stores the comparison results to result
            </summary>
            <param name="image">Image where the search is running. It should be 8-bit or 32-bit floating-point</param>
            <param name="templ">Searched template; must be not greater than the source image and the same data type as the image</param>
            <param name="result">A map of comparison results; single-channel 32-bit floating-point. If image is WxH and templ is wxh then result must be W-w+1xH-h+1.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>  
        </member>
        <member name="M:Emgu.CV.Cuda.CudaTemplateMatching.DisposeObject">
            <summary>
            Release the buffer
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaBackgroundSubtractorFGD">
            <summary>
            Background/Foreground Segmentation Algorithm.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBackgroundSubtractorFGD.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.Int32,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Create a Background/Foreground Segmentation model
            </summary>
            <param name="Lc"></param>
            <param name="N1c"></param>
            <param name="N2c"></param>
            <param name="Lcc"></param>
            <param name="N1cc"></param>
            <param name="N2cc"></param>
            <param name="isObjWithoutHoles"></param>
            <param name="performMorphing"></param>
            <param name="alpha1">Background reference image update parameter</param>
            <param name="alpha2">Stat model update parameter. 0.002f ~ 1K frame(~45sec), 0.005 ~ 18sec (if 25fps and absolutely static BG)</param>
            <param name="alpha3">start value for alpha parameter (to fast initiate statistic model)</param>
            <param name="delta"></param>
            <param name="T"></param>
            <param name="minArea"></param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBackgroundSubtractorFGD.Apply(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double)">
            <summary>
            Updates the background model
            </summary>
            <param name="frame">Next video frame.</param>
            <param name="learningRate">The learning rate, use -1.0f for default value.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBackgroundSubtractorFGD.DisposeObject">
            <summary>
            Release all the unmanaged resource associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaBackgroundSubtractorGMG">
            <summary>
            Background/Foreground Segmentation Algorithm.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBackgroundSubtractorGMG.#ctor(System.Int32,System.Double)">
            <summary>
            Create a Background/Foreground Segmentation model
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBackgroundSubtractorGMG.Apply(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,Emgu.CV.Cuda.Stream)">
            <summary>
            Updates the background model
            </summary>
            <param name="frame">Next video frame.</param>
            <param name="learningRate">The learning rate, use -1.0f for default value.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBackgroundSubtractorGMG.DisposeObject">
            <summary>
            Release all the unmanaged resource associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaCascadeClassifier">
            <summary>
            Cascade Classifier for object detection using Cuda
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaCascadeClassifier.#ctor(System.String)">
            <summary>
            Create a Cuda cascade classifier using the specific file
            </summary>
            <param name="fileName">The file to create the classifier from</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaCascadeClassifier.#ctor(Emgu.CV.FileStorage)">
            <summary>
            Create a Cuda cascade classifier using the specific file storage
            </summary>
            <param name="fs">The file storage to create the classifier from</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaCascadeClassifier.DetectMultiScale(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Detects objects of different sizes in the input image.
            </summary>
            <param name="image">Matrix of type CV_8U containing an image where objects should be detected.</param>
            <param name="objects">Buffer to store detected objects (rectangles).</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaCascadeClassifier.Convert(Emgu.CV.IOutputArray)">
            <summary>
            Converts objects array from internal representation to standard vector.
            </summary>
            <param name="objects">Objects array in internal representation.</param>
            <returns>Resulting array.</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaCascadeClassifier.DisposeObject">
            <summary>
            Release all unmanaged resources associated with this object
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaCascadeClassifier.ScaleFactor">
            <summary>
            Parameter specifying how much the image size is reduced at each image scale
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaCascadeClassifier.MinNeighbors">
            <summary>
            Parameter specifying how many neighbors each candidate rectangle should have to retain it
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaCascadeClassifier.MaxNumObjects">
            <summary>
            The maximum number of objects
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaCascadeClassifier.FindLargestObject">
            <summary>
            If true, only return the largest object
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaCascadeClassifier.MaxObjectSize">
            <summary>
            The maximum object size
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaCascadeClassifier.MinObjectSize">
            <summary>
            The minimum object size
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaCascadeClassifier.ClassifierSize">
            <summary>
            The classifier size
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaHOG">
            <summary>
            A HOG descriptor
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHOG.#ctor(System.Drawing.Size,System.Drawing.Size,System.Drawing.Size,System.Drawing.Size,System.Int32)">
            <summary>
            Create a new HOGDescriptor using the specific parameters
            </summary>
            <param name="blockSize">Block size in cells. Use (16, 16) for default.</param>
            <param name="cellSize">Cell size. Use (8, 8) for default.</param>
            <param name="blockStride">Block stride. Must be a multiple of cell size. Use (8,8) for default.</param>
            <param name="nbins">Number of bins.</param>
            <param name="winSize">Detection window size. Must be aligned to block size and block stride. Must match the size of the training image. Use (64, 128) for default.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHOG.GetDefaultPeopleDetector">
            <summary>
            Returns coefficients of the classifier trained for people detection (for default window size).
            </summary>
            <returns>The default people detector</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHOG.SetSVMDetector(Emgu.CV.IInputArray)">
            <summary>
            Set the SVM detector 
            </summary>
            <param name="detector">The SVM detector</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHOG.DetectMultiScale(Emgu.CV.IInputArray)">
            <summary>
            Performs object detection with increasing detection window.
            </summary>
            <param name="image">The CudaImage to search in</param>
            <returns>The regions where positives are found</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHOG.DetectMultiScale(Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfRect,Emgu.CV.Util.VectorOfDouble)">
            <summary>
            Performs object detection with a multi-scale window.
            </summary>
            <param name="image">Source image.</param>
            <param name="objects">Detected objects boundaries.</param>
            <param name="confident">Optional output array for confidences.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaHOG.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this HOGDescriptor
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaHOG.GammaCorrection">
            <summary>
            Flag to specify whether the gamma correction preprocessing is required or not
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaHOG.WinSigma">
            <summary>
            Gaussian smoothing window parameter
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaHOG.NumLevels">
            <summary>
            Maximum number of detection window increases
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaHOG.GroupThreshold">
            <summary>
            Coefficient to regulate the similarity threshold. When detected, some objects can be covered by many rectangles. 0 means not to perform grouping. See groupRectangles.
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaHOG.HitThreshold">
            <summary>
            Threshold for the distance between features and SVM classifying plane. Usually it is 0 and should be specfied in the detector coefficients (as the last free coefficient). But if the free coefficient is omitted (which is allowed), you can specify it manually here.
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaHOG.ScaleFactor">
            <summary>
            Coefficient of the detection window increase.
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaHOG.L2HysThreshold">
            <summary>
            L2-Hys normalization method shrinkage.
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaHOG.DescriptorFormat">
            <summary>
            The descriptor format
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaHOG.DescriptorSize">
            <summary>
            Returns the number of coefficients required for the classification.
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaHOG.WinStride">
            <summary>
            Window stride. It must be a multiple of block stride.
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.CudaHOG.BlockHistogramSize">
            <summary>
            Returns the block histogram size.
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaHOG.DescrFormat">
            <summary>
            The descriptor format
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.CudaHOG.DescrFormat.RowByRow">
            <summary>
            Row by row
            </summary>
        </member>
        <member name="F:Emgu.CV.Cuda.CudaHOG.DescrFormat.ColByCol">
            <summary>
            Col by col
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaBroxOpticalFlow">
            <summary>
            Brox optical flow
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.ICudaDenseOpticalFlow">
            <summary>
            Cuda Dense Optical flow
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.ICudaDenseOpticalFlow.DenseOpticalFlowPtr">
            <summary>
            Pointer to cv::cuda::denseOpticalFlow
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBroxOpticalFlow.#ctor(System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create the Brox optical flow solver
            </summary>
            <param name="alpha">Flow smoothness</param>
            <param name="gamma">Gradient constancy importance</param>
            <param name="scaleFactor">Pyramid scale factor</param>
            <param name="innerIterations">Number of lagged non-linearity iterations (inner loop)</param>
            <param name="outerIterations">Number of warping iterations (number of pyramid levels)</param>
            <param name="solverIterations">Number of linear system solver iterations</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaBroxOpticalFlow.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this optical flow solver.
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaDensePyrLKOpticalFlow">
            <summary>
            PyrLK optical flow
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaDensePyrLKOpticalFlow.#ctor(System.Drawing.Size,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create the PyrLK optical flow solver
            </summary>
            <param name="winSize">Windows size. Use 21x21 for default</param>
            <param name="maxLevel">The maximum number of pyramid levels.</param>
            <param name="iters">The number of iterations.</param>
            <param name="useInitialFlow">Weather or not use the initial flow in the input matrix.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaDensePyrLKOpticalFlow.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this optical flow solver.
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaFarnebackOpticalFlow">
            <summary>
            Farneback optical flow
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaFarnebackOpticalFlow.#ctor(System.Int32,System.Double,System.Boolean,System.Int32,System.Int32,System.Int32,System.Double,System.Int32)">
            <summary>
            
            </summary>
            <param name="numLevels"></param>
            <param name="pyrScale"></param>
            <param name="fastPyramids"></param>
            <param name="winSize"></param>
            <param name="numIters"></param>
            <param name="polyN"></param>
            <param name="polySigma"></param>
            <param name="flags"></param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaFarnebackOpticalFlow.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this optical flow solver.
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaOpticalFlowDualTvl1">
            <summary>
            DualTvl1 optical flow
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaOpticalFlowDualTvl1.#ctor(System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Double,System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Emgu.CV.Cuda.CudaOpticalFlowDualTvl1"/> class.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaOpticalFlowDualTvl1.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this optical flow solver.
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaSparsePyrLKOpticalFlow">
            <summary>
            Sparse PyrLK optical flow
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.ICudaSparseOpticalFlow">
            <summary>
            Interface to provide access to the cuda::SparseOpticalFlow class.
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.ICudaSparseOpticalFlow.SparseOpticalFlowPtr">
            <summary>
            Pointer the the native cuda::sparseOpticalFlow object.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaSparsePyrLKOpticalFlow.#ctor(System.Drawing.Size,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create the PyrLK optical flow solver
            </summary>
            <param name="winSize">Windows size. Use 21x21 for default</param>
            <param name="maxLevel">The maximum number of pyramid levels.</param>
            <param name="iters">The number of iterations.</param>
            <param name="useInitialFlow">Weather or not use the initial flow in the input matrix.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaSparsePyrLKOpticalFlow.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this optical flow solver.
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaDisparityBilateralFilter">
            <summary>
            Disparity map refinement using joint bilateral filtering given a single color image.
            Qingxiong Yang, Liang Wang, Narendra Ahuja
            http://vision.ai.uiuc.edu/~qyang6/
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaDisparityBilateralFilter.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a GpuDisparityBilateralFilter
            </summary>
            <param name="ndisp">Number of disparities. Use 64 as default</param>
            <param name="radius">Filter radius, use 3 as default</param>
            <param name="iters">Number of iterations, use 1 as default</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaDisparityBilateralFilter.Apply(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Apply the filter to the disparity image
            </summary>
            <param name="disparity">The input disparity map</param>
            <param name="image">The image</param>
            <param name="dst">The output disparity map, should have the same size as the input disparity map</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaDisparityBilateralFilter.DisposeObject">
            <summary>
            Release the unmanaged resources associated with the filter.
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaStereoBM">
            <summary>
            Use Block Matching algorithm to find stereo correspondence
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaStereoBM.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a stereoBM 
            </summary>
            <param name="numberOfDisparities">The number of disparities. Must be multiple of 8. Use 64 for default </param>
            <param name="blockSize">The SAD window size. Use 19 for default</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaStereoBM.FindStereoCorrespondence(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes disparity map for the input rectified stereo pair.
            </summary>
            <param name="left">The left single-channel, 8-bit image</param>
            <param name="right">The right image of the same size and the same type</param>
            <param name="disparity">The disparity map</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaStereoBM.DisposeObject">
            <summary>
            Release the stereo state and all the memory associate with it
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.CudaStereoConstantSpaceBP">
            <summary>
            A Constant-Space Belief Propagation Algorithm for Stereo Matching.
            Qingxiong Yang, Liang Wang, Narendra Ahuja.
            http://vision.ai.uiuc.edu/~qyang6/
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaStereoConstantSpaceBP.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            A Constant-Space Belief Propagation Algorithm for Stereo Matching
            </summary>
            <param name="ndisp">The number of disparities. Use 128 as default</param>
            <param name="iters">The number of BP iterations on each level. Use 8 as default.</param>
            <param name="levels">The number of levels. Use 4 as default</param>
            <param name="nrPlane">The number of active disparity on the first level. Use 4 as default.</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaStereoConstantSpaceBP.FindStereoCorrespondence(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.Cuda.Stream)">
            <summary>
            Computes disparity map for the input rectified stereo pair.
            </summary>
            <param name="left">The left single-channel, 8-bit image</param>
            <param name="right">The right image of the same size and the same type</param>
            <param name="disparity">The disparity map</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.Cuda.CudaStereoConstantSpaceBP.DisposeObject">
            <summary>
            Release the unmanaged memory
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.Stream">
            <summary>
            Encapculates Cuda Stream. Provides interface for async coping.
            Passed to each function that supports async kernel execution.
            Reference counting is enabled
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.Stream.#ctor">
            <summary>
            Create a new Cuda Stream
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.Stream.WaitForCompletion">
            <summary>
            Wait for the completion
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.Stream.DisposeObject">
            <summary>
            Release the stream
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.Stream.Completed">
            <summary>
            Check if the stream is completed
            </summary>
        </member>
        <member name="T:Emgu.CV.Cuda.TargetArchs">
            <summary>
            Gives information about what GPU archs this OpenCV GPU module was compiled for
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.TargetArchs.BuildWith(Emgu.CV.Cuda.CudaDeviceInfo.GpuFeature)">
            <summary>
            Check if the GPU module is build with the specific feature set.
            </summary>
            <param name="featureSet">The feature set to be checked.</param>
            <returns>True if the GPU module is build with the specific feature set.</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.TargetArchs.Has(System.Int32,System.Int32)">
            <summary>
            Check if the GPU module is targeted for the specific device version
            </summary>
            <param name="major">The major version</param>
            <param name="minor">The minor version</param>
            <returns>True if the GPU module is targeted for the specific device version.</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.TargetArchs.HasPtx(System.Int32,System.Int32)">
            <summary>
            Check if the GPU module is targeted for the specific PTX version
            </summary>
            <param name="major">The major version</param>
            <param name="minor">The minor version</param>
            <returns>True if the GPU module is targeted for the specific PTX version.</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.TargetArchs.HasBin(System.Int32,System.Int32)">
            <summary>
            Check if the GPU module is targeted for the specific BIN version
            </summary>
            <param name="major">The major version</param>
            <param name="minor">The minor version</param>
            <returns>True if the GPU module is targeted for the specific BIN version.</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.TargetArchs.HasEqualOrLessPtx(System.Int32,System.Int32)">
            <summary>
            Check if the GPU module is targeted for equal or less PTX version
            </summary>
            <param name="major">The major version</param>
            <param name="minor">The minor version</param>
            <returns>True if the GPU module is targeted for equal or less PTX version.</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.TargetArchs.HasEqualOrGreater(System.Int32,System.Int32)">
            <summary>
            Check if the GPU module is targeted for equal or greater device version
            </summary>
            <param name="major">The major version</param>
            <param name="minor">The minor version</param>
            <returns>True if the GPU module is targeted for equal or greater device version.</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.TargetArchs.HasEqualOrGreaterPtx(System.Int32,System.Int32)">
            <summary>
            Check if the GPU module is targeted for equal or greater PTX version
            </summary>
            <param name="major">The major version</param>
            <param name="minor">The minor version</param>
            <returns>True if the GPU module is targeted for equal or greater PTX version.</returns>
        </member>
        <member name="M:Emgu.CV.Cuda.TargetArchs.HasEqualOrGreaterBin(System.Int32,System.Int32)">
            <summary>
            Check if the GPU module is targeted for equal or greater BIN version
            </summary>
            <param name="major">The major version</param>
            <param name="minor">The minor version</param>
            <returns>True if the GPU module is targeted for equal or greater BIN version.</returns>
        </member>
        <member name="T:Emgu.CV.Cuda.VectorOfGpuMat">
            <summary>
            Wrapped class of the C++ standard vector of GpuMat.
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.VectorOfGpuMat.#ctor">
            <summary>
            Create an empty standard vector of GpuMat
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.VectorOfGpuMat.#ctor(System.Int32)">
            <summary>
            Create an standard vector of GpuMat of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Cuda.VectorOfGpuMat.#ctor(Emgu.CV.Cuda.GpuMat[])">
            <summary>
            Create an standard vector of GpuMat with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Cuda.VectorOfGpuMat.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.VectorOfGpuMat.Push(Emgu.CV.Cuda.GpuMat)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Cuda.VectorOfGpuMat.Push(Emgu.CV.Cuda.GpuMat[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Cuda.VectorOfGpuMat.Push(Emgu.CV.Cuda.VectorOfGpuMat)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Cuda.VectorOfGpuMat.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.VectorOfGpuMat.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.VectorOfGpuMat.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Cuda.VectorOfGpuMat.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.VectorOfGpuMat.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Cuda.VectorOfGpuMat.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.Cuda.VectorOfGpuMat.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Aruco.ArucoInvoke">
            <summary>
            Entry points for the Aruco module.
            </summary>
        </member>
        <member name="M:Emgu.CV.Aruco.ArucoInvoke.DrawMarker(Emgu.CV.Aruco.Dictionary,System.Int32,System.Int32,Emgu.CV.IOutputArray,System.Int32)">
            <summary>
            Draw a canonical marker image.
            </summary>
            <param name="dict">dictionary of markers indicating the type of markers</param>
            <param name="id">identifier of the marker that will be returned. It has to be a valid id in the specified dictionary.</param>
            <param name="sidePixels">size of the image in pixels</param>
            <param name="img">output image with the marker</param>
            <param name="borderBits">width of the marker border.</param>
        </member>
        <member name="M:Emgu.CV.Aruco.ArucoInvoke.DetectMarkers(Emgu.CV.IInputArray,Emgu.CV.Aruco.Dictionary,Emgu.CV.IOutputArrayOfArrays,Emgu.CV.IOutputArray,Emgu.CV.Aruco.DetectorParameters,Emgu.CV.IOutputArrayOfArrays)">
            <summary>
            Performs marker detection in the input image. Only markers included in the specific dictionary are searched. For each detected marker, it returns the 2D position of its corner in the image and its corresponding identifier. Note that this function does not perform pose estimation.
            </summary>
            <param name="image">input image</param>
            <param name="dict">indicates the type of markers that will be searched</param>
            <param name="corners">	vector of detected marker corners. For each marker, its four corners are provided, (e.g VectorOfVectorOfPointF ). For N detected markers, the dimensions of this array is Nx4. The order of the corners is clockwise.</param>
            <param name="ids">vector of identifiers of the detected markers. The identifier is of type int (e.g. VectorOfInt). For N detected markers, the size of ids is also N. The identifiers have the same order than the markers in the imgPoints array.</param>
            <param name="parameters">marker detection parameters</param>
            <param name="rejectedImgPoints">contains the imgPoints of those squares whose inner code has not a correct codification. Useful for debugging purposes.</param>
        </member>
        <member name="M:Emgu.CV.Aruco.ArucoInvoke.DrawAxis(Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Single)">
            <summary>
            Given the pose estimation of a marker or board, this function draws the axis of the world coordinate system, i.e. the system centered on the marker/board. Useful for debugging purposes.
            </summary>
            <param name="image">input/output image. It must have 1 or 3 channels. The number of channels is not altered.</param>
            <param name="cameraMatrix">input 3x3 floating-point camera matrix</param>
            <param name="distCoeffs">vector of distortion coefficients (k1,k2,p1,p2[,k3[,k4,k5,k6],[s1,s2,s3,s4]]) of 4, 5, 8 or 12 elements</param>
            <param name="rvec">rotation vector of the coordinate system that will be drawn.</param>
            <param name="tvec">translation vector of the coordinate system that will be drawn.</param>
            <param name="length">length of the painted axis in the same unit than tvec (usually in meters)</param>
        </member>
        <member name="M:Emgu.CV.Aruco.ArucoInvoke.EstimatePoseSingleMarkers(Emgu.CV.IInputArrayOfArrays,System.Single,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArrayOfArrays,Emgu.CV.IOutputArrayOfArrays)">
            <summary>
            This function receives the detected markers and returns their pose estimation respect to the camera individually. So for each marker, one rotation and translation vector is returned. The returned transformation is the one that transforms points from each marker coordinate system to the camera coordinate system. The marker corrdinate system is centered on the middle of the marker, with the Z axis perpendicular to the marker plane. The coordinates of the four corners of the marker in its own coordinate system are: (-markerLength/2, markerLength/2, 0), (markerLength/2, markerLength/2, 0), (markerLength/2, -markerLength/2, 0), (-markerLength/2, -markerLength/2, 0)
            </summary>
            <param name="corners">vector of already detected markers corners. For each marker, its four corners are provided, (e.g VectorOfVectorOfPointF ). For N detected markers, the dimensions of this array should be Nx4. The order of the corners should be clockwise.</param>
            <param name="markerLength">the length of the markers' side. The returning translation vectors will be in the same unit. Normally, unit is meters.</param>
            <param name="cameraMatrix">input 3x3 floating-point camera matrix</param>
            <param name="distCoeffs">vector of distortion coefficients (k1,k2,p1,p2[,k3[,k4,k5,k6],[s1,s2,s3,s4]]) of 4, 5, 8 or 12 elements</param>
            <param name="rvecs">array of output rotation vectors. Each element in rvecs corresponds to the specific marker in imgPoints.</param>
            <param name="tvecs">array of output translation vectors (e.g. VectorOfPoint3D32F ). Each element in tvecs corresponds to the specific marker in imgPoints.</param>
        </member>
        <member name="M:Emgu.CV.Aruco.ArucoInvoke.RefineDetectedMarkers(Emgu.CV.IInputArray,Emgu.CV.Aruco.IBoard,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,System.Single,System.Single,System.Boolean,Emgu.CV.IOutputArray,Emgu.CV.Aruco.DetectorParameters)">
            <summary>
            Refine not detected markers based on the already detected and the board layout.
            </summary>
            <param name="image">Input image</param>
            <param name="board">Layout of markers in the board.</param>
            <param name="detectedCorners">Vector of already detected marker corners.</param>
            <param name="detectedIds">Vector of already detected marker identifiers.</param>
            <param name="rejectedCorners">Vector of rejected candidates during the marker detection process</param>
            <param name="cameraMatrix">Optional input 3x3 floating-point camera matrix </param>
            <param name="distCoeffs">Optional vector of distortion coefficients (k1,k2,p1,p2[,k3[,k4,k5,k6],[s1,s2,s3,s4]]) of 4, 5, 8 or 12 elements</param>
            <param name="minRepDistance">Minimum distance between the corners of the rejected candidate and the reprojected marker in order to consider it as a correspondence. (default 10)</param>
            <param name="errorCorrectionRate">Rate of allowed erroneous bits respect to the error correction capability of the used dictionary. -1 ignores the error correction step. (default 3)</param>
            <param name="checkAllOrders">Consider the four posible corner orders in the rejectedCorners array. If it set to false, only the provided corner order is considered (default true).</param>
            <param name="recoveredIdxs">Optional array to returns the indexes of the recovered candidates in the original rejectedCorners array.</param>
            <param name="parameters">marker detection parameters</param>
        </member>
        <member name="M:Emgu.CV.Aruco.ArucoInvoke.DrawDetectedMarkers(Emgu.CV.IInputOutputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Draw detected markers in image.
            </summary>
            <param name="image">Input/output image. It must have 1 or 3 channels. The number of channels is not altered.</param>
            <param name="corners">Positions of marker corners on input image. (e.g std::vector&lt;std::vector&lt;cv::Point2f&gt; &gt; ). For N detected markers, the dimensions of this array should be Nx4. The order of the corners should be clockwise.</param>
            <param name="ids">Vector of identifiers for markers in markersCorners . Optional, if not provided, ids are not painted.</param>
            <param name="borderColor">Color of marker borders. Rest of colors (text color and first corner color) are calculated based on this one to improve visualization.</param>
        </member>
        <member name="M:Emgu.CV.Aruco.ArucoInvoke.CalibrateCameraAruco(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.Aruco.IBoard,System.Drawing.Size,Emgu.CV.IInputOutputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IOutputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.CalibType,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Calibrate a camera using aruco markers.
            </summary>
            <param name="corners">Vector of detected marker corners in all frames. The corners should have the same format returned by detectMarkers</param>
            <param name="ids">List of identifiers for each marker in corners</param>
            <param name="counter">Number of markers in each frame so that corners and ids can be split</param>
            <param name="board">Marker Board layout</param>
            <param name="imageSize">Size of the image used only to initialize the intrinsic camera matrix.</param>
            <param name="cameraMatrix">Output 3x3 floating-point camera matrix. </param>
            <param name="distCoeffs">Output vector of distortion coefficients (k1,k2,p1,p2[,k3[,k4,k5,k6],[s1,s2,s3,s4]]) of 4, 5, 8 or 12 elements</param>
            <param name="rvecs">Output vector of rotation vectors (see Rodrigues ) estimated for each board view (e.g. std::vector&lt;cv::Mat&gt;>). That is, each k-th rotation vector together with the corresponding k-th translation vector (see the next output parameter description) brings the board pattern from the model coordinate space (in which object points are specified) to the world coordinate space, that is, a real position of the board pattern in the k-th pattern view (k=0.. M -1).</param>
            <param name="tvecs">Output vector of translation vectors estimated for each pattern view.</param>
            <param name="flags">Flags Different flags for the calibration process</param>
            <param name="criteria">Termination criteria for the iterative optimization algorithm.</param>
            <returns>The final re-projection error.</returns>
        </member>
        <member name="T:Emgu.CV.Aruco.DetectorParameters">
            <summary>
            Parameters for the detectMarker process
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.DetectorParameters.AdaptiveThreshWinSizeMin">
            <summary>
            minimum window size for adaptive thresholding before finding contours (default 3)
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.DetectorParameters.AdaptiveThreshWinSizeMax">
            <summary>
            maximum window size for adaptive thresholding before finding contours (default 23).
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.DetectorParameters.AdaptiveThreshWinSizeStep">
            <summary>
            increments from adaptiveThreshWinSizeMin to adaptiveThreshWinSizeMax during the thresholding (default 10).
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.DetectorParameters.AdaptiveThreshConstant">
            <summary>
            constant for adaptive thresholding before finding contours (default 7)
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.DetectorParameters.MinMarkerPerimeterRate">
            <summary>
             determine minimum perimeter for marker contour to be detected. This is defined as a rate respect to the maximum dimension of the input image (default 0.03).
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.DetectorParameters.MaxMarkerPerimeterRate">
            <summary>
            determine maximum perimeter for marker contour to be detected. This is defined as a rate respect to the maximum dimension of the input image (default 4.0).
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.DetectorParameters.PolygonalApproxAccuracyRate">
            <summary>
            minimum accuracy during the polygonal approximation process to determine which contours are squares.
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.DetectorParameters.MinCornerDistanceRate">
            <summary>
            minimum distance between corners for detected markers relative to its perimeter (default 0.05)
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.DetectorParameters.MinDistanceToBorder">
            <summary>
            minimum distance of any corner to the image border for detected markers (in pixels) (default 3)
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.DetectorParameters.MinMarkerDistanceRate">
            <summary>
            minimum mean distance beetween two marker corners to be considered similar, so that the smaller one is removed. The rate is relative to the smaller perimeter of the two markers (default 0.05).
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.DetectorParameters.CornerRefinementMethod">
            <summary>
            Corner refinement method
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.DetectorParameters.CornerRefinementWinSize">
            <summary>
            window size for the corner refinement process (in pixels) (default 5).
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.DetectorParameters.CornerRefinementMaxIterations">
            <summary>
            maximum number of iterations for stop criteria of the corner refinement process (default 30).
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.DetectorParameters.CornerRefinementMinAccuracy">
            <summary>
            minimum error for the stop criteria of the corner refinement process (default: 0.1)
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.DetectorParameters.MarkerBorderBits">
            <summary>
            number of bits of the marker border, i.e. marker border width (default 1).
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.DetectorParameters.PerspectiveRemovePixelPerCell">
            <summary>
            number of bits (per dimension) for each cell of the marker when removing the perspective (default 8).
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.DetectorParameters.PerspectiveRemoveIgnoredMarginPerCell">
            <summary>
            width of the margin of pixels on each cell not considered for the determination of the cell bit. Represents the rate respect to the total size of the cell, i.e. perpectiveRemovePixelPerCell (default 0.13)
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.DetectorParameters.MaxErroneousBitsInBorderRate">
            <summary>
            maximum number of accepted erroneous bits in the border (i.e. number of allowed white bits in the border). Represented as a rate respect to the total number of bits per marker (default 0.35).
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.DetectorParameters.MinOtsuStdDev">
            <summary>
             minimun standard deviation in pixels values during the decodification step to apply Otsu thresholding (otherwise, all the bits are set to 0 or 1 depending on mean higher than 128 or not) (default 5.0)
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.DetectorParameters.ErrorCorrectionRate">
            <summary>
            error correction rate respect to the maximun error correction capability for each dictionary. (default 0.6).
            </summary>
        </member>
        <member name="M:Emgu.CV.Aruco.DetectorParameters.GetDefault">
            <summary>
            Get the detector parameters with default values
            </summary>
            <returns>The default detector parameters</returns>
        </member>
        <member name="T:Emgu.CV.Aruco.DetectorParameters.RefinementMethod">
            <summary>
            Type of corner refinement method
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.DetectorParameters.RefinementMethod.None">
            <summary>
            Default corners
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.DetectorParameters.RefinementMethod.Subpix">
            <summary>
            Refine the corners using subpix
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.DetectorParameters.RefinementMethod.Contour">
            <summary>
            Refine the corners using the contour-points
            </summary>
        </member>
        <member name="T:Emgu.CV.Aruco.Dictionary">
            <summary>
            Dictionary/Set of markers. It contains the inner codification.
            </summary>
        </member>
        <member name="M:Emgu.CV.Aruco.Dictionary.#ctor(Emgu.CV.Aruco.Dictionary.PredefinedDictionaryName)">
            <summary>
            Create a Dictionary using predefined values
            </summary>
            <param name="name">The name of the predefined dictionary</param>
        </member>
        <member name="M:Emgu.CV.Aruco.Dictionary.#ctor(System.Int32,System.Int32)">
            <summary>
            Generates a new customizable marker dictionary.
            </summary>
            <param name="nMarkers">number of markers in the dictionary</param>
            <param name="markerSize">number of bits per dimension of each markers</param>
        </member>
        <member name="M:Emgu.CV.Aruco.Dictionary.#ctor(System.Int32,System.Int32,Emgu.CV.Aruco.Dictionary)">
            <summary>
            Generates a new customizable marker dictionary.
            </summary>
            <param name="nMarkers">number of markers in the dictionary</param>
            <param name="markerSize">number of bits per dimension of each markers</param>
            <param name="baseDictionary">Include the markers in this dictionary at the beginning (optional)</param>
        </member>
        <member name="M:Emgu.CV.Aruco.Dictionary.DisposeObject">
            <summary>
            Release the unmanaged resource
            </summary>
        </member>
        <member name="T:Emgu.CV.Aruco.Dictionary.PredefinedDictionaryName">
            <summary>
            The name of the predefined dictionary
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.Dictionary.PredefinedDictionaryName.Dict4X4_50">
            <summary>
            Dict4X4_50
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.Dictionary.PredefinedDictionaryName.Dict4X4_100">
            <summary>
            Dict4X4_100
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.Dictionary.PredefinedDictionaryName.Dict4X4_250">
            <summary>
            Dict4X4_250
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.Dictionary.PredefinedDictionaryName.Dict4X4_1000">
            <summary>
            Dict4X4_1000
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.Dictionary.PredefinedDictionaryName.Dict5X5_50">
            <summary>
            Dict5X5_50
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.Dictionary.PredefinedDictionaryName.Dict5X5_100">
            <summary>
            Dict5X5_100
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.Dictionary.PredefinedDictionaryName.Dict5X5_250">
            <summary>
            Dict5X5_250
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.Dictionary.PredefinedDictionaryName.Dict5X5_1000">
            <summary>
            Dict5X5_1000
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.Dictionary.PredefinedDictionaryName.Dict6X6_50">
            <summary>
            Dict6X6_50
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.Dictionary.PredefinedDictionaryName.Dict6X6_100">
            <summary>
            Dict6X6_100
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.Dictionary.PredefinedDictionaryName.Dict6X6_250">
            <summary>
            Dict6X6_250
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.Dictionary.PredefinedDictionaryName.Dict6X6_1000">
            <summary>
            Dict6X6_1000
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.Dictionary.PredefinedDictionaryName.Dict7X7_50">
            <summary>
            Dict7X7_50
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.Dictionary.PredefinedDictionaryName.Dict7X7_100">
            <summary>
            Dict7X7_100
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.Dictionary.PredefinedDictionaryName.Dict7X7_250">
            <summary>
            Dict7X7_250
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.Dictionary.PredefinedDictionaryName.Dict7X7_1000">
            <summary>
            Dict7X7_1000
            </summary>
        </member>
        <member name="F:Emgu.CV.Aruco.Dictionary.PredefinedDictionaryName.DictArucoOriginal">
            <summary>
            standard ArUco Library Markers. 1024 markers, 5x5 bits, 0 minimum distance
            </summary>
        </member>
        <member name="T:Emgu.CV.Aruco.IBoard">
            <summary>
            Board of markers
            </summary>
        </member>
        <member name="P:Emgu.CV.Aruco.IBoard.BoardPtr">
            <summary>
            Pointer to native IBoard
            </summary>
        </member>
        <member name="T:Emgu.CV.Aruco.GridBoard">
            <summary>
            Planar board with grid arrangement of markers More common type of board. All markers are placed in the same plane in a grid arrangment.
            </summary>
        </member>
        <member name="M:Emgu.CV.Aruco.GridBoard.#ctor(System.Int32,System.Int32,System.Single,System.Single,Emgu.CV.Aruco.Dictionary,System.Int32)">
            <summary>
            Create a GridBoard object.
            </summary>
            <param name="markersX">number of markers in X direction</param>
            <param name="markersY">number of markers in Y direction</param>
            <param name="markerLength">marker side length (normally in meters)</param>
            <param name="markerSeparation">separation between two markers (same unit than markerLenght)</param>
            <param name="dictionary">dictionary of markers indicating the type of markers. The first markersX*markersY markers in the dictionary are used.</param>
            <param name="firstMarker">	id of first marker in dictionary to use on board.</param>
        </member>
        <member name="M:Emgu.CV.Aruco.GridBoard.Draw(System.Drawing.Size,Emgu.CV.IOutputArray,System.Int32,System.Int32)">
            <summary>
            Draw a GridBoard.
            </summary>
            <param name="outSize">size of the output image in pixels.</param>
            <param name="img">output image with the board. The size of this image will be outSize and the board will be on the center, keeping the board proportions.</param>
            <param name="marginSize">minimum margins (in pixels) of the board in the output image</param>
            <param name="borderBits">width of the marker borders.</param>
        </member>
        <member name="M:Emgu.CV.Aruco.GridBoard.DisposeObject">
            <summary>
            Release the unmanaged resource associated with this GridBoard
            </summary>
        </member>
        <member name="P:Emgu.CV.Aruco.GridBoard.BoardPtr">
            <summary>
            Pointer to native IBoard
            </summary>
        </member>
        <member name="T:Emgu.CV.Aruco.CharucoBoard">
            <summary>
            A ChArUco board is a planar board where the markers are placed
            inside the white squares of a chessboard.The benefits of ChArUco boards is that they provide
            both, ArUco markers versatility and chessboard corner precision, which is important for
            calibration and pose estimation.
            </summary>
        </member>
        <member name="M:Emgu.CV.Aruco.CharucoBoard.#ctor(System.Int32,System.Int32,System.Single,System.Single,Emgu.CV.Aruco.Dictionary)">
            <summary>
            ChArUco board
            </summary>
            <param name="squaresX">number of chessboard squares in X direction</param>
            <param name="squaresY">number of chessboard squares in Y direction</param>
            <param name="squareLength">chessboard square side length (normally in meters)</param>
            <param name="markerLength">marker side length (same unit than squareLength)</param>
            <param name="dictionary">dictionary of markers indicating the type of markers.</param>
        </member>
        <member name="M:Emgu.CV.Aruco.CharucoBoard.Draw(System.Drawing.Size,Emgu.CV.IOutputArray,System.Int32,System.Int32)">
            <summary>
            Draw a ChArUco board
            </summary>
            <param name="outSize">size of the output image in pixels.</param>
            <param name="img">output image with the board. The size of this image will be outSize and the board will be on the center, keeping the board proportions.</param>
            <param name="margindSize">minimum margins (in pixels) of the board in the output image</param>
            <param name="borderBits">width of the marker borders.</param>
        </member>
        <member name="M:Emgu.CV.Aruco.CharucoBoard.DisposeObject">
            <summary>
            Release the unmanaged resource associated with this ChArUco board
            </summary>
        </member>
        <member name="P:Emgu.CV.Aruco.CharucoBoard.BoardPtr">
            <summary>
            Pointer to native IBoard
            </summary>
        </member>
        <member name="T:Emgu.CV.BgSegm.BackgroundSubtractorGMG">
            <summary>
            Background Subtractor module based on the algorithm given in:
            Andrew B. Godbehere, Akihiro Matsukawa, Ken Goldberg, 
            Visual Tracking of Human Visitors under Variable-Lighting Conditions for a Responsive Audio Art Installation, 
            American Control Conference, Montreal, June 2012.
            </summary>
        </member>
        <member name="M:Emgu.CV.BgSegm.BackgroundSubtractorGMG.#ctor(System.Int32,System.Double)">
            <summary>
            Create a background subtractor module based on GMG
            </summary>
            <param name="initializationFrames">Number of frames used to initialize the background models.</param>
            <param name="decisionThreshold">Threshold value, above which it is marked foreground, else background.</param>
        </member>
        <member name="M:Emgu.CV.BgSegm.BackgroundSubtractorGMG.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this background model.
            </summary>
        </member>
        <member name="T:Emgu.CV.ContribInvoke">
            <summary>
            Class that contains entry points for the Contrib module.
            </summary>
        </member>
        <member name="T:Emgu.CV.BgSegm.BackgroundSubtractorMOG">
            <summary>
            Gaussian Mixture-based Background/Foreground Segmentation Algorithm.
            The class implements the following algorithm:
            "An improved adaptive background mixture model for real-time tracking with shadow detection"
            P. KadewTraKuPong and R. Bowden,
            Proc. 2nd European Workshp on Advanced Video-Based Surveillance Systems, 2001."
            http://personal.ee.surrey.ac.uk/Personal/R.Bowden/publications/avbs01/avbs01.pdf
            </summary>
        </member>
        <member name="M:Emgu.CV.BgSegm.BackgroundSubtractorMOG.#ctor(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Create an "Improved adaptive Gaussian mixture model for background subtraction".
            </summary>
            <param name="history">The length of the history.</param>
            <param name="nMixtures">The maximum number of gaussian mixtures.</param>
            <param name="backgroundRatio">Background ratio</param>
            <param name="noiseSigma">Noise strength (standard deviation of the brightness or each color channel). 0 means some automatic value.</param>
        </member>
        <member name="M:Emgu.CV.BgSegm.BackgroundSubtractorMOG.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this background model.
            </summary>
        </member>
        <member name="T:Emgu.CV.Bioinspired.Retina">
             <summary>
             A wrapper class which allows the Gipsa/Listic Labs model to be used.
             This retina model allows spatio-temporal image processing (applied on still images, video sequences).
             As a summary, these are the retina model properties:
             1. It applies a spectral whithening (mid-frequency details enhancement);
             2. high frequency spatio-temporal noise reduction;
             3. low frequency luminance to be reduced (luminance range compression);
             4. local logarithmic luminance compression allows details to be enhanced in low light conditions.
             USE : this model can be used basically for spatio-temporal video effects but also for :
                 _using the getParvo method output matrix : texture analysiswith enhanced signal to noise ratio and enhanced details robust against input images luminance ranges
                  _using the getMagno method output matrix : motion analysis also with the previously cited properties
                  
             For more information, reer to the following papers :
             Benoit A., Caplier A., Durette B., Herault, J., "USING HUMAN VISUAL SYSTEM MODELING FOR BIO-INSPIRED LOW LEVEL IMAGE PROCESSING", Elsevier, Computer Vision and Image Understanding 114 (2010), pp. 758-773, DOI: http://dx.doi.org/10.1016/j.cviu.2010.01.011
             Vision: Images, Signals and Neural Networks: Models of Neural Processing in Visual Perception (Progress in Neural Processing),By: Jeanny Herault, ISBN: 9814273686. WAPI (Tower ID): 113266891.
            
             The retina filter includes the research contributions of phd/research collegues from which code has been redrawn by the author :
             _take a look at the retinacolor.hpp module to discover Brice Chaix de Lavarene color mosaicing/demosaicing and the reference paper:
             B. Chaix de Lavarene, D. Alleysson, B. Durette, J. Herault (2007). "Efficient demosaicing through recursive filtering", IEEE International Conference on Image Processing ICIP 2007
             _take a look at imagelogpolprojection.hpp to discover retina spatial log sampling which originates from Barthelemy Durette phd with Jeanny Herault. A Retina / V1 cortex projection is also proposed and originates from Jeanny's discussions.
             more informations in the above cited Jeanny Heraults's book.
             </summary>
        </member>
        <member name="M:Emgu.CV.Bioinspired.Retina.#ctor(System.Drawing.Size)">
            <summary>
            Create a retina model
            </summary>
            <param name="inputSize">The input frame size</param>
        </member>
        <member name="M:Emgu.CV.Bioinspired.Retina.#ctor(System.Drawing.Size,System.Boolean,Emgu.CV.Bioinspired.Retina.ColorSamplingMethod,System.Boolean,System.Double,System.Double)">
            <summary>
            Create a retina model
            </summary>
            <param name="inputSize">The input frame size</param>
            <param name="colorMode">Specifies if (true) color is processed of not (false) to then processing gray level image</param>
            <param name="colorSamplingMethod">Specifies which kind of color sampling will be used</param>
            <param name="useRetinaLogSampling">Activate retina log sampling, if true, the 2 following parameters can be used</param>
            <param name="reductionFactor">Only useful if param useRetinaLogSampling=true, specifies the reduction factor of the output frame (as the center (fovea) is high resolution and corners can be underscaled, then a reduction of the output is allowed without precision leak</param>
            <param name="samplingStrength">Only useful if param useRetinaLogSampling=true, specifies the strenght of the log scale that is applied</param>
        </member>
        <member name="M:Emgu.CV.Bioinspired.Retina.Run(Emgu.CV.IInputArray)">
            <summary>
            Method which allows retina to be applied on an input image, after run, encapsulated retina module is ready to deliver its outputs using dedicated acccessors. <seealso cref="M:Emgu.CV.Bioinspired.Retina.GetParvo(Emgu.CV.IOutputArray)"/> and <seealso cref="M:Emgu.CV.Bioinspired.Retina.GetMagno(Emgu.CV.IOutputArray)"/>
            </summary>
            <param name="image">The input image to be processed</param>
        </member>
        <member name="M:Emgu.CV.Bioinspired.Retina.GetParvo(Emgu.CV.IOutputArray)">
            <summary>
            Accessors of the details channel of the retina (models foveal vision)
            </summary>
            <returns>The details channel of the retina.</returns>
        </member>
        <member name="M:Emgu.CV.Bioinspired.Retina.GetMagno(Emgu.CV.IOutputArray)">
            <summary>
            Accessors of the motion channel of the retina (models peripheral vision)
            </summary>
            <returns>The motion channel of the retina.</returns>
        </member>
        <member name="M:Emgu.CV.Bioinspired.Retina.ClearBuffers">
            <summary>
            Clear all retina buffers (equivalent to opening the eyes after a long period of eye close.
            </summary>
        </member>
        <member name="M:Emgu.CV.Bioinspired.Retina.DisposeObject">
            <summary>
            Release all unmanaged memory associated with the retina model.
            </summary>
        </member>
        <member name="P:Emgu.CV.Bioinspired.Retina.Parameters">
            <summary>
            Get or Set the Retina parameters.
            </summary>
        </member>
        <member name="T:Emgu.CV.Bioinspired.Retina.ColorSamplingMethod">
            <summary>
            The retina color sampling method.
            </summary>
        </member>
        <member name="F:Emgu.CV.Bioinspired.Retina.ColorSamplingMethod.ColorRandom">
            <summary>
            Each pixel position is either R, G or B in a random choice
            </summary>
        </member>
        <member name="F:Emgu.CV.Bioinspired.Retina.ColorSamplingMethod.ColorDiagonal">
            <summary>
            Color sampling is RGBRGBRGB..., line 2 BRGBRGBRG..., line 3, GBRGBRGBR...
            </summary>
        </member>
        <member name="F:Emgu.CV.Bioinspired.Retina.ColorSamplingMethod.ColorBayer">
            <summary>
            Standard bayer sampling
            </summary>
        </member>
        <member name="T:Emgu.CV.Bioinspired.Retina.OPLandIplParvoParameters">
            <summary>
            Outer Plexiform Layer (OPL) and Inner Plexiform Layer Parvocellular (IplParvo) parameters 
            </summary>
        </member>
        <member name="F:Emgu.CV.Bioinspired.Retina.OPLandIplParvoParameters.ColorMode">
            <summary>
            Specifies if (true) color is processed of not (false) to then processing gray level image
            </summary>
        </member>
        <member name="F:Emgu.CV.Bioinspired.Retina.OPLandIplParvoParameters.NormaliseOutput">
            <summary>
            Normalise output. Use true for default
            </summary>
        </member>
        <member name="F:Emgu.CV.Bioinspired.Retina.OPLandIplParvoParameters.PhotoreceptorsLocalAdaptationSensitivity">
            <summary>
            Photoreceptors local adaptation sensitivity. Use 0.7 for default
            </summary>
        </member>
        <member name="F:Emgu.CV.Bioinspired.Retina.OPLandIplParvoParameters.PhotoreceptorsTemporalConstant">
            <summary>
            Photoreceptors temporal constant. Use 0.5 for default
            </summary>
        </member>
        <member name="F:Emgu.CV.Bioinspired.Retina.OPLandIplParvoParameters.PhotoreceptorsSpatialConstant">
            <summary>
            Photoreceptors spatial constant. Use 0.53 for default
            </summary>
        </member>
        <member name="F:Emgu.CV.Bioinspired.Retina.OPLandIplParvoParameters.HorizontalCellsGain">
            <summary>
            Horizontal cells gain. Use 0.0 for default
            </summary>
        </member>
        <member name="F:Emgu.CV.Bioinspired.Retina.OPLandIplParvoParameters.HcellsTemporalConstant">
            <summary>
            Hcells temporal constant. Use 1.0 for default
            </summary>
        </member>
        <member name="F:Emgu.CV.Bioinspired.Retina.OPLandIplParvoParameters.HcellsSpatialConstant">
            <summary>
            Hcells spatial constant. Use 7.0 for default
            </summary>
        </member>
        <member name="F:Emgu.CV.Bioinspired.Retina.OPLandIplParvoParameters.GanglionCellsSensitivity">
            <summary>
            Ganglion cells sensitivity. Use 0.7 for default
            </summary>
        </member>
        <member name="T:Emgu.CV.Bioinspired.Retina.IplMagnoParameters">
            <summary>
            Inner Plexiform Layer Magnocellular channel (IplMagno)
            </summary>
        </member>
        <member name="F:Emgu.CV.Bioinspired.Retina.IplMagnoParameters.NormaliseOutput">
            <summary>
            Normalise output
            </summary>
        </member>
        <member name="F:Emgu.CV.Bioinspired.Retina.IplMagnoParameters.ParasolCellsBeta">
            <summary>
            ParasolCells_beta. Use 0.0 for default
            </summary>
        </member>
        <member name="F:Emgu.CV.Bioinspired.Retina.IplMagnoParameters.ParasolCellsTau">
            <summary>
            ParasolCells_tau. Use 0.0 for default
            </summary>
        </member>
        <member name="F:Emgu.CV.Bioinspired.Retina.IplMagnoParameters.ParasolCellsK">
            <summary>
            ParasolCells_k. Use 7.0 for default
            </summary>
        </member>
        <member name="F:Emgu.CV.Bioinspired.Retina.IplMagnoParameters.AmacrinCellsTemporalCutFrequency">
            <summary>
            Amacrin cells temporal cut frequency. Use 1.2 for default
            </summary>
        </member>
        <member name="F:Emgu.CV.Bioinspired.Retina.IplMagnoParameters.V0CompressionParameter">
            <summary>
            V0 compression parameter. Use 0.95 for default
            </summary>
        </member>
        <member name="F:Emgu.CV.Bioinspired.Retina.IplMagnoParameters.LocalAdaptintegrationTau">
            <summary>
            LocalAdaptintegration_tau. Use 0.0 for default
            </summary>
        </member>
        <member name="F:Emgu.CV.Bioinspired.Retina.IplMagnoParameters.LocalAdaptintegrationK">
            <summary>
            LocalAdaptintegration_k. Use 7.0 for default
            </summary>
        </member>
        <member name="T:Emgu.CV.Bioinspired.Retina.RetinaParameters">
            <summary>
            Retina parameters
            </summary>
        </member>
        <member name="F:Emgu.CV.Bioinspired.Retina.RetinaParameters.OPLandIplParvo">
            <summary>
            Outer Plexiform Layer (OPL) and Inner Plexiform Layer Parvocellular (IplParvo) parameters 
            </summary>
        </member>
        <member name="F:Emgu.CV.Bioinspired.Retina.RetinaParameters.IplMagno">
            <summary>
            Inner Plexiform Layer Magnocellular channel (IplMagno)
            </summary>
        </member>
        <member name="T:Emgu.CV.Bioinspired.BioinspiredInvoke">
            <summary>
            Entry points to the Open CV bioinspired module
            </summary>
        </member>
        <member name="T:Emgu.CV.Dpm.DpmDetector">
            <summary>
            A deformable parts model detector
            </summary>
        </member>
        <member name="M:Emgu.CV.Dpm.DpmDetector.Create(System.String[],System.String[])">
            <summary>
            create a new dpm detector with the specified files and classes
            </summary>
            <param name="files"></param>
            <param name="classes"></param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.Dpm.DpmDetector.Detect(Emgu.CV.Mat)">
            <summary>
            Perform detection on the image
            </summary>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.Dpm.DpmDetector.DisposeObject">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="P:Emgu.CV.Dpm.DpmDetector.IsEmpty">
            <summary>
            Is the detector empty?
            </summary>
        </member>
        <member name="P:Emgu.CV.Dpm.DpmDetector.ClassNames">
            <summary>
            get the class names
            </summary>
        </member>
        <member name="P:Emgu.CV.Dpm.DpmDetector.ClassCount">
            <summary>
            get the number of classes
            </summary>
        </member>
        <member name="T:Emgu.CV.Dpm.DpmInvoke">
            <summary>
            Provide interfaces to the Open CV DPM functions
            </summary>
        </member>
        <member name="T:Emgu.CV.Dpm.ObjectDetection">
            <summary>
            A DPM detection
            </summary>
        </member>
        <member name="F:Emgu.CV.Dpm.ObjectDetection.Rect">
            <summary>
            rectangle
            </summary>
        </member>
        <member name="F:Emgu.CV.Dpm.ObjectDetection.Score">
            <summary>
            detection score
            </summary>
        </member>
        <member name="F:Emgu.CV.Dpm.ObjectDetection.ClassId">
            <summary>
            class of the detection
            </summary>
        </member>
        <member name="M:Emgu.CV.Dpm.ObjectDetection.#ctor(System.Drawing.Rectangle,System.Single,System.Int32)">
            <summary>
            create a detection
            </summary>
            <param name="rect"></param>
            <param name="score"></param>
            <param name="classId"></param>
        </member>
        <member name="T:Emgu.CV.Face.BIF">
            <summary>
            Implementation of bio-inspired features (BIF) from the paper: Guo, Guodong, et al. "Human age estimation using bio-inspired features." Computer Vision and Pattern Recognition, 2009. CVPR 2009.
            </summary>
        </member>
        <member name="M:Emgu.CV.Face.BIF.#ctor(System.Int32,System.Int32)">
            <summary>
            Create an instance of bio-inspired features
            </summary>
            <param name="numBands">The number of filter bands used for computing BIF.</param>
            <param name="numRotations">The number of image rotations.</param>
        </member>
        <member name="M:Emgu.CV.Face.BIF.Compute(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Computes features by input image.
            </summary>
            <param name="image">Input image (CV_32FC1)</param>
            <param name="features">Feature vector (CV_32FC1)</param>
        </member>
        <member name="M:Emgu.CV.Face.BIF.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this BIF
            </summary>
        </member>
        <member name="T:Emgu.CV.Face.FaceRecognizer">
            <summary>
            Face Recognizer
            </summary>
        </member>
        <member name="M:Emgu.CV.Face.FaceRecognizer.Train(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Train the face recognizer with the specific images and labels
            </summary>
            <param name="images">The images used in the training. This can be a VectorOfMat</param>
            <param name="labels">The labels of the images. This can be a VectorOfInt</param>
        </member>
        <member name="M:Emgu.CV.Face.FaceRecognizer.Train``2(Emgu.CV.Image{``0,``1}[],System.Int32[])">
            <summary>
            Train the face recognizer with the specific images and labels
            </summary>
            <param name="images">The images used in the training.</param>
            <param name="labels">The labels of the images.</param>
        </member>
        <member name="M:Emgu.CV.Face.FaceRecognizer.Predict(Emgu.CV.IInputArray)">
            <summary>
            Predict the label of the image
            </summary>
            <param name="image">The image where prediction will be based on</param>
            <returns>The prediction label</returns>
        </member>
        <member name="M:Emgu.CV.Face.FaceRecognizer.Write(System.String)">
            <summary>
            Save the FaceRecognizer to a file
            </summary>
            <param name="fileName">The file name to be saved to</param>
        </member>
        <member name="M:Emgu.CV.Face.FaceRecognizer.Read(System.String)">
            <summary>
            Load the FaceRecognizer from the file
            </summary>
            <param name="fileName">The file where the FaceRecognizer will be loaded from</param>
        </member>
        <member name="M:Emgu.CV.Face.FaceRecognizer.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this FaceRecognizer
            </summary>
        </member>
        <member name="T:Emgu.CV.Face.FaceRecognizer.PredictionResult">
            <summary>
            The prediction result
            </summary>
        </member>
        <member name="F:Emgu.CV.Face.FaceRecognizer.PredictionResult.Label">
            <summary>
            The label
            </summary>
        </member>
        <member name="F:Emgu.CV.Face.FaceRecognizer.PredictionResult.Distance">
            <summary>
            The distance
            </summary>
        </member>
        <member name="T:Emgu.CV.Face.EigenFaceRecognizer">
            <summary>
            Eigen face recognizer
            </summary>
        </member>
        <member name="M:Emgu.CV.Face.EigenFaceRecognizer.#ctor(System.Int32,System.Double)">
            <summary>
            Create an EigenFaceRecognizer
            </summary>
            <param name="numComponents">The number of components</param>
            <param name="threshold">The distance threshold</param>
        </member>
        <member name="T:Emgu.CV.Face.FisherFaceRecognizer">
            <summary>
            Fisher face recognizer
            </summary>
        </member>
        <member name="M:Emgu.CV.Face.FisherFaceRecognizer.#ctor(System.Int32,System.Double)">
            <summary>
            Create a FisherFaceRecognizer
            </summary>
            <param name="numComponents">The number of components</param>
            <param name="threshold">The distance threshold</param>
        </member>
        <member name="T:Emgu.CV.Face.LBPHFaceRecognizer">
            <summary>
            LBPH face recognizer
            </summary>
        </member>
        <member name="M:Emgu.CV.Face.LBPHFaceRecognizer.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Double)">
            <summary>
            Create a LBPH face recognizer
            </summary>
            <param name="radius">Radius</param>
            <param name="neighbors">Neighbors</param>
            <param name="gridX">Grid X</param>
            <param name="gridY">Grid Y</param>
            <param name="threshold">The distance threshold</param>
        </member>
        <member name="M:Emgu.CV.Face.LBPHFaceRecognizer.Update(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Updates a FaceRecognizer with given data and associated labels.
            </summary>
            <param name="images">The training images, that means the faces you want to learn. The data has to be given as a VectorOfMat.</param>
            <param name="labels">The labels corresponding to the images</param>
        </member>
        <member name="M:Emgu.CV.Face.LBPHFaceRecognizer.Update``2(Emgu.CV.Image{``0,``1}[],System.Int32[])">
            <summary>
            Update the face recognizer with the specific images and labels
            </summary>
            <param name="images">The images used for updating the face recognizer</param>
            <param name="labels">The labels of the images</param>
        </member>
        <member name="T:Emgu.CV.Fuzzy.FuzzyInvoke">
            <summary>
            The module brings implementation of the image processing algorithms based on fuzzy mathematics.
            </summary>
        </member>
        <member name="M:Emgu.CV.Fuzzy.FuzzyInvoke.CreateKernel(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32)">
            <summary>
            Creates kernel from basic functions.
            </summary>
            <param name="A">Basic function used in axis x.</param>
            <param name="B">Basic function used in axis y.</param>
            <param name="kernel">Final 32-b kernel derived from A and B.</param>
            <param name="chn">Number of kernel channels.</param>
        </member>
        <member name="M:Emgu.CV.Fuzzy.FuzzyInvoke.CreateKernel(Emgu.CV.Fuzzy.FuzzyInvoke.Function,System.Int32,Emgu.CV.IOutputArray,System.Int32)">
            <summary>
            Creates kernel from general functions.
            </summary>
            <param name="function">Function type</param>
            <param name="radius">Radius of the basic function.</param>
            <param name="kernel">Final 32-b kernel.</param>
            <param name="chn">Number of kernel channels.</param>
        </member>
        <member name="M:Emgu.CV.Fuzzy.FuzzyInvoke.Inpaint(Emgu.CV.Mat,Emgu.CV.Mat,Emgu.CV.Mat,System.Int32,Emgu.CV.Fuzzy.FuzzyInvoke.Function,Emgu.CV.Fuzzy.FuzzyInvoke.InpaintAlgorithm)">
            <summary>
            Image inpainting.
            </summary>
            <param name="image">Input image.</param>
            <param name="mask">Mask used for unwanted area marking.</param>
            <param name="output">Output 32-bit image.</param>
            <param name="radius">Radius of the basic function.</param>
            <param name="function">Function type</param>
            <param name="algorithm">Algorithm type</param>
        </member>
        <member name="M:Emgu.CV.Fuzzy.FuzzyInvoke.Filter(Emgu.CV.Mat,Emgu.CV.Mat,Emgu.CV.Mat)">
            <summary>
            Image filtering.
            </summary>
            <param name="image">Input image.</param>
            <param name="kernel">Final 32-b kernel.</param>
            <param name="output">Output 32-bit image.</param>
        </member>
        <member name="T:Emgu.CV.Fuzzy.FuzzyInvoke.Function">
            <summary>
            Function type
            </summary>
        </member>
        <member name="F:Emgu.CV.Fuzzy.FuzzyInvoke.Function.Linear">
            <summary>
            Linear
            </summary>
        </member>
        <member name="F:Emgu.CV.Fuzzy.FuzzyInvoke.Function.Sinus">
            <summary>
            Sinus
            </summary>
        </member>
        <member name="T:Emgu.CV.Fuzzy.FuzzyInvoke.InpaintAlgorithm">
            <summary>
            Inpaint algorithm
            </summary>
        </member>
        <member name="F:Emgu.CV.Fuzzy.FuzzyInvoke.InpaintAlgorithm.OneStep">
            <summary>
            One step algorithm.
            </summary>
        </member>
        <member name="F:Emgu.CV.Fuzzy.FuzzyInvoke.InpaintAlgorithm.MultiStep">
            <summary>
            Algorithm automaticaly increasing radius of the basic function.
            </summary>
        </member>
        <member name="F:Emgu.CV.Fuzzy.FuzzyInvoke.InpaintAlgorithm.Iterative">
            <summary>
            Iterative algorithm running in more steps using partial computations.
            </summary>
        </member>
        <member name="T:Emgu.CV.ImgHash.AverageHash">
            <summary>
            Computes average hash value of the input image.
            </summary>
            <remarks>This is a fast image hashing algorithm, but only work on simple case.</remarks>
        </member>
        <member name="T:Emgu.CV.ImgHash.ImgHashBase">
            <summary>
            The Image Hash base class
            </summary>
        </member>
        <member name="F:Emgu.CV.ImgHash.ImgHashBase._imgHashBase">
            <summary>
            The pointer to the ImgHashBase object
            </summary>
        </member>
        <member name="M:Emgu.CV.ImgHash.ImgHashBase.DisposeObject">
            <summary>
            Reset the pointers
            </summary>
        </member>
        <member name="M:Emgu.CV.ImgHash.ImgHashBase.Compute(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Computes hash of the input image
            </summary>
            <param name="inputArr">input image to compute hash value</param>
            <param name="outputArr">hash of the image</param>
        </member>
        <member name="M:Emgu.CV.ImgHash.ImgHashBase.Compare(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Compare the hash value between inOne and inTwo
            </summary>
            <param name="hashOne">Hash value one</param>
            <param name="hashTwo">Hash value two</param>
            <returns>indicate similarity between inOne and inTwo, the meaning of the value vary from algorithms to algorithms</returns>
        </member>
        <member name="P:Emgu.CV.ImgHash.ImgHashBase.ImgHashBasePtr">
            <summary>
            Get the pointer to the ImgHashBase object
            </summary>
            <returns>The pointer to the ImgHashBase object</returns>
        </member>
        <member name="M:Emgu.CV.ImgHash.AverageHash.#ctor">
            <summary>
            Create an average hash object.
            </summary>
        </member>
        <member name="M:Emgu.CV.ImgHash.AverageHash.DisposeObject">
            <summary>
            Release all the unmanaged resource associated with AverageHash
            </summary>
        </member>
        <member name="T:Emgu.CV.ImgHash.ImgHashInvoke">
            <summary>
            The module brings implementation of the image processing algorithms based on fuzzy mathematics.
            </summary>
        </member>
        <member name="T:Emgu.CV.ImgHash.BlockMeanHash">
            <summary>
            Image hash based on block mean.
            </summary>
        </member>
        <member name="M:Emgu.CV.ImgHash.BlockMeanHash.#ctor(Emgu.CV.ImgHash.BlockMeanHash.Mode)">
            <summary>
            Create a Block Mean Hash object
            </summary>
            <param name="mode">The hash mode</param>
        </member>
        <member name="M:Emgu.CV.ImgHash.BlockMeanHash.DisposeObject">
            <summary>
            Release all the unmanaged resource associated with BlockMeanHash
            </summary>
        </member>
        <member name="T:Emgu.CV.ImgHash.BlockMeanHash.Mode">
            <summary>
            Block Mean Hash mode
            </summary>
        </member>
        <member name="F:Emgu.CV.ImgHash.BlockMeanHash.Mode.HashMode0">
            <summary>
            use fewer block and generate 16*16/8 uchar hash value
            </summary>
        </member>
        <member name="F:Emgu.CV.ImgHash.BlockMeanHash.Mode.HashMode1">
            <summary>
            use block blocks(step sizes/2), generate 31*31/8 + 1 uchar hash value
            </summary>
        </member>
        <member name="T:Emgu.CV.ImgHash.ColorMomentHash">
            <summary>
            Image hash based on color moments.
            </summary>
        </member>
        <member name="M:Emgu.CV.ImgHash.ColorMomentHash.#ctor">
            <summary>
            Create a Color Moment Hash object
            </summary>
        </member>
        <member name="M:Emgu.CV.ImgHash.ColorMomentHash.DisposeObject">
            <summary>
            Release all the unmanaged resource associated with ColorMomentHash
            </summary>
        </member>
        <member name="T:Emgu.CV.ImgHash.MarrHildrethHash">
            <summary>
            Marr-Hildreth Operator Based Hash, slowest but more discriminative.
            </summary>
        </member>
        <member name="M:Emgu.CV.ImgHash.MarrHildrethHash.#ctor(System.Single,System.Single)">
            <summary>
            Create a Marr-Hildreth operator based hash.
            </summary>
            <param name="alpha">Scale factor for marr wavelet.</param>
            <param name="scale">Level of scale factor</param>
        </member>
        <member name="M:Emgu.CV.ImgHash.MarrHildrethHash.DisposeObject">
            <summary>
            Release all the unmanaged resource associated with MarrHildrethHash
            </summary>
        </member>
        <member name="T:Emgu.CV.ImgHash.PHash">
            <summary>
            Slower than average hash, but tolerant of minor modifications
            </summary>
        </member>
        <member name="M:Emgu.CV.ImgHash.PHash.#ctor">
            <summary>
            Create a PHash object
            </summary>
        </member>
        <member name="M:Emgu.CV.ImgHash.PHash.DisposeObject">
            <summary>
            Release all the unmanaged resource associated with AverageHash
            </summary>
        </member>
        <member name="T:Emgu.CV.ImgHash.RadialVarianceHash">
            <summary>
            Image hash based on Radon transform
            </summary>
        </member>
        <member name="M:Emgu.CV.ImgHash.RadialVarianceHash.#ctor(System.Double,System.Int32)">
            <summary>
            Create an image hash based on Radon transform
            </summary>
            <param name="sigma">Sigma</param>
            <param name="numOfAngleLine">Number of angle line</param>
        </member>
        <member name="M:Emgu.CV.ImgHash.RadialVarianceHash.DisposeObject">
            <summary>
            Release all the unmanaged resource associated with RadialVarianceHash
            </summary>
        </member>
        <member name="T:Emgu.CV.LineDescriptor.BinaryDescriptor">
            <summary>
            Class implements both functionalities for detection of lines and computation of their binary descriptor.
            </summary>
        </member>
        <member name="M:Emgu.CV.LineDescriptor.BinaryDescriptor.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Emgu.CV.LineDescriptor.BinaryDescriptor.Detect(Emgu.CV.Mat,Emgu.CV.LineDescriptor.VectorOfKeyLine,Emgu.CV.Mat)">
            <summary>
            Line detection.
            </summary>
            <param name="image">Input image</param>
            <param name="keylines">Vector that will store extracted lines for one or more images</param>
            <param name="mask">Mask matrix to detect only KeyLines of interest</param>
        </member>
        <member name="M:Emgu.CV.LineDescriptor.BinaryDescriptor.Compute(Emgu.CV.Mat,Emgu.CV.LineDescriptor.VectorOfKeyLine,Emgu.CV.Mat,System.Boolean)">
            <summary>
            Descriptors computation.
            </summary>
            <param name="image">Input image</param>
            <param name="keylines">Vector containing lines for which descriptors must be computed</param>
            <param name="descriptors">Computed descriptors will be stored here</param>
            <param name="returnFloatDescr">When true, original non-binary descriptors are returned</param>
        </member>
        <member name="M:Emgu.CV.LineDescriptor.BinaryDescriptor.DisposeObject">
            <summary>
            Release unmanaged memory associated with this binary descriptor
            </summary>
        </member>
        <member name="T:Emgu.CV.LineDescriptor.LineDescriptorInvoke">
            <summary>
            Entry points for LineDescriptor module
            </summary>
        </member>
        <member name="T:Emgu.CV.LineDescriptor.LSDDetector">
            <summary>
            The lines extraction methodology described in the following is mainly based on: R Grompone Von Gioi, Jeremie Jakubowicz, Jean-Michel Morel, and Gregory Randall. Lsd: A fast line segment detector with a false detection control. IEEE Transactions on Pattern Analysis and Machine Intelligence, 32(4):722732, 2010.
            </summary>
        </member>
        <member name="M:Emgu.CV.LineDescriptor.LSDDetector.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Emgu.CV.LineDescriptor.LSDDetector.Detect(Emgu.CV.Mat,Emgu.CV.LineDescriptor.VectorOfKeyLine,System.Int32,System.Int32,Emgu.CV.Mat)">
            <summary>
            Detect lines inside an image.
            </summary>
            <param name="image">	input image</param>
            <param name="keylines">vector that will store extracted lines for one or more images</param>
            <param name="scale">scale factor used in pyramids generation</param>
            <param name="numOctaves">number of octaves inside pyramid</param>
            <param name="mask">	mask matrix to detect only KeyLines of interest</param>
        </member>
        <member name="M:Emgu.CV.LineDescriptor.LSDDetector.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this object.
            </summary>
        </member>
        <member name="T:Emgu.CV.LineDescriptor.MKeyLine">
            <summary>
            A class to represent a line.
            </summary>
        </member>
        <member name="F:Emgu.CV.LineDescriptor.MKeyLine.Angle">
            <summary>
            Orientation of the line
            </summary>
        </member>
        <member name="F:Emgu.CV.LineDescriptor.MKeyLine.ClassId">
            <summary>
            Object ID, that can be used to cluster keylines by the line they represent
            </summary>
        </member>
        <member name="F:Emgu.CV.LineDescriptor.MKeyLine.Octave">
            <summary>
            Octave (pyramid layer), from which the keyline has been extracted 
            </summary>
        </member>
        <member name="F:Emgu.CV.LineDescriptor.MKeyLine.Pt">
            <summary>
            Coordinates of the middlepoint
            </summary>
        </member>
        <member name="F:Emgu.CV.LineDescriptor.MKeyLine.Response">
            <summary>
            The response, by which the strongest keylines have been selected.
            It's represented by the ratio between line's length and maximum between
            image's width and height 
            </summary>
        </member>
        <member name="F:Emgu.CV.LineDescriptor.MKeyLine.Size">
            <summary>
            Minimum area containing line
            </summary>
        </member>
        <member name="F:Emgu.CV.LineDescriptor.MKeyLine.StartPointX">
            <summary>
            Lines's extremes in original image 
            </summary>
        </member>
        <member name="F:Emgu.CV.LineDescriptor.MKeyLine.StartPointY">
            <summary>
            Lines's extremes in original image 
            </summary>
        </member>
        <member name="F:Emgu.CV.LineDescriptor.MKeyLine.EndPointX">
            <summary>
            Lines's extremes in original image 
            </summary>
        </member>
        <member name="F:Emgu.CV.LineDescriptor.MKeyLine.EndPointY">
            <summary>
            Lines's extremes in original image 
            </summary>
        </member>
        <member name="F:Emgu.CV.LineDescriptor.MKeyLine.SPointInOctaveX">
            <summary>
            Line's extremes in image it was extracted from
            </summary>
        </member>
        <member name="F:Emgu.CV.LineDescriptor.MKeyLine.SPointInOctaveY">
            <summary>
            Line's extremes in image it was extracted from
            </summary>
        </member>
        <member name="F:Emgu.CV.LineDescriptor.MKeyLine.EPointInOctaveX">
            <summary>
            Line's extremes in image it was extracted from
            </summary>
        </member>
        <member name="F:Emgu.CV.LineDescriptor.MKeyLine.EPointInOctaveY">
            <summary>
            Line's extremes in image it was extracted from
            </summary>
        </member>
        <member name="F:Emgu.CV.LineDescriptor.MKeyLine.LineLength">
            <summary>
            The length of line
            </summary>
        </member>
        <member name="F:Emgu.CV.LineDescriptor.MKeyLine.NumOfPixels">
            <summary>
            Number of pixels covered by the line
            </summary>
        </member>
        <member name="T:Emgu.CV.LineDescriptor.VectorOfKeyLine">
            <summary>
            Wrapped class of the C++ standard vector of KeyLine.
            </summary>
        </member>
        <member name="M:Emgu.CV.LineDescriptor.VectorOfKeyLine.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.LineDescriptor.VectorOfKeyLine.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.LineDescriptor.VectorOfKeyLine.#ctor">
            <summary>
            Create an empty standard vector of KeyLine
            </summary>
        </member>
        <member name="M:Emgu.CV.LineDescriptor.VectorOfKeyLine.#ctor(System.Int32)">
            <summary>
            Create an standard vector of KeyLine of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.LineDescriptor.VectorOfKeyLine.#ctor(Emgu.CV.LineDescriptor.MKeyLine[])">
            <summary>
            Create an standard vector of KeyLine with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.LineDescriptor.VectorOfKeyLine.Push(Emgu.CV.LineDescriptor.MKeyLine[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.LineDescriptor.VectorOfKeyLine.Push(Emgu.CV.LineDescriptor.VectorOfKeyLine)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.LineDescriptor.VectorOfKeyLine.ToArray">
            <summary>
            Convert the standard vector to an array of KeyLine
            </summary>
            <returns>An array of KeyLine</returns>
        </member>
        <member name="M:Emgu.CV.LineDescriptor.VectorOfKeyLine.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.LineDescriptor.VectorOfKeyLine.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.LineDescriptor.VectorOfKeyLine.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.LineDescriptor.VectorOfKeyLine.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.LineDescriptor.VectorOfKeyLine.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.LineDescriptor.VectorOfKeyLine.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.LineDescriptor.VectorOfKeyLine.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.LineDescriptor.VectorOfKeyLine.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.LineDescriptor.VectorOfKeyLine.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Plot.Plot2d">
            <summary>
            A 2D plot
            </summary>
        </member>
        <member name="M:Emgu.CV.Plot.Plot2d.#ctor(Emgu.CV.Mat)">
            <summary>
            Create 2D plot from data
            </summary>
            <param name="data">The data to be plotted</param>
        </member>
        <member name="M:Emgu.CV.Plot.Plot2d.#ctor(Emgu.CV.Mat,Emgu.CV.Mat)">
            <summary>
            Create 2D plot for data
            </summary>
            <param name="dataX">The data for the X-axis</param>
            <param name="dataY">The data for the Y-axis</param>
        </member>
        <member name="M:Emgu.CV.Plot.Plot2d.Render(Emgu.CV.Mat)">
            <summary>
            Render the plot to the resulting Mat
            </summary>
            <param name="result">The output plot</param>
        </member>
        <member name="M:Emgu.CV.Plot.Plot2d.SetPlotLineColor(Emgu.CV.Structure.MCvScalar)">
            <summary>
            Set the line color
            </summary>
            <param name="plotLineColor">The plot line color</param>
        </member>
        <member name="M:Emgu.CV.Plot.Plot2d.SetPlotBackgroundColor(Emgu.CV.Structure.MCvScalar)">
            <summary>
            Set the background color
            </summary>
            <param name="plotBackgroundColor">The background color</param>
        </member>
        <member name="M:Emgu.CV.Plot.Plot2d.SetPlotAxisColor(Emgu.CV.Structure.MCvScalar)">
            <summary>
            Set the axis color
            </summary>
            <param name="plotAxisColor">the axis color</param>
        </member>
        <member name="M:Emgu.CV.Plot.Plot2d.SetPlotGridColor(Emgu.CV.Structure.MCvScalar)">
            <summary>
            Set the plot grid color
            </summary>
            <param name="plotGridColor">The plot grid color</param>
        </member>
        <member name="M:Emgu.CV.Plot.Plot2d.SetPlotTextColor(Emgu.CV.Structure.MCvScalar)">
            <summary>
            Set the plot text color
            </summary>
            <param name="plotTextColor">The plot text color</param>
        </member>
        <member name="M:Emgu.CV.Plot.Plot2d.SetPlotSize(System.Int32,System.Int32)">
            <summary>
            Set the plot size
            </summary>
            <param name="width">The width</param>
            <param name="height">The height</param>
        </member>
        <member name="M:Emgu.CV.Plot.Plot2d.DisposeObject">
            <summary>
            Release unmanaged memory associated with this plot2d.
            </summary>
        </member>
        <member name="M:Emgu.CV.Plot.Plot2d.SetMinX(System.Double)">
            <summary>
            Min X
            </summary>
        </member>
        <member name="M:Emgu.CV.Plot.Plot2d.SetMinY(System.Double)">
            <summary>
            Min Y
            </summary>
        </member>
        <member name="M:Emgu.CV.Plot.Plot2d.SetMaxX(System.Double)">
            <summary>
            Max X
            </summary>
        </member>
        <member name="M:Emgu.CV.Plot.Plot2d.SetMaxY(System.Double)">
            <summary>
            Max Y
            </summary>
        </member>
        <member name="M:Emgu.CV.Plot.Plot2d.SetPlotLineWidth(System.Int32)">
            <summary>
            Plot line width
            </summary>
        </member>
        <member name="T:Emgu.CV.Plot.PlotInvoke">
            <summary>
            Entry points for the cv::plot functions
            </summary>
        </member>
        <member name="T:Emgu.CV.Saliency.Saliency">
            <summary>
            Base abstract class for Saliency algorithms:
            </summary>
        </member>
        <member name="M:Emgu.CV.Saliency.Saliency.#ctor(System.String)">
            <summary>
            Creates a specialized saliency algorithm by its name.
            </summary>
            <param name="saliencyType"></param>
        </member>
        <member name="M:Emgu.CV.Saliency.Saliency.Compute(Emgu.CV.Mat,Emgu.CV.IOutputArray)">
            <summary>
            Performs all the operations, according to the specific algorithm created, to obtain the saliency map.
            </summary>
            <param name="image"></param>
            <param name="saliencyMap"></param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.Saliency.Saliency.DisposeObject">
            <summary>
            dispose
            </summary>
        </member>
        <member name="P:Emgu.CV.Saliency.Saliency.AlgorithmPtr">
            <summary>
            pointer to the saliency object
            </summary>
        </member>
        <member name="T:Emgu.CV.Saliency.Objectness">
            <summary>
            reflects how likely an image window covers an object of any category
            </summary>
        </member>
        <member name="M:Emgu.CV.Saliency.Objectness.#ctor(System.String)">
            <summary>
            constructor
            </summary>
            <param name="saliencyType"></param>
        </member>
        <member name="T:Emgu.CV.Saliency.MotionSaliency">
            <summary>
            detect salient objects over time (hence also over frame)
            </summary>
        </member>
        <member name="M:Emgu.CV.Saliency.MotionSaliency.#ctor(System.String)">
            <summary>
            constructor
            </summary>
            <param name="saliencyType"></param>
        </member>
        <member name="T:Emgu.CV.Saliency.StaticSaliency">
            <summary>
            detect salient objects in a non dynamic scenarios.
            </summary>
        </member>
        <member name="M:Emgu.CV.Saliency.StaticSaliency.#ctor(System.String)">
            <summary>
            constructor
            </summary>
            <param name="saliencyType"></param>
        </member>
        <member name="M:Emgu.CV.Saliency.StaticSaliency.ComputeBinaryMap(Emgu.CV.Mat,Emgu.CV.Mat)">
            <summary>
            perform a binary map of given saliency map
            </summary>
            <param name="saliencyMap">the saliency map obtained through one of the specialized algorithms</param>
            <param name="binaryMap">the binary map</param>
            <returns></returns>
        </member>
        <member name="T:Emgu.CV.Saliency.SpectralResidualSaliency">
            <summary>
            simulate the behavior of pre-attentive visual search
            </summary>
        </member>
        <member name="M:Emgu.CV.Saliency.SpectralResidualSaliency.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="T:Emgu.CV.Saliency.FineGrainedSaliency">
            <summary>
            This method calculates saliency based on center-surround differences
            </summary>
        </member>
        <member name="M:Emgu.CV.Saliency.FineGrainedSaliency.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="T:Emgu.CV.Saliency.BinWangApr2014Saliency">
            <summary>
            the Fast Self-tuning Background Subtraction Algorithm
            </summary>
        </member>
        <member name="M:Emgu.CV.Saliency.BinWangApr2014Saliency.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="M:Emgu.CV.Saliency.BinWangApr2014Saliency.Init">
            <summary>
            This function allows the correct initialization of all data structures that will be used by the algorithm. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.Saliency.BinWangApr2014Saliency.SetImageSize(System.Int32,System.Int32)">
            <summary>
            set the correct size (taken from the input image) in the corresponding variables that will be used to size the data structures of the algorithm. 
            </summary>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="T:Emgu.CV.Saliency.ObjectnessBing">
            <summary>
            Objectness algorithms based on [3] [3] Cheng, Ming-Ming, et al. "BING: Binarized normed gradients for objectness estimation at 300fps." IEEE CVPR. 2014
            </summary>
        </member>
        <member name="M:Emgu.CV.Saliency.ObjectnessBing.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="M:Emgu.CV.Saliency.ObjectnessBing.GetObjectnessValues">
            <summary>
            Return the list of the rectangles' objectness value,. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.Saliency.ObjectnessBing.Compute(Emgu.CV.Mat,Emgu.CV.Util.VectorOfRect)">
            <summary>
            Performs all the operations and calls all internal functions necessary for the accomplishment of the Binarized normed gradients algorithm. 
            </summary>
            <param name="image"></param>
            <param name="boxes"></param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.Saliency.ObjectnessBing.SetTrainingPath(System.String)">
            <summary>
            set the correct path from which the algorithm will load the trained model. 
            </summary>
            <param name="trainingPath"></param>
        </member>
        <member name="T:Emgu.CV.Saliency.SaliencyInvoke">
            <summary>
            Provide interfaces to the Open CV Saliency functions
            </summary>
        </member>
        <member name="T:Emgu.CV.Text.ERFilter">
            <summary>
            Base class for 1st and 2nd stages of Neumann and Matas scene text detection algorithm
            </summary>
        </member>
        <member name="M:Emgu.CV.Text.ERFilter.DisposeObject">
            <summary>
            Release all the unmanaged memory associate with this ERFilter
            </summary>
        </member>
        <member name="M:Emgu.CV.Text.ERFilter.Run(Emgu.CV.IInputArray,Emgu.CV.Text.VectorOfERStat)">
            <summary>
            Takes image on input and returns the selected regions in a vector of ERStat only distinctive ERs which correspond to characters are selected by a sequential classifier
            </summary>
            <param name="image">Sinle channel image CV_8UC1</param>
            <param name="regions">Output for the 1st stage and Input/Output for the 2nd. The selected Extremal Regions are stored here.</param>
        </member>
        <member name="M:Emgu.CV.Text.ERFilter.ERGrouping(Emgu.CV.IInputArray,Emgu.CV.IInputArrayOfArrays,Emgu.CV.Text.VectorOfERStat[],Emgu.CV.Text.ERFilter.GroupingMethod,System.String,System.Single)">
            <summary>
            Find groups of Extremal Regions that are organized as text blocks.
            </summary>
            <param name="image">The image where ER grouping is to be perform on</param>
            <param name="channels">Array of single channel images from which the regions were extracted</param>
            <param name="erstats">Vector of ERs retrieved from the ERFilter algorithm from each channel</param>
            <param name="groupingTrainedFileName">The XML or YAML file with the classifier model (e.g. trained_classifier_erGrouping.xml)</param>
            <param name="minProbability">The minimum probability for accepting a group.</param>
            <param name="groupMethods">The grouping methods</param>
            <returns>The output of the algorithm that indicates the text regions</returns>
        </member>
        <member name="T:Emgu.CV.Text.ERFilter.GroupingMethod">
            <summary>
            The grouping method
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.ERFilter.GroupingMethod.OrientationHoriz">
            <summary>
            Only perform grouping horizontally.
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.ERFilter.GroupingMethod.OrientationAny">
            <summary>
            Perform grouping in any orientation.
            </summary>
        </member>
        <member name="T:Emgu.CV.Text.ERFilterNM1">
            <summary>
            Extremal Region Filter for the 1st stage classifier of N&amp;M algorithm
            </summary>
        </member>
        <member name="M:Emgu.CV.Text.ERFilterNM1.#ctor(System.String,System.Int32,System.Single,System.Single,System.Single,System.Boolean,System.Single)">
            <summary>
            Create an Extremal Region Filter for the 1st stage classifier of N&amp;M algorithm
            </summary>
            <param name="classifierFileName">The file name of the classifier</param>
            <param name="thresholdDelta">Threshold step in subsequent thresholds when extracting the component tree.</param>
            <param name="minArea">The minimum area (% of image size) allowed for retreived ERs.</param>
            <param name="maxArea">The maximum area (% of image size) allowed for retreived ERs.</param>
            <param name="minProbability">The minimum probability P(er|character) allowed for retreived ERs.</param>
            <param name="nonMaxSuppression">Whenever non-maximum suppression is done over the branch probabilities.</param>
            <param name="minProbabilityDiff">The minimum probability difference between local maxima and local minima ERs.</param>
        </member>
        <member name="T:Emgu.CV.Text.ERFilterNM2">
            <summary>
            Extremal Region Filter for the 2nd stage classifier of N&amp;M algorithm
            </summary>
        </member>
        <member name="M:Emgu.CV.Text.ERFilterNM2.#ctor(System.String,System.Single)">
            <summary>
            Create an Extremal Region Filter for the 2nd stage classifier of N&amp;M algorithm
            </summary>
            <param name="classifierFileName">The file name of the classifier</param>
            <param name="minProbability">The minimum probability P(er|character) allowed for retreived ERs.</param>
        </member>
        <member name="T:Emgu.CV.Text.ERFilterNMMode">
            <summary>
            computeNMChannels operation modes
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.ERFilterNMMode.RGBLGrad">
            <summary>
            A combination of red (R), green (G), blue (B), lightness (L), and gradient
            magnitude (Grad).
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.ERFilterNMMode.IHSGrad">
            <summary>
            In N&amp;M algorithm, the combination of intensity (I), hue (H), saturation (S), and gradient magnitude
            channels (Grad) are used in order to obtain high localization recall. 
            </summary>
        </member>
        <member name="T:Emgu.CV.Text.TextInvoke">
            <summary>
            This class wraps the functional calls to the OpenCV Text modules
            </summary>
        </member>
        <member name="M:Emgu.CV.Text.TextInvoke.MSERsToERStats(Emgu.CV.IInputArray,Emgu.CV.Util.VectorOfVectorOfPoint,Emgu.CV.Text.VectorOfVectorOfERStat)">
            <summary>
            Converts MSER contours (vector of point) to ERStat regions.
            </summary>
            <param name="image">Source image CV_8UC1 from which the MSERs where extracted.</param>
            <param name="contours">Input vector with all the contours (vector of Point).</param>
            <param name="regions">Output where the ERStat regions are stored.</param>
        </member>
        <member name="M:Emgu.CV.Text.TextInvoke.ComputeNMChannels(Emgu.CV.IInputArray,Emgu.CV.IOutputArrayOfArrays,Emgu.CV.Text.ERFilterNMMode)">
            <summary>
            Compute the different channels to be processed independently in the N&amp;M algorithm.
            </summary>
            <param name="src">Source image. Must be RGB CV_8UC3.</param>
            <param name="channels">Output vector of Mat where computed channels are stored.</param>
            <param name="mode">Mode of operation</param>
        </member>
        <member name="T:Emgu.CV.Text.MCvERStat">
            <summary>
            The ERStat structure represents a class-specific Extremal Region (ER).
            An ER is a 4-connected set of pixels with all its grey-level values smaller than the values in its outer boundary. 
            A class-specific ER is selected (using a classifier) from all the ERs in the component tree of the image.
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.MCvERStat.Pixel">
            <summary>
            Seed point
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.MCvERStat.Level">
            <summary>
            Threshold (max grey-level value)
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.MCvERStat.Area">
            <summary>
            Area
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.MCvERStat.Perimeter">
            <summary>
            Perimeter
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.MCvERStat.Euler">
            <summary>
            Euler number
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.MCvERStat.Rect">
            <summary>
            Bounding box
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.MCvERStat.RawMoments0">
            <summary>
            Order 1 raw moments to derive the centroid
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.MCvERStat.RawMoments1">
            <summary>
            Order 1 raw moments to derive the centroid
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.MCvERStat.CentralMoments0">
            <summary>
            Order 2 central moments to construct the covariance matrix
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.MCvERStat.CentralMoments1">
            <summary>
            Order 2 central moments to construct the covariance matrix
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.MCvERStat.CentralMoments2">
            <summary>
            Order 2 central moments to construct the covariance matrix
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.MCvERStat.CrossingsOwner">
            <summary>
            Pointer owner to horizontal crossings
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.MCvERStat.CrossingsStored">
            <summary>
            Pointer to horizontal crossings
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.MCvERStat.MedCrossings">
            <summary>
            Median of the crossings at three different height levels
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.MCvERStat.HoleAreaRatio">
            <summary>
            Hole area ratio
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.MCvERStat.ConvexHullRatio">
            <summary>
            Convex hull ratio
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.MCvERStat.NumInflexionPoints">
            <summary>
            Number of inflexion points
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.MCvERStat.Pixels">
            <summary>
            Pointer to pixels
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.MCvERStat.probability">
            <summary>
            Probability that the ER belongs to the class we are looking for
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.MCvERStat.ParentPtr">
            <summary>
            Pointer to the parent ERStat
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.MCvERStat.ChildPtr">
            <summary>
            Pointer to the child ERStat
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.MCvERStat.NextPtr">
            <summary>
            Pointer to the next ERStat
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.MCvERStat.PrevPtr">
            <summary>
            Pointer to the previous ERStat
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.MCvERStat.MaxProbabilityAncestor">
            <summary>
            Pointer to the ERStat that is the max probability ancestor
            </summary>
        </member>
        <member name="F:Emgu.CV.Text.MCvERStat.MinProbabilityAncestor">
            <summary>
            Pointer to the ERStat that is the min probability ancestor
            </summary>
        </member>
        <member name="M:Emgu.CV.Text.MCvERStat.GetCenter(System.Int32)">
            <summary>
            Get the center of the region
            </summary>
            <param name="imageWidth">The source image width</param>
            <returns>The center of the region</returns>
        </member>
        <member name="P:Emgu.CV.Text.MCvERStat.LocalMaxima">
            <summary>
            If or not the regions is a local maxima of the probability
            </summary>
        </member>
        <member name="T:Emgu.CV.Text.VectorOfERStat">
            <summary>
            Wrapped class of the C++ standard vector of ERStat.
            </summary>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfERStat.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfERStat.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serialization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfERStat.#ctor">
            <summary>
            Create an empty standard vector of ERStat
            </summary>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfERStat.#ctor(System.Int32)">
            <summary>
            Create an standard vector of ERStat of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfERStat.#ctor(Emgu.CV.Text.MCvERStat[])">
            <summary>
            Create an standard vector of ERStat with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfERStat.Push(Emgu.CV.Text.MCvERStat[])">
            <summary>
            Push an array of value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfERStat.Push(Emgu.CV.Text.VectorOfERStat)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfERStat.ToArray">
            <summary>
            Convert the standard vector to an array of ERStat
            </summary>
            <returns>An array of ERStat</returns>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfERStat.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfERStat.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfERStat.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfERStat.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfERStat.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="P:Emgu.CV.Text.VectorOfERStat.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Text.VectorOfERStat.StartAddress">
            <summary>
            The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
            </summary>
        </member>
        <member name="P:Emgu.CV.Text.VectorOfERStat.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.Text.VectorOfERStat.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Text.VectorOfVectorOfERStat">
            <summary>
            Wrapped class of the C++ standard vector of VectorOfERStat.
            </summary>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfVectorOfERStat.#ctor">
            <summary>
            Create an empty standard vector of VectorOfERStat
            </summary>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfVectorOfERStat.#ctor(System.Int32)">
            <summary>
            Create an standard vector of VectorOfERStat of the specific size
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfVectorOfERStat.#ctor(Emgu.CV.Text.VectorOfERStat[])">
            <summary>
            Create an standard vector of VectorOfERStat with the initial values
            </summary>
            <param name="values">The initial values</param>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfVectorOfERStat.Clear">
            <summary>
            Clear the vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfVectorOfERStat.Push(Emgu.CV.Text.VectorOfERStat)">
            <summary>
            Push a value into the standard vector
            </summary>
            <param name="value">The value to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfVectorOfERStat.Push(Emgu.CV.Text.VectorOfERStat[])">
            <summary>
            Push multiple values into the standard vector
            </summary>
            <param name="values">The values to be pushed to the vector</param>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfVectorOfERStat.Push(Emgu.CV.Text.VectorOfVectorOfERStat)">
            <summary>
            Push multiple values from the other vector into this vector
            </summary>
            <param name="other">The other vector, from which the values will be pushed to the current vector</param>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfVectorOfERStat.DisposeObject">
            <summary>
            Release the standard vector
            </summary>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfVectorOfERStat.GetInputArray">
            <summary>
            Get the pointer to cv::_InputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfVectorOfERStat.GetOutputArray">
            <summary>
            Get the pointer to cv::_OutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfVectorOfERStat.GetInputOutputArray">
            <summary>
            Get the pointer to cv::_InputOutputArray
            </summary>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfVectorOfERStat.#ctor(Emgu.CV.Text.MCvERStat[][])">
            <summary>
            Create the standard vector of VectorOfERStat 
            </summary>
        </member>
        <member name="M:Emgu.CV.Text.VectorOfVectorOfERStat.ToArrayOfArray">
            <summary>
            Convert the standard vector to arrays of int
            </summary>
            <returns>Arrays of int</returns>
        </member>
        <member name="P:Emgu.CV.Text.VectorOfVectorOfERStat.Size">
            <summary>
            Get the size of the vector
            </summary>
        </member>
        <member name="P:Emgu.CV.Text.VectorOfVectorOfERStat.Item(System.Int32)">
            <summary>
            Get the item in the specific index
            </summary>
            <param name="index">The index</param>
            <returns>The item in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.Text.VectorOfVectorOfERStat.SizeOfItemInBytes">
            <summary>
            The size of the item in this Vector, counted as size in bytes.
            </summary>
        </member>
        <member name="T:Emgu.CV.Tracking.MultiTracker">
            <summary>
            This class is used to track multiple objects using the specified tracker algorithm. The MultiTracker is naive implementation of multiple object tracking. It process the tracked objects independently without any optimization accross the tracked objects.
            </summary>
        </member>
        <member name="M:Emgu.CV.Tracking.MultiTracker.#ctor">
            <summary>
            Constructor. In the case of trackerType is given, it will be set as the default algorithm for all trackers.
            </summary>
        </member>
        <member name="M:Emgu.CV.Tracking.MultiTracker.Add(Emgu.CV.Tracking.Tracker,Emgu.CV.Mat,System.Drawing.Rectangle)">
            <summary>
            Add a new object to be tracked. The defaultAlgorithm will be used the newly added tracker.
            </summary>
            <param name="tracker">The tracker to use for tracking the image</param>
            <param name="image">Input image</param>
            <param name="boundingBox">A rectangle represents ROI of the tracked object</param>
            <returns>True if successfully added</returns>
        </member>
        <member name="M:Emgu.CV.Tracking.MultiTracker.Update(Emgu.CV.Mat,Emgu.CV.Util.VectorOfRect)">
            <summary>
            Update the current tracking status. The result will be saved in the internal storage.
            </summary>
            <param name="image">Input image</param>
            <param name="boundingBox">the tracking result, represent a list of ROIs of the tracked objects.</param>
            <returns>True id update success</returns>
        </member>
        <member name="M:Emgu.CV.Tracking.MultiTracker.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this multi-tracker.
            </summary>
        </member>
        <member name="T:Emgu.CV.Tracking.TrackerBoosting">
            <summary>
            This is a real-time object tracking based on a novel on-line version of the AdaBoost algorithm. 
            The classifier uses the surrounding background as negative examples in update step to avoid the drifting problem.
            </summary>
        </member>
        <member name="T:Emgu.CV.Tracking.Tracker">
            <summary>
            Long-term tracker
            </summary>
        </member>
        <member name="F:Emgu.CV.Tracking.Tracker._trackerPtr">
            <summary>
            The native pointer to the tracker
            </summary>
        </member>
        <member name="M:Emgu.CV.Tracking.Tracker.Init(Emgu.CV.Mat,System.Drawing.Rectangle)">
            <summary>
            Initialize the tracker with a know bounding box that surrounding the target.
            </summary>
            <param name="image">The initial frame</param>
            <param name="boundingBox">The initial bounding box</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.Tracking.Tracker.Update(Emgu.CV.Mat,System.Drawing.Rectangle@)">
            <summary>
            Update the tracker, find the new most likely bounding box for the target.
            </summary>
            <param name="image">The current frame</param>
            <param name="boundingBox">The bounding box that represent the new target location, if true was returned, not modified otherwise</param>
            <returns>True means that target was located and false means that tracker cannot locate target in current frame. Note, that latter does not imply that tracker has failed, maybe target is indeed missing from the frame (say, out of sight)</returns>
        </member>
        <member name="M:Emgu.CV.Tracking.Tracker.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this tracker
            </summary>
        </member>
        <member name="M:Emgu.CV.Tracking.TrackerBoosting.#ctor(System.Int32,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Create a Boosting Tracker
            </summary>
            <param name="numClassifiers">The number of classifiers to use in a OnlineBoosting algorithm</param>
            <param name="samplerOverlap">Search region parameters to use in a OnlineBoosting algorithm</param>
            <param name="samplerSearchFactor">search region parameters to use in a OnlineBoosting algorithm</param>
            <param name="iterationInit">The initial iterations</param>
            <param name="featureSetNumFeatures">Number of features, a good value would be 10*numClassifiers + iterationInit</param>
        </member>
        <member name="M:Emgu.CV.Tracking.TrackerBoosting.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this Boosting Tracker
            </summary>
        </member>
        <member name="T:Emgu.CV.Tracking.TrackerMedianFlow">
            <summary>
            Median Flow tracker implementation.
            The tracker is suitable for very smooth and predictable movements when object is visible throughout
            the whole sequence.It's quite and accurate for this type of problems (in particular, it was shown
            by authors to outperform MIL). During the implementation period the code at
            http://www.aonsquared.co.uk/node/5, the courtesy of the author Arthur Amarra, was used for the
            reference purpose.
            </summary>
        </member>
        <member name="M:Emgu.CV.Tracking.TrackerMedianFlow.#ctor(System.Int32,System.Drawing.Size,System.Int32,Emgu.CV.Structure.MCvTermCriteria,System.Drawing.Size,System.Double)">
            <summary>Create a median flow tracker</summary>
            <param name="pointsInGrid">Points in grid, use 10 for default.</param>
            <param name="winSize">Win size, use (3, 3) for default</param>
            <param name="maxLevel">Max level, use 5 for default.</param>
            <param name="termCriteria">Termination criteria, use count = 20 and eps = 0.3 for default</param>
            <param name="winSizeNCC">win size NCC, use (30, 30) for default</param>
            <param name="maxMedianLengthOfDisplacementDifference">Max median length of displacement difference</param>
        </member>
        <member name="M:Emgu.CV.Tracking.TrackerMedianFlow.DisposeObject">
            <summary>
            Release the unmanaged resources associated with this tracker
            </summary>
        </member>
        <member name="T:Emgu.CV.Tracking.TrackerMIL">
            <summary>
            The MIL algorithm trains a classifier in an online manner to separate the object from the background.
            Multiple Instance Learning avoids the drift problem for a robust tracking.
            Original code can be found here http://vision.ucsd.edu/~bbabenko/project_miltrack.shtml
            </summary>
        </member>
        <member name="M:Emgu.CV.Tracking.TrackerMIL.#ctor(System.Single,System.Int32,System.Single,System.Single,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a MIL Tracker
            </summary>
            <param name="samplerInitInRadius">radius for gathering positive instances during init</param>
            <param name="samplerInitMaxNegNum">negative samples to use during init</param>
            <param name="samplerSearchWinSize">size of search window</param>
            <param name="samplerTrackInRadius">radius for gathering positive instances during tracking</param>
            <param name="samplerTrackMaxPosNum">positive samples to use during tracking</param>
            <param name="samplerTrackMaxNegNum">negative samples to use during tracking</param>
            <param name="featureSetNumFeatures">features</param>
        </member>
        <member name="M:Emgu.CV.Tracking.TrackerMIL.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this tracker
            </summary>
        </member>
        <member name="M:Emgu.CV.Tracking.TrackerTLD.DisposeObject">
            <summary>
            Release the unmanaged resources associated with this tracker
            </summary>
        </member>
        <member name="M:Emgu.CV.Tracking.TrackerKCF.DisposeObject">
            <summary>
            Release the unmanaged resources associated with this tracker
            </summary>
        </member>
        <member name="M:Emgu.CV.Tracking.TrackerGOTURN.DisposeObject">
            <summary>
            Release the unmanaged resources associated with this tracker
            </summary>
        </member>
        <member name="T:Emgu.CV.XFeatures2D.BoostDesc">
            <summary>
            Class implementing BoostDesc (Learning Image Descriptors with Boosting).
            </summary>
            <remarks>
            See: 
            V. Lepetit T. Trzcinski, M. Christoudias and P. Fua. Boosting Binary Keypoint Descriptors. In Computer Vision and Pattern Recognition, 2013.
            M. Christoudias T. Trzcinski and V. Lepetit. Learning Image Descriptors with Boosting. submitted to IEEE Transactions on Pattern Analysis and Machine Intelligence (PAMI), 2013.
            </remarks>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.BoostDesc.#ctor(Emgu.CV.XFeatures2D.BoostDesc.DescriptorType,System.Boolean,System.Single)">
            <summary>
            Create an instance of Boost Descriptor
            </summary>
            <param name="desc">type of descriptor to use</param>
            <param name="useScaleOrientation">sample patterns using keypoints orientation</param>
            <param name="scalefactor">adjust the sampling window of detected keypoints 6.25f is default and fits for KAZE, SURF detected keypoints window ratio 6.75f should be the scale for SIFT detected keypoints window ratio 5.00f should be the scale for AKAZE, MSD, AGAST, FAST, BRISK keypoints window ratio 0.75f should be the scale for ORB keypoints ratio 1.50f was the default in original implementation</param>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.BoostDesc.DisposeObject">
            <summary>
            Release all the unmanaged resource associated with BRIEF
            </summary>
        </member>
        <member name="T:Emgu.CV.XFeatures2D.BoostDesc.DescriptorType">
            <summary>
            The type of descriptor
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.BoostDesc.DescriptorType.Bgm">
            <summary>
            BGM is the base descriptor where each binary dimension is computed as the output of a single weak learner.
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.BoostDesc.DescriptorType.BgmHard">
            <summary>
            BGM_HARD refers to same BGM but use different type of gradient binning. In the BGM_HARD that use ASSIGN_HARD binning type the gradient is assigned to the nearest orientation bin.
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.BoostDesc.DescriptorType.BgmBilinear">
            <summary>
            BGM_BILINEAR refers to same BGM but use different type of gradient binning. In the BGM_BILINEAR that use ASSIGN_BILINEAR binning type the gradient is assigned to the two neighbouring bins.
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.BoostDesc.DescriptorType.Lbgm">
            <summary>
            LBGM (alias FP-Boost) is the floating point extension where each dimension is computed as a linear combination of the weak learner responses.
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.BoostDesc.DescriptorType.Binboost64">
            <summary>
            BINBOOST and subvariants are the binary extensions of LBGM where each bit is computed as a thresholded linear combination of a set of weak learners.
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.BoostDesc.DescriptorType.Binboost128">
            <summary>
            BINBOOST and subvariants are the binary extensions of LBGM where each bit is computed as a thresholded linear combination of a set of weak learners.
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.BoostDesc.DescriptorType.Binboost256">
            <summary>
            BINBOOST and subvariants are the binary extensions of LBGM where each bit is computed as a thresholded linear combination of a set of weak learners.
            </summary>
        </member>
        <member name="T:Emgu.CV.XFeatures2D.XFeatures2DInvoke">
            <summary>
            This class wraps the functional calls to the OpenCV XFeatures2D modules
            </summary>
        </member>
        <member name="T:Emgu.CV.XFeatures2D.BriefDescriptorExtractor">
            <summary>
            BRIEF Descriptor
            </summary>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.BriefDescriptorExtractor.#ctor(System.Int32)">
            <summary>
            Create a BRIEF descriptor extractor.
            </summary>
            <param name="descriptorSize">The size of descriptor. It can be equal 16, 32 or 64 bytes.</param>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.BriefDescriptorExtractor.DisposeObject">
            <summary>
            Release all the unmanaged resource associated with BRIEF
            </summary>
        </member>
        <member name="T:Emgu.CV.XFeatures2D.CudaSURF">
            <summary>
            A SURF detector using Cuda
            </summary>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.CudaSURF.#ctor(System.Single,System.Int32,System.Int32,System.Boolean,System.Single,System.Boolean)">
            <summary>
            Create a Cuda SURF detector
            </summary>
            <param name="hessianThreshold">The interest operator threshold.</param>
            <param name="nOctaves">The number of octaves to process.</param>
            <param name="nOctaveLayers">The number of layers in each octave.</param>
            <param name="extended">True, if generate 128-len descriptors, false - 64-len descriptors.</param>
            <param name="featuresRatio">Max features = featuresRatio * img.size().srea().</param>
            <param name="upright">If set to true, the orientation is not computed for the keypoints</param>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.CudaSURF.DetectKeyPointsRaw(Emgu.CV.Cuda.GpuMat,Emgu.CV.Cuda.GpuMat)">
            <summary>
            Detect keypoints in the CudaImage
            </summary>
            <param name="img">The image where keypoints will be detected from</param>
            <param name="mask">The optional mask, can be null if not needed</param>
            <returns>
            The keypoints GpuMat that will have 1 row.
            keypoints.at&lt;float[6]&gt;(1, i) contains i'th keypoint
            format: (x, y, size, response, angle, octave)
            </returns>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.CudaSURF.DetectKeyPoints(Emgu.CV.Cuda.GpuMat,Emgu.CV.Cuda.GpuMat)">
            <summary>
            Detect keypoints in the CudaImage
            </summary>
            <param name="img">The image where keypoints will be detected from</param>
            <param name="mask">The optional mask, can be null if not needed</param>
            <returns>An array of keypoints</returns>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.CudaSURF.DownloadKeypoints(Emgu.CV.Cuda.GpuMat,Emgu.CV.Util.VectorOfKeyPoint)">
            <summary>
            Obtain the keypoints array from GpuMat
            </summary>
            <param name="src">The keypoints obtained from DetectKeyPointsRaw</param>
            <param name="dst">The vector of keypoints</param>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.CudaSURF.UploadKeypoints(Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.Cuda.GpuMat)">
            <summary>
            Obtain a GpuMat from the keypoints array
            </summary>
            <param name="src">The keypoints array</param>
            <param name="dst">A GpuMat that represent the keypoints</param>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.CudaSURF.ComputeDescriptorsRaw(Emgu.CV.Cuda.GpuMat,Emgu.CV.Cuda.GpuMat,Emgu.CV.Cuda.GpuMat)">
            <summary>
            Compute the descriptor given the image and the point location
            </summary>
            <param name="image">The image where the descriptor will be computed from</param>
            <param name="mask">The optional mask, can be null if not needed</param>
            <param name="keyPoints">The keypoint where the descriptor will be computed from. The order of the keypoints might be changed unless the GPU_SURF detector is UP-RIGHT.</param>
            <returns>The image features founded on the keypoint location</returns>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.CudaSURF.DisposeObject">
            <summary>
            Release the unmanaged resource associate to the Detector
            </summary>
        </member>
        <member name="P:Emgu.CV.XFeatures2D.CudaSURF.DescriptorSize">
            <summary>
            Return the size of the descriptor (64/128)
            </summary>
        </member>
        <member name="T:Emgu.CV.XFeatures2D.DAISY">
            <summary>
            Daisy descriptor.
            </summary>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.DAISY.#ctor(System.Single,System.Int32,System.Int32,System.Int32,Emgu.CV.XFeatures2D.DAISY.NormalizationType,Emgu.CV.IInputArray,System.Boolean,System.Boolean)">
            <summary>
            Create DAISY descriptor extractor
            </summary>
            <param name="radius">Radius of the descriptor at the initial scale.</param>
            <param name="qRadius">Amount of radial range division quantity.</param>
            <param name="qTheta">Amount of angular range division quantity.</param>
            <param name="qHist">Amount of gradient orientations range division quantity.</param>
            <param name="norm">Descriptors normalization type.</param>
            <param name="H">optional 3x3 homography matrix used to warp the grid of daisy but sampling keypoints remains unwarped on image</param>
            <param name="interpolation">Switch to disable interpolation for speed improvement at minor quality loss</param>
            <param name="useOrientation">Sample patterns using keypoints orientation, disabled by default.</param>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.DAISY.DisposeObject">
            <summary>
            Release all the unmanaged resource associated with BRIEF
            </summary>
        </member>
        <member name="T:Emgu.CV.XFeatures2D.DAISY.NormalizationType">
            <summary>
            Normalization type
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.DAISY.NormalizationType.None">
            <summary>
            Will not do any normalization (default)
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.DAISY.NormalizationType.Partial">
            <summary>
            Histograms are normalized independently for L2 norm equal to 1.0
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.DAISY.NormalizationType.Full">
            <summary>
            Descriptors are normalized for L2 norm equal to 1.0
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.DAISY.NormalizationType.SIFT">
            <summary>
            Descriptors are normalized for L2 norm equal to 1.0 but no individual one is bigger than 0.154 as in SIFT
            </summary>
        </member>
        <member name="T:Emgu.CV.XFeatures2D.Freak">
            <summary>
            The FREAK (Fast Retina Keypoint) keypoint descriptor:
            Alahi, R. Ortiz, and P. Vandergheynst. FREAK: Fast Retina Keypoint. In IEEE Conference on Computer
            Vision and Pattern Recognition, 2012. CVPR 2012 Open Source Award Winner.
            The algorithm
            propose a novel keypoint descriptor inspired by the human visual system and more precisely the retina, coined Fast
            Retina Key- point (FREAK). A cascade of binary strings is computed by efficiently comparing image intensities over a
            retinal sampling pattern. FREAKs are in general faster to compute with lower memory load and also more robust than
            SIFT, SURF or BRISK. They are competitive alternatives to existing keypoints in particular for embedded applications.
            </summary>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.Freak.#ctor(System.Boolean,System.Boolean,System.Single,System.Int32)">
            <summary>
            Create a Freak descriptor extractor.
            </summary>
            <param name="orientationNormalized">Enable orientation normalization</param>
            <param name="scaleNormalized">Enable scale normalization</param>
            <param name="patternScale">Scaling of the description pattern</param>
            <param name="nOctaves">Number of octaves covered by the detected keypoints.</param>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.Freak.DisposeObject">
            <summary>
            Release all the unmanaged resource associated with FREAK
            </summary>
        </member>
        <member name="T:Emgu.CV.XFeatures2D.LATCH">
            <summary>
            latch Class for computing the LATCH descriptor.
            If you find this code useful, please add a reference to the following paper in your work:
            Gil Levi and Tal Hassner, "LATCH: Learned Arrangements of Three Patch Codes", arXiv preprint arXiv:1501.03719, 15 Jan. 2015
            LATCH is a binary descriptor based on learned comparisons of triplets of image patches.
            </summary>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.LATCH.#ctor(System.Int32,System.Boolean,System.Int32)">
            <summary>
            Create LATCH descriptor extractor
            </summary>
            <param name="bytes">The size of the descriptor - can be 64, 32, 16, 8, 4, 2 or 1</param>
            <param name="rotationInvariance">Whether or not the descriptor should compensate for orientation changes.</param>
            <param name="halfSsdSize">the size of half of the mini-patches size. For example, if we would like to compare triplets of patches of size 7x7x
            then the half_ssd_size should be (7-1)/2 = 3.</param>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.LATCH.DisposeObject">
            <summary>
            Release all the unmanaged resource associated with BRIEF
            </summary>
        </member>
        <member name="T:Emgu.CV.XFeatures2D.LUCID">
            <summary>
            The locally uniform comparison image descriptor:
            An image descriptor that can be computed very fast, while being
            about as robust as, for example, SURF or BRIEF.
            </summary>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.LUCID.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a locally uniform comparison image descriptor.
            </summary>
            <param name="lucidKernel">Kernel for descriptor construction, where 1=3x3, 2=5x5, 3=7x7 and so forth</param>
            <param name="blurKernel">kernel for blurring image prior to descriptor construction, where 1=3x3, 2=5x5, 3=7x7 and so forth</param>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.LUCID.DisposeObject">
            <summary>
            Release all the unmanaged resource associated with BRIEF
            </summary>
        </member>
        <member name="T:Emgu.CV.XFeatures2D.MSDDetector">
            <summary>
            Class implementing the MSD (Maximal Self-Dissimilarity) keypoint detector, described in "Federico Tombari and Luigi Di Stefano. Interest points via maximal self-dissimilarities. In Asian Conference on Computer Vision  ACCV 2014, 2014".
            </summary>
            <remarks>The algorithm implements a novel interest point detector stemming from the intuition that image patches which are highly dissimilar over a relatively large extent of their surroundings hold the property of being repeatable and distinctive. This concept of "contextual self-dissimilarity" reverses the key paradigm of recent successful techniques such as the Local Self-Similarity descriptor and the Non-Local Means filter, which build upon the presence of similar - rather than dissimilar - patches. Moreover, it extends to contextual information the local self-dissimilarity notion embedded in established detectors of corner-like interest points, thereby achieving enhanced repeatability, distinctiveness and localization accuracy.</remarks>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.MSDDetector.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Int32,System.Single,System.Int32,System.Boolean)">
            <summary>
            Create a MSD (Maximal Self-Dissimilarity) keypoint detector.
            </summary>
            <param name="m_patch_radius">Patch radius</param>
            <param name="m_search_area_radius">Search area raduis</param>
            <param name="m_nms_radius">Nms radius</param>
            <param name="m_nms_scale_radius">Nms scale radius</param>
            <param name="m_th_saliency">Th saliency</param>
            <param name="m_kNN">Knn</param>
            <param name="m_scale_factor">Scale factor</param>
            <param name="m_n_scales">N scales</param>
            <param name="m_compute_orientation">Compute orientation</param>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.MSDDetector.DisposeObject">
            <summary>
            Release all the unmanaged resource associated with MSDDetector
            </summary>
        </member>
        <member name="T:Emgu.CV.XFeatures2D.PCTSignatures">
            <summary>
            Class implementing PCT (position-color-texture) signature extraction as described in:
            Martin Krulis, Jakub Lokoc, and Tomas Skopal. Efficient extraction of clustering-based feature signatures using GPU architectures. Multimedia Tools Appl., 75(13):80718103, 2016.
            The algorithm is divided to a feature sampler and a clusterizer. Feature sampler produces samples at given set of coordinates. Clusterizer then produces clusters of these samples using k-means algorithm. Resulting set of clusters is the signature of the input image.
            A signature is an array of SIGNATURE_DIMENSION-dimensional points.Used dimensions are: weight, x, y position; lab color, contrast, entropy.
            </summary>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.PCTSignatures.#ctor(System.Int32,System.Int32,Emgu.CV.XFeatures2D.PCTSignatures.PointDistributionType)">
            <summary>
            Creates PCTSignatures algorithm using sample and seed count. It generates its own sets of sampling points and clusterization seed indexes.
            </summary>
            <param name="initSampleCount">Number of points used for image sampling.</param>
            <param name="initSeedCount">Number of initial clusterization seeds. Must be lower or equal to initSampleCount</param>
            <param name="pointDistribution">Distribution of generated points.</param>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.PCTSignatures.#ctor(Emgu.CV.Util.VectorOfPointF,System.Int32)">
            <summary>
            Creates PCTSignatures algorithm using pre-generated sampling points and number of clusterization seeds. It uses the provided sampling points and generates its own clusterization seed indexes.
            </summary>
            <param name="initSamplingPoints">Sampling points used in image sampling.</param>
            <param name="initSeedCount">Number of initial clusterization seeds. Must be lower or equal to initSamplingPoints.size().</param>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.PCTSignatures.#ctor(Emgu.CV.Util.VectorOfPointF,Emgu.CV.Util.VectorOfInt)">
            <summary>
            Creates PCTSignatures algorithm using pre-generated sampling points and clusterization seeds indexes.
            </summary>
            <param name="initSamplingPoints">Sampling points used in image sampling.</param>
            <param name="initClusterSeedIndexes">Indexes of initial clusterization seeds. Its size must be lower or equal to initSamplingPoints.size().</param>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.PCTSignatures.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this PCTSignatures object
            </summary>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.PCTSignatures.ComputeSignature(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Computes signature of given image.
            </summary>
            <param name="image">Input image of CV_8U type.</param>
            <param name="signature">Output computed signature.</param>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.PCTSignatures.DrawSignature(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single,System.Int32)">
            <summary>
            Draws signature in the source image and outputs the result. Signatures are visualized as a circle with radius based on signature weight and color based on signature color. Contrast and entropy are not visualized.
            </summary>
            <param name="source">Source image.</param>
            <param name="signature">Image signature.</param>
            <param name="result">Output result.</param>
            <param name="radiusToShorterSideRatio">Determines maximal radius of signature in the output image.</param>
            <param name="borderThickness">Border thickness of the visualized signature.</param>
        </member>
        <member name="P:Emgu.CV.XFeatures2D.PCTSignatures.GrayscaleBits">
            <summary>
            Color resolution of the greyscale bitmap represented in allocated bits (i.e., value 4 means that 16 shades of grey are used). The greyscale bitmap is used for computing contrast and entropy values.
            </summary>
        </member>
        <member name="P:Emgu.CV.XFeatures2D.PCTSignatures.WindowRadius">
            <summary>
            Size of the texture sampling window used to compute contrast and entropy. (center of the window is always in the pixel selected by x,y coordinates of the corresponding feature sample).
            </summary>
        </member>
        <member name="P:Emgu.CV.XFeatures2D.PCTSignatures.WeightX">
            <summary>
            Weights (multiplicative constants) that linearly stretch individual axes of the feature space. (x,y = position. L,a,b = color in CIE Lab space. c = contrast. e = entropy)
            </summary>
        </member>
        <member name="P:Emgu.CV.XFeatures2D.PCTSignatures.WeightY">
            <summary>
            Weights (multiplicative constants) that linearly stretch individual axes of the feature space. (x,y = position. L,a,b = color in CIE Lab space. c = contrast. e = entropy)
            </summary>
        </member>
        <member name="P:Emgu.CV.XFeatures2D.PCTSignatures.WeightL">
            <summary>
            Weights (multiplicative constants) that linearly stretch individual axes of the feature space. (x,y = position. L,a,b = color in CIE Lab space. c = contrast. e = entropy)
            </summary>
        </member>
        <member name="P:Emgu.CV.XFeatures2D.PCTSignatures.WeightA">
            <summary>
            Weights (multiplicative constants) that linearly stretch individual axes of the feature space. (x,y = position. L,a,b = color in CIE Lab space. c = contrast. e = entropy)
            </summary>
        </member>
        <member name="P:Emgu.CV.XFeatures2D.PCTSignatures.WeightB">
            <summary>
            Weights (multiplicative constants) that linearly stretch individual axes of the feature space. (x,y = position. L,a,b = color in CIE Lab space. c = contrast. e = entropy)
            </summary>
        </member>
        <member name="P:Emgu.CV.XFeatures2D.PCTSignatures.WeightEntropy">
            <summary>
            Weights (multiplicative constants) that linearly stretch individual axes of the feature space. (x,y = position. L,a,b = color in CIE Lab space. c = contrast. e = entropy)
            </summary>
        </member>
        <member name="P:Emgu.CV.XFeatures2D.PCTSignatures.IterationCount">
            <summary>
            Number of iterations of the k-means clustering. We use fixed number of iterations, since the modified clustering is pruning clusters (not iteratively refining k clusters).
            </summary>
        </member>
        <member name="P:Emgu.CV.XFeatures2D.PCTSignatures.MaxClustersCount">
            <summary>
            Maximal number of generated clusters. If the number is exceeded, the clusters are sorted by their weights and the smallest clusters are cropped.
            </summary>
        </member>
        <member name="P:Emgu.CV.XFeatures2D.PCTSignatures.ClusterMinSize">
            <summary>
            This parameter multiplied by the index of iteration gives lower limit for cluster size. Clusters containing fewer points than specified by the limit have their centroid dismissed and points are reassigned.
            </summary>
        </member>
        <member name="P:Emgu.CV.XFeatures2D.PCTSignatures.JoiningDistance">
            <summary>
            Threshold euclidean distance between two centroids. If two cluster centers are closer than this distance, one of the centroid is dismissed and points are reassigned.
            </summary>
        </member>
        <member name="P:Emgu.CV.XFeatures2D.PCTSignatures.DropThreshold">
            <summary>
            Remove centroids in k-means whose weight is lesser or equal to given threshold.
            </summary>
        </member>
        <member name="P:Emgu.CV.XFeatures2D.PCTSignatures.DistanceFunction">
            <summary>
            Distance function selector used for measuring distance between two points in k-means.
            </summary>
        </member>
        <member name="T:Emgu.CV.XFeatures2D.PCTSignatures.PointDistributionType">
             <summary>
            Point distributions supported by random point generator.
             </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.PCTSignatures.PointDistributionType.Uniform">
            <summary>
            Generate numbers uniformly.
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.PCTSignatures.PointDistributionType.Regular">
            <summary>
            Generate points in a regular grid.
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.PCTSignatures.PointDistributionType.Normal">
            Generate points with normal (gaussian) distribution.
        </member>
        <member name="T:Emgu.CV.XFeatures2D.PCTSignaturesSQFD">
            <summary>
            Class implementing Signature Quadratic Form Distance (SQFD).
            </summary>
            <remarks>See also: Christian Beecks, Merih Seran Uysal, Thomas Seidl. Signature quadratic form distance. In Proceedings of the ACM International Conference on Image and Video Retrieval, pages 438-445. ACM, 2010.</remarks>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.PCTSignaturesSQFD.#ctor(Emgu.CV.XFeatures2D.PCTSignaturesSQFD.DistanceFunction,Emgu.CV.XFeatures2D.PCTSignaturesSQFD.SimilarityFunction,System.Single)">
            <summary>
            Creates the algorithm instance using selected distance function, similarity function and similarity function parameter.
            </summary>
            <param name="distanceFunction">Distance function selector.</param>
            <param name="similarityFunction">Similarity function selector.</param>
            <param name="similarityParameter">Parameter of the similarity function.</param>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.PCTSignaturesSQFD.ComputeQuadraticFormDistance(Emgu.CV.IInputArray,Emgu.CV.IInputArray)">
            <summary>
            Computes Signature Quadratic Form Distance of two signatures.
            </summary>
            <param name="signature0">The first signature.</param>
            <param name="signature1">The second signature.</param>
            <returns>The Signature Quadratic Form Distance of two signatures</returns>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.PCTSignaturesSQFD.ComputeQuadraticFormDistances(Emgu.CV.Mat,Emgu.CV.Util.VectorOfMat,Emgu.CV.Util.VectorOfFloat)">
            <summary>
            Computes Signature Quadratic Form Distance between the reference signature and each of the other image signatures.
            </summary>
            <param name="sourceSignature">The signature to measure distance of other signatures from.</param>
            <param name="imageSignatures">Vector of signatures to measure distance from the source signature.</param>
            <param name="distances">Output vector of measured distances.</param>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.PCTSignaturesSQFD.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this PCTSignaturesSQFD object
            </summary>
        </member>
        <member name="T:Emgu.CV.XFeatures2D.PCTSignaturesSQFD.DistanceFunction">
            <summary>
            Lp distance function selector.       
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.PCTSignaturesSQFD.DistanceFunction.L0_25">
            <summary>
            L0_25
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.PCTSignaturesSQFD.DistanceFunction.L0_5">
            <summary>
            L0_5
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.PCTSignaturesSQFD.DistanceFunction.L1">
            <summary>
            L1
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.PCTSignaturesSQFD.DistanceFunction.L2">
            <summary>
            L2
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.PCTSignaturesSQFD.DistanceFunction.L2SQUARED">
            <summary>
            L2 squared
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.PCTSignaturesSQFD.DistanceFunction.L5">
            <summary>
            L5
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.PCTSignaturesSQFD.DistanceFunction.L_INFINITY">
            <summary>
            L infinity
            </summary>
        </member>
        <member name="T:Emgu.CV.XFeatures2D.PCTSignaturesSQFD.SimilarityFunction">
             <summary>
            Similarity function selector.
             </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.PCTSignaturesSQFD.SimilarityFunction.Minus">
            <summary>
            -d(c_i, c_j)
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.PCTSignaturesSQFD.SimilarityFunction.Gaussian">
            <summary>
            e^{ -\alpha * d^2(c_i, c_j)}
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.PCTSignaturesSQFD.SimilarityFunction.Heuristic">
            <summary>
            1 / (\alpha + d(c_i, c_j))
            </summary>
        </member>
        <member name="T:Emgu.CV.XFeatures2D.SIFT">
            <summary>
            Wrapped SIFT detector
            </summary>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.SIFT.#ctor(System.Int32,System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Create a SIFT using the specific values
            </summary>
            <param name="nFeatures">The desired number of features. Use 0 for un-restricted number of features</param>
            <param name="nOctaveLayers">The number of octave layers. Use 3 for default</param>
            <param name="contrastThreshold">Contrast threshold. Use 0.04 as default</param>
            <param name="edgeThreshold">Detector parameter. Use 10.0 as default</param>
            <param name="sigma">Use 1.6 as default</param>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.SIFT.DisposeObject">
            <summary>
            Release the unmanaged resources associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.XFeatures2D.SURF">
            <summary>
            Class for extracting Speeded Up Robust Features from an image
            </summary>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.SURF.#ctor(System.Double,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Create a SURF detector using the specific values
            </summary>
            <param name="hessianThresh">      
            Only features with keypoint.hessian larger than that are extracted.
            good default value is ~300-500 (can depend on the average local contrast and sharpness of the image).
            user can further filter out some features based on their hessian values and other characteristics
            </param>
            <param name="extended">      
            false means basic descriptors (64 elements each),
            true means extended descriptors (128 elements each)
            </param>
            <param name="nOctaves">
            The number of octaves to be used for extraction.
            With each next octave the feature size is doubled
            </param>
            <param name="nOctaveLayers">
            The number of layers within each octave
            </param>
            <param name="upright">
            False means that detector computes orientation of each feature. 
            True means that the orientation is not computed (which is much, much faster). 
            For example, if you match images from a stereo pair, or do image stitching, the matched features likely have very similar angles, and you can speed up feature extraction by setting upright=true.</param>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.SURF.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this detector.
            </summary>
        </member>
        <member name="T:Emgu.CV.XFeatures2D.StarDetector">
            <summary>
            StarDetector
            </summary>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.StarDetector.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
             <summary>
             Create a star detector with the specific parameters
             </summary>
             <param name="maxSize">
             Maximum size of the features. The following
             values of the parameter are supported:
             4, 6, 8, 11, 12, 16, 22, 23, 32, 45, 46, 64, 90, 128</param>
             <param name="responseThreshold">
             Threshold for the approximated laplacian,
             used to eliminate weak features. The larger it is,
             the less features will be retrieved
             </param>
             <param name="lineThresholdProjected">
             Another threshold for the laplacian to eliminate edges.
             The larger the threshold, the more points you get.
             </param>
             <param name="lineThresholdBinarized">
             Another threshold for the feature size to eliminate edges. 
             The larger the threshold, the more points you get.</param>
             <param name="suppressNonmaxSize">
            
             </param>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.StarDetector.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this detector.
            </summary>
        </member>
        <member name="T:Emgu.CV.XFeatures2D.VGG">
            <summary>
            Class implementing VGG (Oxford Visual Geometry Group) descriptor trained end to end using "Descriptor Learning Using Convex Optimisation" (DLCO) aparatus
            </summary>
            <remarks>See: K. Simonyan, A. Vedaldi, and A. Zisserman. Learning local feature descriptors using convex optimisation. IEEE Transactions on Pattern Analysis and Machine Intelligence, 2014.</remarks>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.VGG.#ctor(Emgu.CV.XFeatures2D.VGG.DescriptorType,System.Single,System.Boolean,System.Boolean,System.Single,System.Boolean)">
            <summary>
            Create an instance of VGG
            </summary>
            <param name="desc">Type of descriptor to use</param>
            <param name="isigma">gaussian kernel value for image blur</param>
            <param name="imgNormalize">use image sample intensity normalization</param>
            <param name="useScaleOrientation">	sample patterns using keypoints orientation</param>
            <param name="scaleFactor">adjust the sampling window of detected keypoints to 64.0f (VGG sampling window) 6.25f is default and fits for KAZE, SURF detected keypoints window ratio 6.75f should be the scale for SIFT detected keypoints window ratio 5.00f should be the scale for AKAZE, MSD, AGAST, FAST, BRISK keypoints window ratio 0.75f should be the scale for ORB keypoints ratio</param>
            <param name="dscNormalize">clamp descriptors to 255 and convert to uchar CV_8UC1</param>
        </member>
        <member name="M:Emgu.CV.XFeatures2D.VGG.DisposeObject">
            <summary>
            Release all the unmanaged resource associated with VGG
            </summary>
        </member>
        <member name="T:Emgu.CV.XFeatures2D.VGG.DescriptorType">
            <summary>
            The VGG descriptor type
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.VGG.DescriptorType.Vgg120">
            <summary>
            120 dimension float
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.VGG.DescriptorType.Vgg80">
            <summary>
            80 dimension float
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.VGG.DescriptorType.Vgg64">
            <summary>
            64 dimension float
            </summary>
        </member>
        <member name="F:Emgu.CV.XFeatures2D.VGG.DescriptorType.Vgg48">
            <summary>
            48 dimension float
            </summary>
        </member>
        <member name="T:Emgu.CV.XImgproc.DTFilter">
            <summary>
            Interface for realizations of Domain Transform filter.
            </summary>
        </member>
        <member name="M:Emgu.CV.XImgproc.DTFilter.#ctor(Emgu.CV.IInputArray,System.Double,System.Double,Emgu.CV.XImgproc.DTFilter.Mode,System.Int32)">
            <summary>
            Create instance of DTFilter and produce initialization routines.
            </summary>
            <param name="guide">Guided image (used to build transformed distance, which describes edge structure of guided image).</param>
            <param name="sigmaSpatial">Parameter in the original article, it's similar to the sigma in the coordinate space into bilateralFilter.</param>
            <param name="sigmaColor">Parameter in the original article, it's similar to the sigma in the color space into bilateralFilter.</param>
            <param name="mode">One form three modes DTF_NC, DTF_RF and DTF_IC which corresponds to three modes for filtering 2D signals in the article.</param>
            <param name="numIters">Optional number of iterations used for filtering, 3 is quite enough.</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.DTFilter.Filter(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Produce domain transform filtering operation on source image.
            </summary>
            <param name="src">Filtering image with unsigned 8-bit or floating-point 32-bit depth and up to 4 channels.</param>
            <param name="dst">Destination image.</param>
            <param name="dDepth">Optional depth of the output image. dDepth can be set to Default, which will be equivalent to src.depth().</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.DTFilter.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.XImgproc.DTFilter.Mode">
            <summary>
            The three modes for filtering 2D signals in the article.
            </summary>
        </member>
        <member name="F:Emgu.CV.XImgproc.DTFilter.Mode.NC">
            <summary>
            NC
            </summary>
        </member>
        <member name="F:Emgu.CV.XImgproc.DTFilter.Mode.IC">
            <summary>
            IC
            </summary>
        </member>
        <member name="F:Emgu.CV.XImgproc.DTFilter.Mode.RF">
            <summary>
            RF
            </summary>
        </member>
        <member name="T:Emgu.CV.XImgproc.XImgprocInvoke">
            <summary>
            Library to invoke XImgproc functions
            </summary>
            <summary>
            Extended Image Processing
            </summary>
        </member>
        <member name="M:Emgu.CV.XImgproc.XImgprocInvoke.JointBilateralFilter(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Double,System.Double,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Applies the joint bilateral filter to an image.
            </summary>
            <param name="joint">Joint 8-bit or floating-point, 1-channel or 3-channel image.</param>
            <param name="src">Source 8-bit or floating-point, 1-channel or 3-channel image with the same depth as joint image.</param>
            <param name="dst">Destination image of the same size and type as src .</param>
            <param name="d">Diameter of each pixel neighborhood that is used during filtering. If it is non-positive, it is computed from sigmaSpace .</param>
            <param name="sigmaColor">Filter sigma in the color space. A larger value of the parameter means that farther colors within the pixel neighborhood (see sigmaSpace ) will be mixed together, resulting in larger areas of semi-equal color.</param>
            <param name="sigmaSpace">Filter sigma in the coordinate space. A larger value of the parameter means that farther pixels will influence each other as long as their colors are close enough (see sigmaColor ). When d&gt;0 , it specifies the neighborhood size regardless of sigmaSpace . Otherwise, d is proportional to sigmaSpace .</param>
            <param name="borderType">Border type</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.XImgprocInvoke.BilateralTextureFilter(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Applies the bilateral texture filter to an image. It performs structure-preserving texture filter. 
            </summary>
            <param name="src">Source image whose depth is 8-bit UINT or 32-bit FLOAT</param>
            <param name="dst">Destination image of the same size and type as src.</param>
            <param name="fr">Radius of kernel to be used for filtering. It should be positive integer</param>
            <param name="numIter">Number of iterations of algorithm, It should be positive integer</param>
            <param name="sigmaAlpha">Controls the sharpness of the weight transition from edges to smooth/texture regions, where a bigger value means sharper transition. When the value is negative, it is automatically calculated.</param>
            <param name="sigmaAvg">Range blur parameter for texture blurring. Larger value makes result to be more blurred. When the value is negative, it is automatically calculated as described in the paper.</param>
            <remarks>For more details about this filter see: Hojin Cho, Hyunjoon Lee, Henry Kang, and Seungyong Lee. Bilateral texture filtering. ACM Transactions on Graphics, 33(4):128:1128:8, July 2014.</remarks>
        </member>
        <member name="M:Emgu.CV.XImgproc.XImgprocInvoke.RollingGuidanceFilter(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Double,System.Double,System.Int32,Emgu.CV.CvEnum.BorderType)">
            <summary>
            Applies the rolling guidance filter to an image
            </summary>
            <param name="src">Source 8-bit or floating-point, 1-channel or 3-channel image.</param>
            <param name="dst">Destination image of the same size and type as src.</param>
            <param name="d">Diameter of each pixel neighborhood that is used during filtering. If it is non-positive, it is computed from sigmaSpace .</param>
            <param name="sigmaColor">Filter sigma in the color space. A larger value of the parameter means that farther colors within the pixel neighborhood (see sigmaSpace ) will be mixed together, resulting in larger areas of semi-equal color.</param>
            <param name="sigmaSpace">Filter sigma in the coordinate space. A larger value of the parameter means that farther pixels will influence each other as long as their colors are close enough (see sigmaColor ). When d>0 , it specifies the neighborhood size regardless of sigmaSpace . Otherwise, d is proportional to sigmaSpace .</param>
            <param name="numOfIter">Number of iterations of joint edge-preserving filtering applied on the source image.</param>
            <param name="borderType">Border type</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.XImgprocInvoke.FastGlobalSmootherFilter(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,System.Double,System.Int32)">
            <summary>
            Simple one-line Fast Global Smoother filter call.
            </summary>
            <param name="guide">image serving as guide for filtering. It should have 8-bit depth and either 1 or 3 channels.</param>
            <param name="src">source image for filtering with unsigned 8-bit or signed 16-bit or floating-point 32-bit depth and up to 4 channels.</param>
            <param name="dst">destination image.</param>
            <param name="lambda">parameter defining the amount of regularization</param>
            <param name="sigmaColor">parameter, that is similar to color space sigma in bilateralFilter.</param>
            <param name="lambdaAttenuation">internal parameter, defining how much lambda decreases after each iteration. Normally, it should be 0.25. Setting it to 1.0 may lead to streaking artifacts.</param>
            <param name="numIter">number of iterations used for filtering, 3 is usually enough.</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.XImgprocInvoke.AmFilter(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,System.Boolean)">
            <summary>
            Simple one-line Adaptive Manifold Filter call.
            </summary>
            <param name="joint">joint (also called as guided) image or array of images with any numbers of channels.</param>
            <param name="src">filtering image with any numbers of channels.</param>
            <param name="dst">output image.</param>
            <param name="sigmaS">spatial standard deviation.</param>
            <param name="sigmaR">color space standard deviation, it is similar to the sigma in the color space into bilateralFilter.</param>
            <param name="adjustOutliers">optional, specify perform outliers adjust operation or not, (Eq. 9) in the original paper.</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.XImgprocInvoke.GuidedFilter(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Double,Emgu.CV.CvEnum.DepthType)">
            <summary>
            Simple one-line Guided Filter call.
            </summary>
            <param name="guide">guided image (or array of images) with up to 3 channels, if it have more then 3 channels then only first 3 channels will be used.</param>
            <param name="src">filtering image with any numbers of channels.</param>
            <param name="dst">output image.</param>
            <param name="radius">radius of Guided Filter.</param>
            <param name="eps">regularization term of Guided Filter. eps^2 is similar to the sigma in the color space into bilateralFilter.</param>
            <param name="dDepth">optional depth of the output image.</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.XImgprocInvoke.DtFilter(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double,Emgu.CV.XImgproc.DtFilterType,System.Int32)">
            <summary>
            Simple one-line Domain Transform filter call. 
            </summary>
            <param name="guide">guided image (also called as joint image) with unsigned 8-bit or floating-point 32-bit depth and up to 4 channels.</param>
            <param name="src">filtering image with unsigned 8-bit or floating-point 32-bit depth and up to 4 channels.</param>
            <param name="dst">output image</param>
            <param name="sigmaSpatial">parameter in the original article, it's similar to the sigma in the coordinate space into bilateralFilter.</param>
            <param name="sigmaColor">parameter in the original article, it's similar to the sigma in the color space into bilateralFilter.</param>
            <param name="mode">Dt filter mode</param>
            <param name="numIters">optional number of iterations used for filtering, 3 is quite enough.</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.XImgprocInvoke.NiBlackThreshold(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,Emgu.CV.CvEnum.ThresholdType,System.Int32,System.Double)">
            <summary>
            Niblack threshold
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The output result</param>
            <param name="type">Threshold type</param>
            <param name="blockSize">Block size</param>
            <param name="delta">delta</param>
            <param name="maxValue">Maximum value to use with CV_THRESH_BINARY and CV_THRESH_BINARY_INV thresholding types</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.XImgprocInvoke.CovarianceEstimation(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Int32)">
            <summary>
            Computes the estimated covariance matrix of an image using the sliding window forumlation.
            </summary>
            <param name="src">The source image. Input image must be of a complex type.</param>
            <param name="dst">The destination estimated covariance matrix. Output matrix will be size (windowRows*windowCols, windowRows*windowCols).</param>
            <param name="windowRows">The number of rows in the window.</param>
            <param name="windowCols">The number of cols in the window. The window size parameters control the accuracy of the estimation. The sliding window moves over the entire image from the top-left corner to the bottom right corner. Each location of the window represents a sample. If the window is the size of the image, then this gives the exact covariance matrix. For all other cases, the sizes of the window will impact the number of samples and the number of elements in the estimated covariance matrix.</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.XImgprocInvoke.WeightedMedianFilter(Emgu.CV.IInputArray,Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Int32,System.Double,Emgu.CV.XImgproc.WMFWeightType,Emgu.CV.Mat)">
            <summary>
            Applies weighted median filter to an image.
            </summary>
            <param name="joint">Joint 8-bit, 1-channel or 3-channel image.</param>
            <param name="src">Source 8-bit or floating-point, 1-channel or 3-channel image.</param>
            <param name="dst">Destination image.</param>
            <param name="r">Radius of filtering kernel, should be a positive integer.</param>
            <param name="sigma">Filter range standard deviation for the joint image.</param>
            <param name="weightType">The type of weight definition</param>
            <param name="mask">A 0-1 mask that has the same size with I. This mask is used to ignore the effect of some pixels. If the pixel value on mask is 0, the pixel will be ignored when maintaining the joint-histogram. This is useful for applications like optical flow occlusion handling.</param>
            <remarks>For more details about this implementation, please see: Qi Zhang, Li Xu, and Jiaya Jia. 100+ times faster weighted median filter (wmf). In Computer Vision and Pattern Recognition (CVPR), 2014 IEEE Conference on, pages 28302837. IEEE, 2014.</remarks>
        </member>
        <member name="M:Emgu.CV.XImgproc.XImgprocInvoke.GradientPaillouY(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double)">
            <summary>
            Applies Paillou filter to an image.
            </summary>
            <param name="op">Source 8-bit or 16bit image, 1-channel or 3-channel image.</param>
            <param name="dst">result CV_32F image with same number of channel than op.</param>
            <param name="alpha">see paper</param>
            <param name="omega">see paper</param>
            <remarks>For more details about this implementation, please see: Philippe Paillou. Detecting step edges in noisy sar images: a new linear operator. IEEE transactions on geoscience and remote sensing, 35(1):191196, 1997.</remarks>
        </member>
        <member name="M:Emgu.CV.XImgproc.XImgprocInvoke.GradientPaillouX(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double)">
            <summary>
            Applies Paillou filter to an image.
            </summary>
            <param name="op">Source 8-bit or 16bit image, 1-channel or 3-channel image.</param>
            <param name="dst">result CV_32F image with same number of channel than op.</param>
            <param name="alpha">see paper</param>
            <param name="omega">see paper</param>
            <remarks>For more details about this implementation, please see: Philippe Paillou. Detecting step edges in noisy sar images: a new linear operator. IEEE transactions on geoscience and remote sensing, 35(1):191196, 1997.</remarks>
        </member>
        <member name="M:Emgu.CV.XImgproc.XImgprocInvoke.GradientDericheY(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double)">
            <summary>
            Applies Y Deriche filter to an image.
            </summary>
            <param name="op">Source 8-bit or 16bit image, 1-channel or 3-channel image.</param>
            <param name="dst">result CV_32FC image with same number of channel than _op.</param>
            <param name="alphaDerive">see paper</param>
            <param name="alphaMean">see paper</param>
            <remarks>For more details about this implementation, please see <see href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.476.5736&amp;rep=rep1&amp;type=pdf">here</see> </remarks>
        </member>
        <member name="M:Emgu.CV.XImgproc.XImgprocInvoke.GradientDericheX(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Double,System.Double)">
            <summary>
            Applies X Deriche filter to an image.
            </summary>
            <param name="op">Source 8-bit or 16bit image, 1-channel or 3-channel image.</param>
            <param name="dst">result CV_32FC image with same number of channel than _op.</param>
            <param name="alphaDerive">see paper</param>
            <param name="alphaMean">see paper</param>
            <remarks>For more details about this implementation, please see http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.476.5736&amp;rep=rep1&amp;type=pdf </remarks>
        </member>
        <member name="M:Emgu.CV.XImgproc.XImgprocInvoke.Thinning(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,Emgu.CV.XImgproc.ThinningTypes)">
            <summary>
            Applies a binary blob thinning operation, to achieve a skeletization of the input image. 
            The function transforms a binary blob image into a skeletized form using the technique of Zhang-Suen.
            </summary>
            <param name="src">Source 8-bit single-channel image, containing binary blobs, with blobs having 255 pixel values.</param>
            <param name="dst">Destination image of the same size and the same type as src. The function can work in-place.</param>
            <param name="thinningType">Value that defines which thinning algorithm should be used.</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.XImgprocInvoke.AnisotropicDiffusion(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single,System.Single,System.Int32)">
            <summary>
            Performs anisotropic diffusion on an image.
            </summary>
            <param name="src">Grayscale Source image.</param>
            <param name="dst">Destination image of the same size and the same number of channels as src .</param>
            <param name="alpha">The amount of time to step forward by on each iteration (normally, it's between 0 and 1).</param>
            <param name="K">sensitivity to the edges</param>
            <param name="niters">The number of iterations</param>
        </member>
        <member name="T:Emgu.CV.XImgproc.GraphSegmentation">
            <summary>
            Graph Based Segmentation Algorithm. The class implements the algorithm described in Pedro F Felzenszwalb and Daniel P Huttenlocher. Efficient graph-based image segmentation. volume 59, pages 167181. Springer, 2004.
            </summary>
        </member>
        <member name="M:Emgu.CV.XImgproc.GraphSegmentation.#ctor(System.Double,System.Single,System.Int32)">
            <summary>
            Creates a graph based segmentor.
            </summary>
            <param name="sigma">The sigma parameter, used to smooth image</param>
            <param name="k">The k parameter of the algorithm</param>
            <param name="minSize">The minimum size of segments</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.GraphSegmentation.ProcessImage(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Segment an image and store output in dst.
            </summary>
            <param name="src">The input image. Any number of channel (1 (Eg: Gray), 3 (Eg: RGB), 4 (Eg: RGB-D)) can be provided</param>
            <param name="dst">The output segmentation. It's a CV_32SC1 Mat with the same number of cols and rows as input image, with an unique, sequential, id for each pixel.</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.GraphSegmentation.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this object.
            </summary>
        </member>
        <member name="T:Emgu.CV.XImgproc.SelectiveSearchSegmentation">
            <summary>
            Selective search segmentation algorithm The class implements the algorithm described in:
            Jasper RR Uijlings, Koen EA van de Sande, Theo Gevers, and Arnold WM Smeulders. Selective search for object recognition. International journal of computer vision, 104(2):154171, 2013.
            </summary>
        </member>
        <member name="M:Emgu.CV.XImgproc.SelectiveSearchSegmentation.#ctor">
            <summary>
            Selective search segmentation algorithm
            </summary>
        </member>
        <member name="M:Emgu.CV.XImgproc.SelectiveSearchSegmentation.SetBaseImage(Emgu.CV.IInputArray)">
            <summary>
            Set a image used by switch* functions to initialize the class.
            </summary>
            <param name="image">The image</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.SelectiveSearchSegmentation.SwitchToSingleStrategy(System.Int32,System.Single)">
            <summary>
            Initialize the class with the 'Single stragegy' parameters
            </summary>
            <param name="k">The k parameter for the graph segmentation</param>
            <param name="sigma">The sigma parameter for the graph segmentation</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.SelectiveSearchSegmentation.SwitchToSelectiveSearchFast(System.Int32,System.Int32,System.Single)">
            <summary>
            Initialize the class with the 'Selective search fast' parameters
            </summary>
            <param name="baseK">The k parameter for the first graph segmentation</param>
            <param name="incK">The increment of the k parameter for all graph segmentations</param>
            <param name="sigma">The sigma parameter for the graph segmentation</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.SelectiveSearchSegmentation.SwitchToSelectiveSearchQuality(System.Int32,System.Int32,System.Single)">
            <summary>
            Initialize the class with the 'Selective search quality' parameters
            </summary>
            <param name="baseK">The k parameter for the first graph segmentation</param>
            <param name="incK">The increment of the k parameter for all graph segmentations</param>
            <param name="sigma">The sigma parameter for the graph segmentation</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.SelectiveSearchSegmentation.AddImage(Emgu.CV.IInputArray)">
            <summary>
            Add a new image in the list of images to process.
            </summary>
            <param name="img">	The image</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.SelectiveSearchSegmentation.Process">
            <summary>
            Based on all images, graph segmentations and stragies, computes all possible rects and return them.
            </summary>
            <returns>	The list of rects. The first ones are more relevents than the lasts ones.</returns>
        </member>
        <member name="M:Emgu.CV.XImgproc.SelectiveSearchSegmentation.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this object.
            </summary>
        </member>
        <member name="T:Emgu.CV.XImgproc.StructuredEdgeDetection">
            <summary>
            Class implementing edge detection algorithm from Piotr Dollr and C Lawrence Zitnick. Structured forests for fast edge detection. In Computer Vision (ICCV), 2013 IEEE International Conference on, pages 18411848. IEEE, 2013.
            </summary>
        </member>
        <member name="M:Emgu.CV.XImgproc.StructuredEdgeDetection.#ctor(System.String,Emgu.CV.XImgproc.RFFeatureGetter)">
            <summary>
            
            </summary>
            <param name="model">name of the file where the model is stored</param>
            <param name="howToGetFeatures">optional object inheriting from RFFeatureGetter. You need it only if you would like to train your own forest, pass NULL otherwise</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.StructuredEdgeDetection.DetectEdges(Emgu.CV.Mat,Emgu.CV.Mat)">
            <summary>
            The function detects edges in src and draw them to dst. The algorithm underlies this function is much more robust to texture presence, than common approaches, e.g. Sobel
            </summary>
            <param name="src">source image (RGB, float, in [0;1]) to detect edges</param>
            <param name="dst">destination image (grayscale, float, in [0;1]) where edges are drawn</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.StructuredEdgeDetection.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this object.
            </summary>
        </member>
        <member name="T:Emgu.CV.XImgproc.RFFeatureGetter">
            <summary>
            Helper class for training part of [P. Dollar and C. L. Zitnick. Structured Forests for Fast Edge Detection, 2013].
            </summary>
        </member>
        <member name="M:Emgu.CV.XImgproc.RFFeatureGetter.#ctor">
            <summary>
            Create a default RFFeatureGetter
            </summary>
        </member>
        <member name="M:Emgu.CV.XImgproc.RFFeatureGetter.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this RFFeatureGetter.
            </summary>
        </member>
        <member name="T:Emgu.CV.XImgproc.SuperpixelLSC">
            <summary>
            Class implementing the LSC (Linear Spectral Clustering) superpixels algorithm described in "Zhengqin Li and Jiansheng Chen. Superpixel segmentation using linear spectral clustering. June 2015."
            </summary>
            <remarks>LSC (Linear Spectral Clustering) produces compact and uniform superpixels with low computational costs. Basically, a normalized cuts formulation of the superpixel segmentation is adopted based on a similarity metric that measures the color similarity and space proximity between image pixels. LSC is of linear computational complexity and high memory efficiency and is able to preserve global properties of images</remarks>
        </member>
        <member name="M:Emgu.CV.XImgproc.SuperpixelLSC.#ctor(Emgu.CV.IInputArray,System.Int32,System.Single)">
            <summary>
            The function initializes a SuperpixelLSC object for the input image. 
            </summary>
            <param name="image">Image to segment</param>
            <param name="regionSize">Chooses an average superpixel size measured in pixels</param>
            <param name="ratio">Chooses the enforcement of superpixel compactness factor of superpixel</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.SuperpixelLSC.GetLabels(Emgu.CV.IOutputArray)">
            <summary>
            Returns the segmentation labeling of the image.
            Each label represents a superpixel, and each pixel is assigned to one superpixel label.
            </summary>
            <param name="labels">A CV_32SC1 integer array containing the labels of the superpixel segmentation. The labels are in the range [0, NumberOfSuperpixels].</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.SuperpixelLSC.GetLabelContourMask(Emgu.CV.IOutputArray,System.Boolean)">
            <summary>
            Returns the mask of the superpixel segmentation stored in SuperpixelLSC object.
            </summary>
            <param name="image">Return: CV_8U1 image mask where -1 indicates that the pixel is a superpixel border, and 0 otherwise.</param>
            <param name="thickLine">If false, the border is only one pixel wide, otherwise all pixels at the border are masked.</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.SuperpixelLSC.Iterate(System.Int32)">
            <summary>
            Calculates the superpixel segmentation on a given image with the initialized parameters in the SuperpixelLSC object.
            This function can be called again without the need of initializing the algorithm with createSuperpixelLSC(). This save the computational cost of allocating memory for all the structures of the algorithm.
            </summary>
            <param name="numIterations">Number of iterations. Higher number improves the result.</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.SuperpixelLSC.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this object.
            </summary>
        </member>
        <member name="P:Emgu.CV.XImgproc.SuperpixelLSC.NumberOfSuperpixels">
            <summary>
            Calculates the actual amount of superpixels on a given segmentation computed and stored in SuperpixelLSC object
            </summary>
        </member>
        <member name="T:Emgu.CV.XImgproc.SupperpixelSEEDS">
            <summary>
            Class implementing the SEEDS (Superpixels Extracted via Energy-Driven Sampling) superpixels algorithm described in Michael Van den Bergh, Xavier Boix, Gemma Roig, Benjamin de Capitani, and Luc Van Gool. Seeds: Superpixels extracted via energy-driven sampling. In Computer VisionECCV 2012, pages 1326. Springer, 2012.
            </summary>
        </member>
        <member name="M:Emgu.CV.XImgproc.SupperpixelSEEDS.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            The function initializes a SuperpixelSEEDS object for the input image.
            </summary>
            <param name="imageWidth">Image width</param>
            <param name="imageHeight">Image height</param>
            <param name="imageChannels">Number of channels of the image.</param>
            <param name="numSuperpixels">Desired number of superpixels. Note that the actual number may be smaller due to restrictions (depending on the image size and num_levels). Use getNumberOfSuperpixels() to get the actual number.</param>
            <param name="numLevels">Number of block levels. The more levels, the more accurate is the segmentation, but needs more memory and CPU time.</param>
            <param name="prior">Enable 3x3 shape smoothing term if >0. A larger value leads to smoother shapes. prior must be in the range [0, 5].</param>
            <param name="histogramBins">Number of histogram bins.</param>
            <param name="doubleStep">If true, iterate each block level twice for higher accuracy.</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.SupperpixelSEEDS.GetLabels(Emgu.CV.IOutputArray)">
            <summary>
            Returns the segmentation labeling of the image.
            Each label represents a superpixel, and each pixel is assigned to one superpixel label.
            </summary>
            <param name="labels">Return: A CV_32UC1 integer array containing the labels of the superpixel segmentation. The labels are in the range [0, NumberOfSuperpixels].</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.SupperpixelSEEDS.GetLabelContourMask(Emgu.CV.IOutputArray,System.Boolean)">
            <summary>
            Returns the mask of the superpixel segmentation stored in SuperpixelSEEDS object.
            </summary>
            <param name="image">Return: CV_8UC1 image mask where -1 indicates that the pixel is a superpixel border, and 0 otherwise.</param>
            <param name="thickLine">If false, the border is only one pixel wide, otherwise all pixels at the border are masked.</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.SupperpixelSEEDS.Iterate(Emgu.CV.IInputArray,System.Int32)">
            <summary>
            Calculates the superpixel segmentation on a given image with the initialized parameters in the SuperpixelSEEDS object.
            </summary>
            <remarks>This function can be called again for other images without the need of initializing the algorithm with createSuperpixelSEEDS(). This save the computational cost of allocating memory for all the structures of the algorithm.</remarks>
            <param name="img">Input image. Supported formats: CV_8U, CV_16U, CV_32F. Image size &amp; number of channels must match with the initialized image size &amp; channels with the function createSuperpixelSEEDS(). It should be in HSV or Lab color space. Lab is a bit better, but also slower.</param>
            <param name="numIterations">Number of pixel level iterations. Higher number improves the result.</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.SupperpixelSEEDS.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this object.
            </summary>
        </member>
        <member name="P:Emgu.CV.XImgproc.SupperpixelSEEDS.NumberOfSuperpixels">
            <summary>
            The function computes the superpixels segmentation of an image with the parameters initialized with the function createSuperpixelSEEDS().
            </summary>
        </member>
        <member name="T:Emgu.CV.XImgproc.SupperpixelSLIC">
            <summary>
            Class implementing the SLIC (Simple Linear Iterative Clustering) superpixels algorithm described in Radhakrishna Achanta, Appu Shaji, Kevin Smith, Aurelien Lucchi, Pascal Fua, and Sabine Susstrunk. Slic superpixels compared to state-of-the-art superpixel methods. IEEE Trans. Pattern Anal. Mach. Intell., 34(11):22742282, nov 2012.
            </summary>
        </member>
        <member name="M:Emgu.CV.XImgproc.SupperpixelSLIC.#ctor(Emgu.CV.IInputArray,Emgu.CV.XImgproc.SupperpixelSLIC.Algorithm,System.Int32,System.Single)">
            <summary>
            The function initializes a SuperpixelSLIC object for the input image. It sets the parameters of choosed superpixel algorithm, which are: region_size and ruler. It preallocate some buffers for future computing iterations over the given image. 
            </summary>
            <param name="image">Image to segment</param>
            <param name="algorithm">Chooses the algorithm variant to use</param>
            <param name="regionSize">Chooses an average superpixel size measured in pixels</param>
            <param name="ruler">Chooses the enforcement of superpixel smoothness factor of superpixel</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.SupperpixelSLIC.GetLabels(Emgu.CV.IOutputArray)">
            <summary>
            Returns the segmentation labeling of the image. Each label represents a superpixel, and each pixel is assigned to one superpixel label.
            </summary>
            <param name="labels">A CV_32SC1 integer array containing the labels of the superpixel segmentation. The labels are in the range [0, NumberOfSuperpixels].</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.SupperpixelSLIC.GetLabelContourMask(Emgu.CV.IOutputArray,System.Boolean)">
            <summary>
            Returns the mask of the superpixel segmentation stored in SuperpixelSLIC object.
            </summary>
            <param name="image">CV_8U1 image mask where -1 indicates that the pixel is a superpixel border, and 0 otherwise.</param>
            <param name="thickLine">If false, the border is only one pixel wide, otherwise all pixels at the border are masked.</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.SupperpixelSLIC.Iterate(System.Int32)">
            <summary>
            Calculates the superpixel segmentation on a given image with the initialized parameters in the SuperpixelSLIC object.
            This function can be called again without the need of initializing the algorithm with createSuperpixelSLIC(). This save the computational cost of allocating memory for all the structures of the algorithm.
            </summary>
            <param name="numIterations">Number of iterations. Higher number improves the result.</param>
        </member>
        <member name="M:Emgu.CV.XImgproc.SupperpixelSLIC.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this object.
            </summary>
        </member>
        <member name="P:Emgu.CV.XImgproc.SupperpixelSLIC.NumberOfSuperpixels">
            <summary>
            Calculates the actual amount of superpixels on a given segmentation computed and stored in SuperpixelSLIC object. 
            </summary>
        </member>
        <member name="T:Emgu.CV.XImgproc.SupperpixelSLIC.Algorithm">
            <summary>
            The algorithm to use
            </summary>
        </member>
        <member name="F:Emgu.CV.XImgproc.SupperpixelSLIC.Algorithm.SLIC">
            <summary>
            SLIC segments image using a desired region_size
            </summary>
        </member>
        <member name="F:Emgu.CV.XImgproc.SupperpixelSLIC.Algorithm.SLICO">
            <summary>
            SLICO will choose an adaptive compactness factor.
            </summary>
        </member>
        <member name="T:Emgu.CV.XImgproc.DtFilterType">
            <summary>
            Domain Transform filter type
            </summary>
        </member>
        <member name="F:Emgu.CV.XImgproc.DtFilterType.NC">
            <summary>
            NC
            </summary>
        </member>
        <member name="F:Emgu.CV.XImgproc.DtFilterType.IC">
            <summary>
            IC
            </summary>
        </member>
        <member name="F:Emgu.CV.XImgproc.DtFilterType.RF">
            <summary>
            RF
            </summary>
        </member>
        <member name="T:Emgu.CV.XImgproc.WMFWeightType">
            <summary>
            Weight type
            </summary>
        </member>
        <member name="F:Emgu.CV.XImgproc.WMFWeightType.Exp">
            <summary>
            exp(-|I1-I2|^2/(2*sigma^2))
            </summary>
        </member>
        <member name="F:Emgu.CV.XImgproc.WMFWeightType.Iv1">
            <summary>
            (|I1-I2|+sigma)^-1
            </summary>
        </member>
        <member name="F:Emgu.CV.XImgproc.WMFWeightType.Iv2">
            <summary>
            (|I1-I2|^2+sigma^2)^-1
            </summary>
        </member>
        <member name="F:Emgu.CV.XImgproc.WMFWeightType.Cos">
            <summary>
            dot(I1,I2)/(|I1|*|I2|)
            </summary>
        </member>
        <member name="F:Emgu.CV.XImgproc.WMFWeightType.Jac">
            <summary>
            (min(r1,r2)+min(g1,g2)+min(b1,b2))/(max(r1,r2)+max(g1,g2)+max(b1,b2))
            </summary>
        </member>
        <member name="F:Emgu.CV.XImgproc.WMFWeightType.Off">
            <summary>
            unweighted
            </summary>
        </member>
        <member name="T:Emgu.CV.XImgproc.ThinningTypes">
            <summary>
            Thinning type
            </summary>
        </member>
        <member name="F:Emgu.CV.XImgproc.ThinningTypes.ZhangSuen">
            <summary>
            Thinning technique of Zhang-Suen
            </summary>
        </member>
        <member name="F:Emgu.CV.XImgproc.ThinningTypes.GuoHall">
            <summary>
            Thinning technique of Guo-Hall
            </summary>
        </member>
        <member name="T:Emgu.CV.XObjdetect.WBDetector">
            <summary>
            WaldBoost detector.
            </summary>
        </member>
        <member name="M:Emgu.CV.XObjdetect.WBDetector.#ctor">
            <summary>
            Create instance of WBDetector.
            </summary>
        </member>
        <member name="M:Emgu.CV.XObjdetect.WBDetector.Read(Emgu.CV.FileNode)">
            <summary>
            Read detector from FileNode.
            </summary>
            <param name="node">FileNode for input</param>
        </member>
        <member name="M:Emgu.CV.XObjdetect.WBDetector.Write(Emgu.CV.FileStorage)">
            <summary>
            Write detector to FileStorage.
            </summary>
            <param name="fs">FileStorage for output</param>
        </member>
        <member name="M:Emgu.CV.XObjdetect.WBDetector.Train(System.String,System.String)">
            <summary>
            Train WaldBoost detector.
            </summary>
            <param name="posSamples">Path to directory with cropped positive samples</param>
            <param name="negImgs">Path to directory with negative (background) images</param>
        </member>
        <member name="M:Emgu.CV.XObjdetect.WBDetector.Detect(Emgu.CV.Mat,Emgu.CV.Util.VectorOfRect,Emgu.CV.Util.VectorOfDouble)">
            <summary>
            Detect objects on image using WaldBoost detector.
            </summary>
            <param name="image">Input image for detection</param>
            <param name="bboxes">Bounding boxes coordinates output vector</param>
            <param name="confidences">Confidence values for bounding boxes output vector</param>
        </member>
        <member name="M:Emgu.CV.XObjdetect.WBDetector.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this WBDetector.
            </summary>
        </member>
        <member name="T:Emgu.CV.XObjdetect.XObjdetectInvoke">
            <summary>
            Class that contains entry points for the XObjdetect module.
            </summary>
        </member>
        <member name="T:Emgu.CV.XPhoto.XPhotoInvoke">
            <summary>
            Class that contains entry points for the XPhoto module.
            </summary>
        </member>
        <member name="M:Emgu.CV.XPhoto.XPhotoInvoke.DctDenoising(Emgu.CV.Mat,Emgu.CV.Mat,System.Double,System.Int32)">
            <summary>
            The function implements simple dct-based denoising, link: http://www.ipol.im/pub/art/2011/ys-dct/.
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="sigma">Expected noise standard deviation</param>
            <param name="psize">Size of block side where dct is computed</param>
        </member>
        <member name="M:Emgu.CV.XPhoto.XPhotoInvoke.Inpaint(Emgu.CV.Mat,Emgu.CV.Mat,Emgu.CV.Mat,Emgu.CV.XPhoto.XPhotoInvoke.InpaintType)">
            <summary>
            The function implements different single-image inpainting algorithms
            </summary>
            <param name="src">source image, it could be of any type and any number of channels from 1 to 4. In case of 3- and 4-channels images the function expect them in CIELab colorspace or similar one, where first color component shows intensity, while second and third shows colors. Nonetheless you can try any colorspaces.</param>
            <param name="mask">mask (CV_8UC1), where non-zero pixels indicate valid image area, while zero pixels indicate area to be inpainted</param>
            <param name="dst">destination image</param>
            <param name="algorithmType">algorithm type</param>
        </member>
        <member name="M:Emgu.CV.XPhoto.XPhotoInvoke.ApplyChannelGains(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single,System.Single,System.Single)">
            <summary>
            Implements an efficient fixed-point approximation for applying channel gains, which is the last step of multiple white balance algorithms.
            </summary>
            <param name="src">Input three-channel image in the BGR color space (either CV_8UC3 or CV_16UC3)</param>
            <param name="dst">Output image of the same size and type as src.</param>
            <param name="gainB">Gain for the B channel</param>
            <param name="gainG">Gain for the G channel</param>
            <param name="gainR">Gain for the R channel</param>
        </member>
        <member name="M:Emgu.CV.XPhoto.XPhotoInvoke.Bm3dDenoising(Emgu.CV.IInputArray,Emgu.CV.IInputOutputArray,Emgu.CV.IOutputArray,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,Emgu.CV.CvEnum.NormType,Emgu.CV.XPhoto.Bm3dSteps,Emgu.CV.XPhoto.TransformTypes)">
            <summary>
            Performs image denoising using the Block-Matching and 3D-filtering algorithm with several computational optimizations. Noise expected to be a gaussian white noise.
            </summary>
            <param name="src">Input 8-bit or 16-bit 1-channel image.</param>
            <param name="dstStep1">Output image of the first step of BM3D with the same size and type as src.</param>
            <param name="dstStep2">Output image of the second step of BM3D with the same size and type as src.</param>
            <param name="h">Parameter regulating filter strength. Big h value perfectly removes noise but also removes image details, smaller h value preserves details but also preserves some noise.</param>
            <param name="templateWindowSize">Size in pixels of the template patch that is used for block-matching. Should be power of 2.</param>
            <param name="searchWindowSize">Size in pixels of the window that is used to perform block-matching. Affect performance linearly: greater searchWindowsSize - greater denoising time. Must be larger than templateWindowSize.</param>
            <param name="blockMatchingStep1">Block matching threshold for the first step of BM3D (hard thresholding), i.e. maximum distance for which two blocks are considered similar. Value expressed in euclidean distance.</param>
            <param name="blockMatchingStep2">Block matching threshold for the second step of BM3D (Wiener filtering), i.e. maximum distance for which two blocks are considered similar. Value expressed in euclidean distance.</param>
            <param name="groupSize">Maximum size of the 3D group for collaborative filtering.</param>
            <param name="slidingStep">Sliding step to process every next reference block.</param>
            <param name="beta">Kaiser window parameter that affects the sidelobe attenuation of the transform of the window. Kaiser window is used in order to reduce border effects. To prevent usage of the window, set beta to zero.</param>
            <param name="normType">Norm used to calculate distance between blocks. L2 is slower than L1 but yields more accurate results.</param>
            <param name="step">Step of BM3D to be executed. Possible variants are: step 1, step 2, both steps.</param>
            <param name="transformType">	Type of the orthogonal transform used in collaborative filtering step. Currently only Haar transform is supported.</param>
            <remarks> <c href="http://www.cs.tut.fi/~foi/GCF-BM3D/BM3D_TIP_2007.pdf"/>   </remarks>
        </member>
        <member name="M:Emgu.CV.XPhoto.XPhotoInvoke.Bm3dDenoising(Emgu.CV.IInputArray,Emgu.CV.IOutputArray,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,Emgu.CV.CvEnum.NormType,Emgu.CV.XPhoto.Bm3dSteps,Emgu.CV.XPhoto.TransformTypes)">
            <summary>
            Performs image denoising using the Block-Matching and 3D-filtering algorithm with several computational optimizations. Noise expected to be a gaussian white noise.
            </summary>
            <param name="src">Input 8-bit or 16-bit 1-channel image.</param>
            <param name="dst">Output image with the same size and type as src.</param>
            <param name="h">Parameter regulating filter strength. Big h value perfectly removes noise but also removes image details, smaller h value preserves details but also preserves some noise.</param>
            <param name="templateWindowSize">Size in pixels of the template patch that is used for block-matching. Should be power of 2.</param>
            <param name="searchWindowSize">Size in pixels of the window that is used to perform block-matching. Affect performance linearly: greater searchWindowsSize - greater denoising time. Must be larger than templateWindowSize.</param>
            <param name="blockMatchingStep1">Block matching threshold for the first step of BM3D (hard thresholding), i.e. maximum distance for which two blocks are considered similar. Value expressed in euclidean distance.</param>
            <param name="blockMatchingStep2">Block matching threshold for the second step of BM3D (Wiener filtering), i.e. maximum distance for which two blocks are considered similar. Value expressed in euclidean distance.</param>
            <param name="groupSize">Maximum size of the 3D group for collaborative filtering.</param>
            <param name="slidingStep">Sliding step to process every next reference block.</param>
            <param name="beta">Kaiser window parameter that affects the sidelobe attenuation of the transform of the window. Kaiser window is used in order to reduce border effects. To prevent usage of the window, set beta to zero.</param>
            <param name="normType">Norm used to calculate distance between blocks. L2 is slower than L1 but yields more accurate results.</param>
            <param name="step">Step of BM3D to be executed. Allowed are only BM3D_STEP1 and BM3D_STEPALL. BM3D_STEP2 is not allowed as it requires basic estimate to be present.</param>
            <param name="transformType">Type of the orthogonal transform used in collaborative filtering step. Currently only Haar transform is supported.</param>
            <remarks> <c href="http://www.cs.tut.fi/~foi/GCF-BM3D/BM3D_TIP_2007.pdf"/> </remarks>
        </member>
        <member name="T:Emgu.CV.XPhoto.XPhotoInvoke.InpaintType">
            <summary>
            Inpaint type
            </summary>
        </member>
        <member name="F:Emgu.CV.XPhoto.XPhotoInvoke.InpaintType.Shiftmap">
            <summary>
            Shift map
            </summary>
        </member>
        <member name="T:Emgu.CV.XPhoto.GrayworldWB">
            <summary>
            Gray-world white balance algorithm.
            This algorithm scales the values of pixels based on a gray-world assumption which states that the average of all channels should result in a gray image.
            It adds a modification which thresholds pixels based on their saturation value and only uses pixels below the provided threshold in finding average pixel values.
            Saturation is calculated using the following for a 3-channel RGB image per pixel I and is in the range [0, 1]:
            Saturation[I]= max(R,G,B)min(R,G,B) / max(R,G,B)
            A threshold of 1 means that all pixels are used to white-balance, while a threshold of 0 means no pixels are used. Lower thresholds are useful in white-balancing saturated images.
            Currently supports images of type CV_8UC3 and CV_16UC3.
            </summary>
        </member>
        <member name="T:Emgu.CV.XPhoto.WhiteBalancer">
            <summary>
            The base class for auto white balance algorithms.
            </summary>
        </member>
        <member name="F:Emgu.CV.XPhoto.WhiteBalancer._whiteBalancerPtr">
            <summary>
            Pointer to the native white balancer object
            </summary>
        </member>
        <member name="M:Emgu.CV.XPhoto.WhiteBalancer.BalanceWhite(Emgu.CV.IInputArray,Emgu.CV.IOutputArray)">
            <summary>
            Applies white balancing to the input image.
            </summary>
            <param name="src">Input image</param>
            <param name="dst">White balancing result</param>
        </member>
        <member name="M:Emgu.CV.XPhoto.WhiteBalancer.DisposeObject">
            <summary>
            Reset the pointer to the native white balancer object
            </summary>
        </member>
        <member name="M:Emgu.CV.XPhoto.GrayworldWB.#ctor">
            <summary>
            Creates a gray-world white balancer
            </summary>
        </member>
        <member name="M:Emgu.CV.XPhoto.GrayworldWB.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this white balancer
            </summary>
        </member>
        <member name="P:Emgu.CV.XPhoto.GrayworldWB.SaturationThreshold">
            <summary>
            Maximum saturation for a pixel to be included in the gray-world assumption
            </summary>
        </member>
        <member name="T:Emgu.CV.XPhoto.LearningBasedWB">
            <summary>
            More sophisticated learning-based automatic white balance algorithm.
            As GrayworldWB, this algorithm works by applying different gains to the input image channels, but their computation is a bit more involved compared to the simple gray-world assumption. 
            More details about the algorithm can be found in: Dongliang Cheng, Brian Price, Scott Cohen, and Michael S Brown. Effective learning-based illuminant estimation using simple features. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 10001008, 2015.
            To mask out saturated pixels this function uses only pixels that satisfy the following condition:
            max(R,G,B) / range_max_val &lt; saturation_thresh 
            Currently supports images of type CV_8UC3 and CV_16UC3.
            </summary>
        </member>
        <member name="M:Emgu.CV.XPhoto.LearningBasedWB.#ctor">
            <summary>
            Create a learning based white balancer.
            </summary>
        </member>
        <member name="M:Emgu.CV.XPhoto.LearningBasedWB.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this white balancer
            </summary>
        </member>
        <member name="P:Emgu.CV.XPhoto.LearningBasedWB.RangeMaxVal">
            <summary>
            Maximum possible value of the input image (e.g. 255 for 8 bit images, 4095 for 12 bit images)
            </summary>
        </member>
        <member name="P:Emgu.CV.XPhoto.LearningBasedWB.SaturationThreshold">
            <summary>
            Threshold that is used to determine saturated pixels, i.e. pixels where at least one of the channels exceeds saturation_threshold x range_max_val are ignored.
            </summary>
        </member>
        <member name="P:Emgu.CV.XPhoto.LearningBasedWB.HistBinNum">
            <summary>
            Defines the size of one dimension of a three-dimensional RGB histogram that is used internally by the algorithm. It often makes sense to increase the number of bins for images with higher bit depth (e.g. 256 bins for a 12 bit image).
            </summary>
        </member>
        <member name="T:Emgu.CV.XPhoto.SimpleWB">
            <summary>
            A simple white balance algorithm that works by independently stretching each of the input image channels to the specified range. For increased robustness it ignores the top and bottom p% of pixel values.
            </summary>
        </member>
        <member name="M:Emgu.CV.XPhoto.SimpleWB.#ctor">
            <summary>
            Creates a simple white balancer
            </summary>
        </member>
        <member name="M:Emgu.CV.XPhoto.SimpleWB.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this white balancer
            </summary>
        </member>
        <member name="P:Emgu.CV.XPhoto.SimpleWB.InputMin">
            <summary>
            Input image range minimum value
            </summary>
        </member>
        <member name="P:Emgu.CV.XPhoto.SimpleWB.InputMax">
            <summary>
            Input image range maximum value
            </summary>
        </member>
        <member name="P:Emgu.CV.XPhoto.SimpleWB.OutputMin">
            <summary>
            Output image range minimum value
            </summary>
        </member>
        <member name="P:Emgu.CV.XPhoto.SimpleWB.OutputMax">
            <summary>
            Output image range maximum value
            </summary>
        </member>
        <member name="P:Emgu.CV.XPhoto.SimpleWB.P">
            <summary>
            Percent of top/bottom values to ignore
            </summary>
        </member>
        <member name="T:Emgu.CV.XPhoto.TransformTypes">
            <summary>
            BM3D denoising transform types
            </summary>
        </member>
        <member name="F:Emgu.CV.XPhoto.TransformTypes.Haar">
            <summary>
            Un-normalized Haar transform
            </summary>
        </member>
        <member name="T:Emgu.CV.XPhoto.Bm3dSteps">
            <summary>
            BM3D steps
            </summary>
        </member>
        <member name="F:Emgu.CV.XPhoto.Bm3dSteps.All">
            <summary>
            Execute all steps of the algorithm 
            </summary>
        </member>
        <member name="F:Emgu.CV.XPhoto.Bm3dSteps.Step1">
            <summary>
            Execute only first step of the algorithm 
            </summary>
        </member>
        <member name="F:Emgu.CV.XPhoto.Bm3dSteps.Step2">
            <summary>
            Execute only second step of the algorithm
            </summary>
        </member>
    </members>
</doc>
